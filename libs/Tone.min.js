!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.Tone = e() : t.Tone = e() }("undefined" != typeof self ? self : this, () => {
  var s = { 18: t => { t.exports = function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }, t.exports.__esModule = !0, t.exports.default = t.exports }, 113: t => { t.exports = function (t, e) { (null == e || e > t.length) && (e = t.length); for (var s = 0, i = new Array(e); s < e; s++)i[s] = t[s]; return i }, t.exports.__esModule = !0, t.exports.default = t.exports }, 327: (t, e, s) => { var i = s(564).default; t.exports = function (t, e) { if ("object" != i(t) || !t) return t; var s = t[Symbol.toPrimitive]; if (void 0 === s) return ("string" === e ? String : Number)(t); s = s.call(t, e || "default"); if ("object" != i(s)) return s; throw new TypeError("@@toPrimitive must return a primitive value.") }, t.exports.__esModule = !0, t.exports.default = t.exports }, 474: t => { t.exports = function (t, e) { var s = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != s) { var i, n, r, o, a = [], h = !0, c = !1; try { if (r = (s = s.call(t)).next, 0 === e) { if (Object(s) !== s) return; h = !1 } else for (; !(h = (i = r.call(s)).done) && (a.push(i.value), a.length !== e); h = !0); } catch (t) { c = !0, n = t } finally { try { if (!h && null != s.return && (o = s.return(), Object(o) !== o)) return } finally { if (c) throw n } } return a } }, t.exports.__esModule = !0, t.exports.default = t.exports }, 498: (t, e, s) => { var i = s(564).default, n = s(327); t.exports = function (t) { t = n(t, "string"); return "symbol" == i(t) ? t : t + "" }, t.exports.__esModule = !0, t.exports.default = t.exports }, 564: e => { function s(t) { return e.exports = s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, e.exports.__esModule = !0, e.exports.default = e.exports, s(t) } e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports }, 569: t => { t.exports = function (t) { if (Array.isArray(t)) return t }, t.exports.__esModule = !0, t.exports.default = t.exports }, 744: (t, e, s) => { var i = s(113); t.exports = function (t, e) { if (t) { if ("string" == typeof t) return i(t, e); var s = Object.prototype.toString.call(t).slice(8, -1); return "Map" === (s = "Object" === s && t.constructor ? t.constructor.name : s) || "Set" === s ? Array.from(t) : "Arguments" === s || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s) ? i(t, e) : void 0 } }, t.exports.__esModule = !0, t.exports.default = t.exports }, 805: t => { t.exports = function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }, t.exports.__esModule = !0, t.exports.default = t.exports }, 821: (t, e, s) => { var i = s(569), n = s(474), r = s(744), o = s(18); t.exports = function (t, e) { return i(t) || n(t, e) || r(t, e) || o() }, t.exports.__esModule = !0, t.exports.default = t.exports }, 871: function (t, e, s) { !function (t, c, s, e) { "use strict"; function u(t, e, s) { return { endTime: e, insertTime: s, type: "exponentialRampToValue", value: t } } function p(t, e, s) { return { endTime: e, insertTime: s, type: "linearRampToValue", value: t } } function d(t, e) { return { startTime: e, type: "setValue", value: t } } function f(t, e, s) { return { duration: s, startTime: e, type: "setValueCurve", values: t } } function l(t, e, s) { var i = s.startTime, n = s.target, s = s.timeConstant; return n + (e - n) * Math.exp((i - t) / s) } function _(t) { return "exponentialRampToValue" === t.type } function m(t) { return "linearRampToValue" === t.type } function g(t) { return _(t) || m(t) } function v(t) { return "setValue" === t.type } function y(t) { return "setValueCurve" === t.type } function x(t, e, s, i) { var n = t[e]; return void 0 === n ? i : g(n) || v(n) ? n.value : y(n) ? n.values[n.values.length - 1] : l(s, x(t, e - 1, n.startTime, i), n) } function w(t, e, s, i, n) { return void 0 === s ? [i.insertTime, n] : g(s) ? [s.endTime, s.value] : v(s) ? [s.startTime, s.value] : y(s) ? [s.startTime + s.duration, s.values[s.values.length - 1]] : [s.startTime, x(t, e - 1, s.startTime, n)] } function b(t) { return "cancelAndHold" === t.type } function T(t) { return "cancelScheduledValues" === t.type } function S(t) { return b(t) || T(t) ? t.cancelTime : _(t) || m(t) ? t.endTime : t.startTime } function k(t, e, s, i) { var n = i.endTime, i = i.value; return s === i ? i : 0 < s && 0 < i || s < 0 && i < 0 ? s * Math.pow(i / s, (t - e) / (n - e)) : 0 } function A(t, e, s, i) { return s + (t - e) / (i.endTime - e) * (i.value - s) } function C(t) { return "setTarget" === t.type } e = e(function t(e) { s(this, t), this._automationEvents = [], this._currenTime = 0, this._defaultValue = e }, [{ key: Symbol.iterator, value: function () { return this._automationEvents[Symbol.iterator]() } }, { key: "add", value: function (e) { var s = S(e); if (b(e) || T(e)) { var t = this._automationEvents.findIndex(function (t) { return T(e) && y(t) ? t.startTime + t.duration >= s : S(t) >= s }), i = this._automationEvents[t]; if (-1 !== t && (this._automationEvents = this._automationEvents.slice(0, t)), b(e)) { var n = this._automationEvents[this._automationEvents.length - 1]; if (void 0 !== i && g(i)) { if (void 0 !== n && C(n)) throw new Error("The internal list is malformed."); var t = void 0 === n ? i.insertTime : y(n) ? n.startTime + n.duration : S(n), r = void 0 === n ? this._defaultValue : y(n) ? n.values[n.values.length - 1] : n.value, t = (_(i) ? k : A)(s, t, r, i), r = (_(i) ? u : p)(t, s, this._currenTime); this._automationEvents.push(r) } if (void 0 !== n && C(n) && this._automationEvents.push(d(this.getValue(s), s)), void 0 !== n && y(n) && n.startTime + n.duration > s) { var i = s - n.startTime, t = (n.values.length - 1) / n.duration, o = Math.max(2, 1 + Math.ceil(i * t)), a = i / (o - 1) * t, h = n.values.slice(0, o); if (a < 1) for (var c = 1; c < o; c += 1) { var l = a * c % 1; h[c] = n.values[c - 1] * (1 - l) + n.values[c] * l } this._automationEvents[this._automationEvents.length - 1] = f(h, n.startTime, i) } } } else { r = this._automationEvents.findIndex(function (t) { return S(t) > s }), t = -1 === r ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[r - 1]; if (void 0 !== t && y(t) && S(t) + t.duration > s) return !1; i = _(e) ? u(e.value, e.endTime, this._currenTime) : m(e) ? p(e.value, s, this._currenTime) : e; if (-1 === r) this._automationEvents.push(i); else { if (y(e) && s + e.duration > S(this._automationEvents[r])) return !1; this._automationEvents.splice(r, 0, i) } } return !0 } }, { key: "flush", value: function (e) { var t, s, i = this._automationEvents.findIndex(function (t) { return S(t) > e }); 1 < i && (s = (t = this._automationEvents.slice(i - 1))[0], C(s) && t.unshift(d(x(this._automationEvents, i - 2, s.startTime, this._defaultValue), s.startTime)), this._automationEvents = t) } }, { key: "getValue", value: function (e) { if (0 === this._automationEvents.length) return this._defaultValue; var t, s, i, n, r, o = this._automationEvents.findIndex(function (t) { return S(t) > e }), a = this._automationEvents[o], o = (-1 === o ? this._automationEvents.length : o) - 1, h = this._automationEvents[o]; return void 0 !== h && C(h) && (void 0 === a || !g(a) || a.insertTime > e) ? l(e, x(this._automationEvents, o - 1, h.startTime, this._defaultValue), h) : void 0 === h || !v(h) || void 0 !== a && g(a) ? void 0 !== h && y(h) && (void 0 === a || !g(a) || h.startTime + h.duration > e) ? e < h.startTime + h.duration ? (i = e, t = (n = h).duration, s = n.startTime, n = n.values, s = (i - s) / t * ((i = n).length - 1), t = Math.floor(s), n = Math.ceil(s), t === n ? i[t] : (1 - (s - t)) * i[t] + (1 - (n - s)) * i[n]) : h.values[h.values.length - 1] : void 0 === h || !g(h) || void 0 !== a && g(a) ? void 0 !== a && _(a) ? (t = w(this._automationEvents, o, h, a, this._defaultValue), i = (s = c(t, 2))[0], n = s[1], k(e, i, n, a)) : void 0 !== a && m(a) ? (o = w(this._automationEvents, o, h, a, this._defaultValue), r = (o = c(o, 2))[0], o = o[1], A(e, r, o, a)) : this._defaultValue : h.value : h.value } }]); t.AutomationEventList = e, t.createCancelAndHoldAutomationEvent = function (t) { return { cancelTime: t, type: "cancelAndHold" } }, t.createCancelScheduledValuesAutomationEvent = function (t) { return { cancelTime: t, type: "cancelScheduledValues" } }, t.createExponentialRampToValueAutomationEvent = function (t, e) { return { endTime: e, type: "exponentialRampToValue", value: t } }, t.createLinearRampToValueAutomationEvent = function (t, e) { return { endTime: e, type: "linearRampToValue", value: t } }, t.createSetTargetAutomationEvent = function (t, e, s) { return { startTime: e, target: t, timeConstant: s, type: "setTarget" } }, t.createSetValueAutomationEvent = d, t.createSetValueCurveAutomationEvent = f }(e, s(821), s(805), s(989)) }, 989: (t, e, s) => { var n = s(498); function i(t, e) { for (var s = 0; s < e.length; s++) { var i = e[s]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, n(i.key), i) } } t.exports = function (t, e, s) { return e && i(t.prototype, e), s && i(t, s), Object.defineProperty(t, "prototype", { writable: !1 }), t }, t.exports.__esModule = !0, t.exports.default = t.exports } }, i = {}; function Dm(t) { var e = i[t]; if (void 0 !== e) return e.exports; e = i[t] = { exports: {} }; return s[t].call(e.exports, e, e.exports, Dm), e.exports } Dm.d = (t, e) => { for (var s in e) Dm.o(e, s) && !Dm.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: e[s] }) }, Dm.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), Dm.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var Mm = {}; return (() => {
    "use strict"; Dm.r(Mm), Dm.d(Mm, { AMOscillator: () => sf, AMSynth: () => If, Abs: () => yf, Add: () => lf, AmplitudeEnvelope: () => Ef, Analyser: () => tm, AudioToGain: () => ef, AutoFilter: () => g_, AutoPanner: () => y_, AutoWah: () => w_, BaseContext: () => ed, BiquadFilter: () => Ff, BitCrusher: () => T_, Buffer: () => km, BufferSource: () => Cm, Buffers: () => Am, Channel: () => am, Chebyshev: () => k_, Chorus: () => M_, Clock: () => Md, Compressor: () => pm, Context: () => sd, Convolver: () => vm, CrossFade: () => __, DCMeter: () => nm, Delay: () => Ed, Destination: () => xm, Distortion: () => E_, Draw: () => Tm, DuoSynth: () => jf, EQ3: () => gm, Emitter: () => td, Envelope: () => Cf, FFT: () => im, FMOscillator: () => nf, FMSynth: () => Lf, FatOscillator: () => of, FeedbackCombFilter: () => Hf, FeedbackDelay: () => q_, Filter: () => Vf, Follower: () => x_, Freeverb: () => P_, Frequency: () => function (t, e) { return new gd(b(), t, e) }, FrequencyClass: () => gd, FrequencyEnvelope: () => Nf, FrequencyShifter: () => F_, Gain: () => C, GainToAudio: () => xf, Gate: () => dm, GrainPlayer: () => vf, GreaterThan: () => Sf, GreaterThanZero: () => Tf, IntervalTimeline: () => Pd, JCReverb: () => W_, LFO: () => df, Limiter: () => fm, Listener: () => bm, Loop: () => i_, LowpassCombFilter: () => Jf, Master: () => wm, MembraneSynth: () => Bf, Merge: () => C_, MetalSynth: () => Wf, Meter: () => sm, MidSideCompressor: () => _m, MidSideMerge: () => Y_, MidSideSplit: () => X_, Midi: () => function (t, e) { return new Vd(b(), t, e) }, MidiClass: () => Vd, Mono: () => hm, MonoSynth: () => Pf, MultibandCompressor: () => mm, MultibandSplit: () => cm, Multiply: () => q, Negate: () => wf, Noise: () => Xd, NoiseSynth: () => Uf, Offline: () => function (t, e) { return _(this, arguments, void 0, function* (t, e, s = 2, i = b().sampleRate) { const n = b(), r = new nd(s, e, i); ad(r), yield t(r); s = r.render(), ad(n), e = yield s; return new w(e) }) }, OfflineContext: () => nd, OmniOscillator: () => cf, OnePoleFilter: () => $f, Oscillator: () => E, PWMOscillator: () => af, PanVol: () => om, Panner: () => v_, Panner3D: () => lm, Param: () => k, Part: () => n_, Pattern: () => d_, Phaser: () => Q_, PingPongDelay: () => U_, PitchShift: () => G_, Player: () => mf, Players: () => gf, PluckSynth: () => Kf, PolySynth: () => t_, Pow: () => Bd, PulseOscillator: () => rf, Recorder: () => um, Reverb: () => Z_, Sampler: () => e_, Scale: () => uf, ScaleExp: () => kf, Sequence: () => f_, Signal: () => O, Solo: () => F, Split: () => A_, StateTimeline: () => xd, StereoWidener: () => $_, Subtract: () => bf, SyncedSignal: () => Af, Synth: () => Rf, Ticks: () => function (t, e) { return new D(b(), t, e) }, TicksClass: () => D, Time: () => function (t, e) { return new md(b(), t, e) }, TimeClass: () => md, Timeline: () => Yp, ToneAudioBuffer: () => w, ToneAudioBuffers: () => Fd, ToneAudioNode: () => A, ToneBufferSource: () => Zd, ToneEvent: () => s_, ToneOscillatorNode: () => tf, Transport: () => ym, TransportTime: () => function (t, e) { return new T(b(), t, e) }, TransportTimeClass: () => T, Tremolo: () => J_, Unit: () => N, UserMedia: () => Jd, Vibrato: () => K_, Volume: () => Rd, WaveShaper: () => Wd, Waveform: () => rm, Zero: () => pf, connect: () => bd, connectSeries: () => wd, connectSignal: () => Ad, context: () => Sm, dbToGain: () => hd, debug: () => V, defaultArg: () => zp, disconnect: () => Td, fanIn: () => function (...t) { const e = t.pop(); o(e) && t.forEach(t => bd(t, e)) }, ftom: () => pd, gainToDb: () => cd, getContext: () => b, getDestination: () => function () { return b().destination }, getDraw: () => function () { return b().draw }, getListener: () => function () { return b().listener }, getTransport: () => function () { return b().transport }, immediate: () => function () { return b().immediate() }, intervalToFrequencyRatio: () => ld, isArray: () => d, isBoolean: () => wp, isDefined: () => o, isFunction: () => vp, isNote: () => Tp, isNumber: () => yp, isObject: () => xp, isString: () => bp, isUndef: () => gp, loaded: () => function () { return w.loaded() }, mtof: () => fd, now: () => function () { return b().now() }, optionsFromArguments: () => g, setContext: () => ad, start: () => function () { return od.resume() }, supported: () => mp, version: () => P }); var V = {}, N = (Dm.r(V), Dm.d(V, { assert: () => l, assertContextRunning: () => Sp, assertRange: () => f, assertUsedScheduleTime: () => Op, enterScheduledCallback: () => Cp, log: () => Mp, setLogger: () => function (t) { Dp = t }, warn: () => Ep }), {}); Dm.r(N); const P = "15.1.5"; var j, L, z, W, B, U, G, Q, Z, X, Y, H, $, J, K, tt, et, st, it, nt, rt, ot, at, ht, ct, lt, ut, pt, dt, ft, _t, mt, gt, vt, yt, xt, wt, bt, Tt, St, kt, At, Ct, Ot, Dt, Mt, Et, Rt, qt, It, Ft, Vt, Nt, Pt = Dm(871); const jt = new WeakSet, Lt = new WeakMap, zt = new WeakMap, Wt = new WeakMap, Bt = new WeakMap, Ut = new WeakMap, Gt = new WeakMap, Qt = new WeakMap, Zt = new WeakMap, Xt = new WeakMap, Yt = { construct: () => Yt }, Ht = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/, $t = (t, e) => { const s = []; let i = t.replace(/^[\s]+/, ""), n = i.match(Ht); for (; null !== n;) { const t = n[1].slice(1, -1), r = n[0].replace(/([\s]+)?;?$/, "").replace(t, new URL(t, e).toString()); s.push(r), i = i.slice(n[0].length).replace(/^[\s]+/, ""), n = i.match(Ht) } return [s.join(";"), i] }, Jt = t => { if (void 0 !== t && !Array.isArray(t)) throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.") }, Kt = t => { if (!(t => { try { new new Proxy(t, Yt) } catch { return !1 } return !0 })(t)) throw new TypeError("The given value for processorCtor should be a constructor."); if (null === t.prototype || "object" != typeof t.prototype) throw new TypeError("The given value for processorCtor should have a prototype.") }, te = (t, e) => { t = t.get(e); if (void 0 === t) throw new Error("A value with the given key could not be found."); return t }, ee = (t, e) => { e = Array.from(t).filter(e); if (1 < e.length) throw Error("More than one element was found."); if (0 === e.length) throw Error("No element was found."); var [e] = e; return t.delete(e), e }, se = (t, e, s, i) => { var n = te(t, e), r = ee(n, t => t[0] === s && t[1] === i); return 0 === n.size && t.delete(e), r }, ie = t => te(Gt, t), ne = t => { if (jt.has(t)) throw new Error("The AudioNode is already stored."); jt.add(t), ie(t).forEach(t => t(!0)) }, re = t => "port" in t, oe = t => { if (!jt.has(t)) throw new Error("The AudioNode is not stored."); jt.delete(t), ie(t).forEach(t => t(!1)) }, ae = (t, e) => { !re(t) && e.every(t => 0 === t.size) && oe(t) }, he = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", fftSize: 2048, maxDecibels: -30, minDecibels: -100, smoothingTimeConstant: .8 }, u = (t, e) => t.context === e, ce = t => { try { t.copyToChannel(new Float32Array(1), 0, -1) } catch { return !1 } return !0 }, le = () => new DOMException("", "IndexSizeError"), ue = e => { var s; e.getChannelData = (s = e.getChannelData, t => { try { return s.call(e, t) } catch (t) { if (12 === t.code) throw le(); throw t } }) }, pe = { numberOfChannels: 1 }, de = -34028234663852886e22, fe = -de, _e = t => jt.has(t), me = { buffer: null, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", loop: !1, loopEnd: 0, loopStart: 0, playbackRate: 1 }, ge = t => te(Lt, t), ve = t => te(Wt, t), ye = (e, s) => { const t = ge(e)["activeInputs"]; t.forEach(t => t.forEach(([t]) => { s.includes(e) || ye(t, [...s, e]) })); var i = "playbackRate" in e ? [e.playbackRate] : re(e) ? Array.from(e.parameters.values()) : "frequency" in (i = e) && "gain" in i ? [e.Q, e.detune, e.frequency, e.gain] : "offset" in e ? [e.offset] : !("frequency" in (i = e)) && "gain" in i ? [e.gain] : "detune" in (i = e) && "frequency" in i ? [e.detune, e.frequency] : "pan" in e ? [e.pan] : []; for (const e of i) { const t = ve(e); void 0 !== t && t.activeInputs.forEach(([t]) => ye(t, s)) } _e(e) && oe(e) }, xe = t => { ye(t.destination, []) }, we = t => "context" in t, be = t => we(t[0]), Te = (t, e, s, i) => { for (const e of t) if (s(e)) { if (i) return !1; throw Error("The set contains at least one similar element.") } return t.add(e), !0 }, Se = (t, e, [s, i], n) => { Te(t, [e, s, i], t => t[0] === e && t[1] === s, n) }, ke = (t, [e, s, i], n) => { var r = t.get(e); void 0 === r ? t.set(e, new Set([[s, i]])) : Te(r, [s, i], t => t[0] === s, n) }, Ae = t => "inputs" in t, Ce = (t, e, s, i) => { var n; return Ae(e) ? (n = e.inputs[i], t.connect(n, s, 0), [n, s, 0]) : (t.connect(e, s, i), [e, s, i]) }, Oe = (t, e, s) => { for (const i of t) if (i[0] === e && i[1] === s) return t.delete(i), i; return null }, De = (t, e) => { if (!ie(t).delete(e)) throw new Error("Missing the expected event listener.") }, Me = (t, e, s) => { var i = te(t, e), n = ee(i, t => t[0] === s); return 0 === i.size && t.delete(e), n }, Ee = (t, e, s, i) => { Ae(e) ? t.disconnect(e.inputs[i], s, 0) : t.disconnect(e, s, i) }, m = t => te(zt, t), Re = t => te(Bt, t), qe = t => Qt.has(t), Ie = t => !jt.has(t), Fe = (r, o) => new Promise(e => { if (null !== o) e(!0); else { const o = r.createScriptProcessor(256, 1, 1), t = r.createGain(), s = r.createBuffer(1, 2, 44100), i = s.getChannelData(0), n = (i[0] = 1, i[1] = 1, r.createBufferSource()); n.buffer = s, n.loop = !0, n.connect(o).connect(r.destination), n.connect(t), n.disconnect(t), o.onaudioprocess = t => { t = t.inputBuffer.getChannelData(0); Array.prototype.some.call(t, t => 1 === t) ? e(!0) : e(!1), n.stop(), o.onaudioprocess = null, n.disconnect(o), o.disconnect(r.destination) }, n.start() } }), Ve = (t, s) => { const e = new Map; for (const s of t) for (const t of s) { const s = e.get(t); e.set(t, void 0 === s ? 1 : s + 1) } e.forEach((t, e) => s(e, t)) }, Ne = t => "context" in t, Pe = (t, e, s, i, n) => { var [r, o] = ((t, e, s, i) => { var { activeInputs: e, passiveInputs: n } = ge(e), e = Oe(e[i], t, s); return null === e ? [se(n, t, s, i)[2], !1] : [e[2], !0] })(t, s, i, n); if (null !== r && (De(t, r), !o || e || qe(t) || Ee(m(t), m(s), i, n)), _e(s)) { const t = ge(s)["activeInputs"]; ae(s, t) } }, je = (t, e, s, i) => { var [n, r] = ((t, e, s) => { var { activeInputs: e, passiveInputs: i } = ve(e), e = Oe(e, t, s); return null === e ? [Me(i, t, s)[1], !1] : [e[2], !0] })(t, s, i); null !== n && (De(t, n), !r || e || qe(t) || m(t).disconnect(Re(s), i)) }; class Le { constructor(t) { this._map = new Map(t) } get size() { return this._map.size } entries() { return this._map.entries() } forEach(s, i = null) { return this._map.forEach((t, e) => s.call(i, t, e, this)) } get(t) { return this._map.get(t) } has(t) { return this._map.has(t) } keys() { return this._map.keys() } values() { return this._map.values() } } const ze = { channelCount: 2, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: 1, numberOfOutputs: 1, parameterData: {}, processorOptions: {} }; function We(t, e, s, i, n) { if ("function" == typeof t.copyFromChannel) 0 === e[s].byteLength && (e[s] = new Float32Array(128)), t.copyFromChannel(e[s], i, n); else { const r = t.getChannelData(i); if (0 === e[s].byteLength) e[s] = r.slice(n, n + 128); else { const t = new Float32Array(r.buffer, n * Float32Array.BYTES_PER_ELEMENT, 128); e[s].set(t) } } } const Be = (t, e, s, i, n) => { "function" == typeof t.copyToChannel ? 0 !== e[s].byteLength && t.copyToChannel(e[s], i, n) : 0 !== e[s].byteLength && t.getChannelData(i).set(e[s], n) }, Ue = (e, s) => { const i = []; for (let t = 0; t < e; t += 1) { const e = [], n = "number" == typeof s ? s : s[t]; for (let t = 0; t < n; t += 1)e.push(new Float32Array(128)); i.push(e) } return i }, Ge = { Q: 1, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", detune: 0, frequency: 350, gain: 0, type: "lowpass" }, Qe = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: 6 }, Ze = { channelCount: 6, channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: 6 }, Xe = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", offset: 1 }, Ye = { buffer: null, channelCount: 2, channelCountMode: "clamped-max", channelInterpretation: "speakers", disableNormalization: !1 }, He = s => { const { port1: i, port2: n } = new MessageChannel; return new Promise(t => { const e = () => { n.onmessage = null, i.close(), n.close(), t() }; n.onmessage = () => e(); try { i.postMessage(s, [s]) } catch { } finally { e() } }) }, $e = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", delayTime: 0, maxDelayTime: 1 }, Je = (t, e, s) => { e = e[s]; if (void 0 === e) throw t(); return e }, Ke = { attack: .003, channelCount: 2, channelCountMode: "clamped-max", channelInterpretation: "speakers", knee: 30, ratio: 12, release: .25, threshold: -24 }, ts = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", gain: 1 }, a = () => new DOMException("", "InvalidStateError"), es = () => new DOMException("", "InvalidAccessError"), ss = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers" }, is = (s, i, n, r, o, a, h, t, c, l, u) => { var e = l.length; let p = t; for (let t = 0; t < e; t += 1) { let e = n[0] * l[t]; for (let t = 1; t < o; t += 1) { const r = p - t & c - 1; e = (e += n[t] * a[r]) - s[t] * h[r] } for (let t = o; t < r; t += 1)e += n[t] * a[p - t & c - 1]; for (let t = o; t < i; t += 1)e -= s[t] * h[p - t & c - 1]; a[p] = l[t], h[p] = e, p = p + 1 & c - 1, u[t] = e } return p }, ns = { channelCount: 2, channelCountMode: "explicit", channelInterpretation: "speakers" }, rs = t => { var e = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]); try { const s = t.decodeAudioData(e.buffer, () => { }); return void 0 !== s && (s.catch(() => { }), !0) } catch { } return !1 }, h = (t, e, s) => { e = e[s]; void 0 !== e && e !== t[s] && (t[s] = e) }, R = (t, e) => { h(t, e, "channelCount"), h(t, e, "channelCountMode"), h(t, e, "channelInterpretation") }, os = t => "function" == typeof t.getFloatTimeDomainData, i = (t, e, s) => { e = e[s]; void 0 !== e && e !== t[s].value && (t[s].value = e) }, as = i => { var n; i.start = (n = i.start, (t = 0, e = 0, s) => { if ("number" == typeof s && s < 0 || e < 0 || t < 0) throw new RangeError("The parameters can't be negative."); n.call(i, t, e, s) }) }, hs = e => { var s; e.stop = (s = e.stop, (t = 0) => { if (t < 0) throw new RangeError("The parameter can't be negative."); s.call(e, t) }) }, cs = (t, e) => null === t ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(t * e))))), ls = (t, e) => { t = t.createBiquadFilter(); return R(t, e), i(t, e, "Q"), i(t, e, "detune"), i(t, e, "frequency"), i(t, e, "gain"), h(t, e, "type"), t }, us = (t, e) => { t = t.createChannelSplitter(e.numberOfOutputs); R(t, e); { const s = (e = t).numberOfOutputs; Object.defineProperty(e, "channelCount", { get: () => s, set: t => { if (t !== s) throw a() } }), Object.defineProperty(e, "channelCountMode", { get: () => "explicit", set: t => { if ("explicit" !== t) throw a() } }), Object.defineProperty(e, "channelInterpretation", { get: () => "discrete", set: t => { if ("discrete" !== t) throw a() } }) } return t }, ps = (t, e) => (t.connect = e.connect.bind(e), t.disconnect = e.disconnect.bind(e), t), ds = (t, e) => { t = t.createDelay(e.maxDelayTime); return R(t, e), i(t, e, "delayTime"), t }, fs = (t, e) => { t = t.createGain(); return R(t, e), i(t, e, "gain"), t }; function _s(e, s) { let i = [0, 0]; for (let t = e.length - 1; 0 <= t; --t)(i = [(n = i)[0] * s[0] - n[1] * s[1], n[0] * s[1] + n[1] * s[0]])[0] += e[t]; var n; return i } const ms = (t, e, s, i) => t.createScriptProcessor(e, s, i), gs = () => new DOMException("", "NotSupportedError"), vs = { numberOfChannels: 1 }, ys = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", detune: 0, frequency: 440, periodicWave: void 0, type: "sine" }, xs = { channelCount: 2, channelCountMode: "clamped-max", channelInterpretation: "speakers", coneInnerAngle: 360, coneOuterAngle: 360, coneOuterGain: 0, distanceModel: "inverse", maxDistance: 1e4, orientationX: 1, orientationY: 0, orientationZ: 0, panningModel: "equalpower", positionX: 0, positionY: 0, positionZ: 0, refDistance: 1, rolloffFactor: 1 }, ws = { disableNormalization: !1 }, bs = { channelCount: 2, channelCountMode: "explicit", channelInterpretation: "speakers", pan: 0 }, Ts = { channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", curve: null, oversample: "none" }, Ss = (t, e, s) => void 0 === t.copyFromChannel ? t.getChannelData(s)[0] : (t.copyFromChannel(e, s), e[0]), ks = t => { if (null === t) return !1; var e = t.length; return e % 2 != 0 ? 0 !== t[Math.floor(e / 2)] : t[e / 2 - 1] + t[e / 2] !== 0 }, As = (t, e, s, i) => { let n = t; for (; !n.hasOwnProperty(e);)n = Object.getPrototypeOf(n); var { get: r, set: o } = Object.getOwnPropertyDescriptor(n, e); Object.defineProperty(t, e, { get: s(r), set: i(o) }) }, Cs = (e, s, i) => { try { e.setValueAtTime(s, i) } catch (t) { if (9 !== t.code) throw t; Cs(e, s, i + 1e-7) } }, Os = t => { const e = t.createOscillator(); try { e.start(-1) } catch (t) { return t instanceof RangeError } return !1 }, Ds = t => { const e = t.createBuffer(1, 1, 44100), s = t.createBufferSource(); s.buffer = e, s.start(), s.stop(); try { return s.stop(), !0 } catch { return !1 } }, Ms = t => { const e = t.createOscillator(); try { e.stop(-1) } catch (t) { return t instanceof RangeError } return !1 }, Es = () => { try { new DOMException } catch { return !1 } return !0 }, Rs = () => new Promise(e => { const t = new ArrayBuffer(0), { port1: s, port2: i } = new MessageChannel; s.onmessage = ({ data: t }) => e(null !== t), i.postMessage(t, [t]) }), qs = (i, t) => { const n = t.createGain(), e = (i.connect(n), s = i.disconnect, () => { s.call(i, n), i.removeEventListener("ended", e) }); var s; i.addEventListener("ended", e), ps(i, n), i.stop = (e => { let s = !1; return (t = 0) => { if (s) try { e.call(i, t) } catch { n.gain.setValueAtTime(0, t) } else e.call(i, t), s = !0 } })(i.stop) }, Is = (s, i) => t => { var e = { value: s }; return Object.defineProperties(t, { currentTarget: e, target: e }), ("function" == typeof i ? i : i.handleEvent).call(s, t) }, Fs = (W = Te, (t, e, [s, i, n], r) => { W(t[i], [e, s, n], t => t[0] === e && t[1] === s, r) }), Vs = (z = Te, (t, e, [s, i, n], r) => { var o = t.get(s); void 0 === o ? t.set(s, new Set([[i, e, n]])) : z(o, [i, e, n], t => t[0] === i && t[1] === e, r) }), Ns = (L = ee, (t, e, s, i) => L(t[i], t => t[0] === e && t[1] === s)), Ps = new WeakMap, js = (j = Ps, t => { return null != (t = j.get(t)) ? t : 0 }), Ls = (B = new Map, U = new WeakMap, (e, t) => { const s = U.get(e); if (void 0 !== s) return s; var i = B.get(e); if (void 0 !== i) return i; try { const s = t(); return s instanceof Promise ? (B.set(e, s), s.catch(() => !1).then(t => (B.delete(e), U.set(e, t), t))) : (U.set(e, s), s) } catch { return U.set(e, !1), !1 } }), zs = "undefined" == typeof window ? null : window, Ws = (J = Ls, K = le, (t, e) => { const s = t.createAnalyser(); if (R(s, e), e.maxDecibels > e.minDecibels) return h(s, e, "fftSize"), h(s, e, "maxDecibels"), h(s, e, "minDecibels"), h(s, e, "smoothingTimeConstant"), J(os, () => os(s)) || ((n = s).getFloatTimeDomainData = e => { var s = new Uint8Array(e.length), i = (n.getByteTimeDomainData(s), Math.max(s.length, n.fftSize)); for (let t = 0; t < i; t += 1)e[t] = .0078125 * (s[t] - 128); return e }), s; throw K(); var n }), Bs = ($ = ge, t => { t = $(t); if (null === t.renderer) throw new Error("Missing the renderer of the given AudioNode in the audio graph."); return t.renderer }), Us = (X = ge, Y = Bs, H = qe, async (o, a, h) => { const t = X(o); await Promise.all(t.activeInputs.map((t, r) => Array.from(t).map(async ([t, e]) => { const s = Y(t), i = await s.render(t, a), n = o.context.destination; H(t) || o === n && H(o) || i.connect(h, e, r) })).reduce((t, e) => [...t, ...e], [])) }), Gs = (G = Ws, Q = m, Z = Us, () => { const i = new WeakMap; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Q(t); if (!u(s, e)) { const Q = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, fftSize: s.fftSize, maxDecibels: s.maxDecibels, minDecibels: s.minDecibels, smoothingTimeConstant: s.smoothingTimeConstant }; s = G(e, Q) } return i.set(e, s), await Z(t, e, s), s })(t, e) } } }), Qs = (tt = Ut, t => { t = tt.get(t); if (void 0 === t) throw a(); return t }), t = null === (s = zs) ? null : s.hasOwnProperty("OfflineAudioContext") ? s.OfflineAudioContext : s.hasOwnProperty("webkitOfflineAudioContext") ? s.webkitOfflineAudioContext : null, Zs = (Vt = t, t => null !== Vt && t instanceof Vt), Xs = new WeakMap, Ys = (Ft = Is, class { constructor(t) { this._nativeEventTarget = t, this._listeners = new WeakMap } addEventListener(e, s, i) { if (null !== s) { let t = this._listeners.get(s); void 0 === t && (t = Ft(this, s), "function" == typeof s && this._listeners.set(s, t)), this._nativeEventTarget.addEventListener(e, t, i) } } dispatchEvent(t) { return this._nativeEventTarget.dispatchEvent(t) } removeEventListener(t, e, s) { e = null === e ? void 0 : this._listeners.get(e); this._nativeEventTarget.removeEventListener(t, void 0 === e ? null : e, s) } }), Hs = null === (s = zs) ? null : s.hasOwnProperty("AudioContext") ? s.AudioContext : s.hasOwnProperty("webkitAudioContext") ? s.webkitAudioContext : null, $s = (It = Hs, t => null !== It && t instanceof It), Js = (qt = zs, t => null !== qt && "function" == typeof qt.AudioNode && t instanceof qt.AudioNode), Ks = (Rt = zs, t => null !== Rt && "function" == typeof Rt.AudioParam && t instanceof Rt.AudioParam), ti = null !== (s = zs) && s.hasOwnProperty("AudioWorkletNode") ? s.AudioWorkletNode : null, e = (Nt = Lt, et = ((l, u, p, d, f, _, m, g, v, y, x, w, b) => { const T = new WeakMap; return (i, n, r, o, a) => { const { activeInputs: h, passiveInputs: c } = _(n), t = _(i)["outputs"], e = g(i), s = t => { var e = v(n), s = v(i); if (t) { const u = se(c, i, r, o); l(h, i, u, !1), a || w(i) || p(s, e, r, o), b(n) && ne(n) } else { const l = d(h, i, r, o), p = (u(c, o, l, !1), a || w(i) || f(s, e, r, o), m(n)); if (0 === p) x(n) && ae(n, h); else { const l = T.get(n); void 0 !== l && clearTimeout(l), T.set(n, setTimeout(() => { x(n) && ae(n, h) }, 1e3 * p)) } } }; return !!y(t, [n, r, o], t => t[0] === n && t[1] === r && t[2] === o, !0) && (e.add(s), x(i) ? l(h, i, [r, o, s], !0) : u(c, o, [i, r, s], !0), !0) } })(Fs, Vs, Ce, Ns, Ee, ge, js, ie, m, Te, _e, qe, Ie), st = Ls, At = Qt, Ct = Ee, Ot = ge, Dt = m, Mt = Re, Et = _e, it = i => (t, e) => { var s = At.get(t); if (void 0 === s) { if (!i && Et(t)) { const At = Dt(t), Et = Ot(t)["outputs"]; for (const Ot of Et) if (be(Ot)) { const Mt = Dt(Ot[0]); Ct(At, Mt, Ot[1], Ot[2]) } else { const Ct = Mt(Ot[0]); At.disconnect(Ct, Ot[1]) } } At.set(t, e) } else At.set(t, s + e) }, nt = le, rt = es, ot = gs, vt = Ce, yt = Qt, xt = ge, wt = m, bt = Re, Tt = Qs, St = _e, kt = Zs, at = (t, e) => { var s = yt.get(t); if (void 0 === s) throw new Error("Missing the expected cycle count."); var i = Tt(t.context), i = kt(i); if (s === e) { if (yt.delete(t), !i && St(t)) { const yt = wt(t), Tt = xt(t)["outputs"]; for (const xt of Tt) if (be(xt)) { const bt = wt(xt[0]); vt(yt, bt, xt[1], xt[2]) } else { const vt = bt(xt[0]); yt.connect(vt, xt[1]) } } } else yt.set(t, s - e) }, _t = Xs, mt = ge, gt = te, ht = function e(s, t) { const i = we(t) ? t : gt(_t, t); if ("delayTime" in i) return []; if (s[0] === i) return [s]; if (s.includes(i)) return []; t = mt(i).outputs; return Array.from(t).map(t => e([...s, i], t[0])).reduce((t, e) => t.concat(e), []) }, s = Ys, lt = $s, ut = Js, pt = Ks, ft = ti, class extends s { constructor(t, e, s, i) { super(s), this._context = t, this._nativeAudioNode = s; const n = ct(t); if (lt(n) && !0 !== st(Fe, () => Fe(n, ft))) { var r = s, o, a; const c = new Map; r.connect = (a = r.connect.bind(r), (t, e = 0, s = 0) => { const i = Ne(t) ? a(t, e, s) : a(t, e), n = c.get(t); return void 0 === n ? c.set(t, [{ input: s, output: e }]) : n.every(t => t.input !== s || t.output !== e) && n.push({ input: s, output: e }), i }), r.disconnect = (o = r.disconnect, (e, s, i) => { if (o.apply(r), void 0 === e) c.clear(); else if ("number" == typeof e) for (const [r, o] of c) { const s = o.filter(t => t.output !== e); 0 === s.length ? c.delete(r) : c.set(r, s) } else if (c.has(e)) if (void 0 === s) c.delete(e); else { const r = c.get(e); if (void 0 !== r) { const o = r.filter(t => t.output !== s && (t.input !== i || void 0 === i)); 0 === o.length ? c.delete(e) : c.set(e, o) } } for (const [o, e] of c) e.forEach(t => { Ne(o) ? r.connect(o, t.output, t.input) : r.connect(o, t.output) }) }) } zt.set(this, s), Gt.set(this, new Set), "closed" !== t.state && e && ne(this); { t = this, e = i; var h = s; const l = []; for (let t = 0; t < h.numberOfInputs; t += 1)l.push(new Set); return void Nt.set(t, { activeInputs: l, outputs: new Set, passiveInputs: new WeakMap, renderer: e }) } } get channelCount() { return this._nativeAudioNode.channelCount } set channelCount(t) { this._nativeAudioNode.channelCount = t } get channelCountMode() { return this._nativeAudioNode.channelCountMode } set channelCountMode(t) { this._nativeAudioNode.channelCountMode = t } get channelInterpretation() { return this._nativeAudioNode.channelInterpretation } set channelInterpretation(t) { this._nativeAudioNode.channelInterpretation = t } get context() { return this._context } get numberOfInputs() { return this._nativeAudioNode.numberOfInputs } get numberOfOutputs() { return this._nativeAudioNode.numberOfOutputs } connect(t, e = 0, s = 0) { if (e < 0 || e >= this._nativeAudioNode.numberOfOutputs) throw nt(); var i = ct(this._context), i = dt(i); if (ut(t) || pt(t)) throw rt(); if (we(t)) { const nt = m(t); try { const et = Ce(this._nativeAudioNode, nt, e, s), it = Ie(this); (i || it) && this._nativeAudioNode.disconnect(...et), "closed" !== this.context.state && !it && Ie(t) && ne(t) } catch (t) { if (12 === t.code) throw rt(); throw t } if (et(this, t, e, s, i)) { const et = ht([this], t); Ve(et, it(i)) } return t } s = Re(t); if ("playbackRate" === s.name && 1024 === s.maxValue) throw ot(); try { this._nativeAudioNode.connect(s, e), (i || Ie(this)) && this._nativeAudioNode.disconnect(s, e) } catch (t) { if (12 === t.code) throw rt(); throw t } if (((r, o, a, h) => { const { activeInputs: c, passiveInputs: l } = ve(o), t = ge(r)["outputs"], e = ie(r), s = t => { const e = m(r), s = Re(o); if (t) { const o = Me(l, r, a); Se(c, r, o, !1), h || qe(r) || e.connect(s, a) } else { t = c, i = r, n = a; const o = ee(t, t => t[0] === i && t[1] === n); ke(l, o, !1), h || qe(r) || e.disconnect(s, a) } var i, n }; return !!Te(t, [o, a], t => t[0] === o && t[1] === a, !0) && (e.add(s), _e(r) ? Se(c, r, [a, s], !0) : ke(l, [r, a, s], !0), !0) })(this, t, e, i)) { const et = ht([this], t); Ve(et, it(i)) } } disconnect(t, e, s) { let i; var n = ct(this._context), n = dt(n); if (void 0 === t) i = ((t, e) => { const s = ge(t), i = []; for (const n of s.outputs) (be(n) ? Pe : je)(t, e, ...n), i.push(n[0]); return s.outputs.clear(), i })(this, n); else if ("number" == typeof t) { if (t < 0 || t >= this.numberOfOutputs) throw nt(); i = ((t, e, s) => { const i = ge(t), n = []; for (const r of i.outputs) r[1] === s && ((be(r) ? Pe : je)(t, e, ...r), n.push(r[0]), i.outputs.delete(r)); return n })(this, n, t) } else { if (void 0 !== e && (e < 0 || e >= this.numberOfOutputs)) throw nt(); if (we(t) && void 0 !== s && (s < 0 || s >= t.numberOfInputs)) throw nt(); if (0 === (i = ((e, s, i, n, r) => { const o = ge(e); return Array.from(o.outputs).filter(t => !(t[0] !== i || void 0 !== n && t[1] !== n || void 0 !== r && t[2] !== r)).map(t => ((be(t) ? Pe : je)(e, s, ...t), o.outputs.delete(t), t[0])) })(this, n, t, e, s)).length) throw rt() } for (const t of i) { const e = ht([this], t); Ve(e, at) } } }); s = e, ei = Gs, si = le, ii = Ws, ni = ct = Qs, ri = dt = Zs; var ei, si, ii, ni, ri, oi, ai, hi, ci, li, ui, pi, di, fi, _i, mi, gi, vi, yi, xi, wi, bi, Ti, Si, ki, Ai, Ci, Oi, Di, Mi, Ei, Ri, qi, Ii, Fi, Vi, Ni, Pi, ji, Li, zi, Wi, Bi, Ui, Gi, Qi, Zi, Xi, Yi, Hi, $i, Ji, Ki, tn, en, sn, nn, rn, on, an, hn, cn, ln, un, pn, dn, fn, _n, mn, gn, vn, yn, xn, wn, bn, Tn, Sn, kn, An, Cn, On, Dn, Mn, En, Rn, qn, In, Fn, Vn, Nn, Pn, jn, Ln, zn, Wn, Bn, Un, Gn, c, Qn, Zn, Xn, Yn, Hn, $n, Jn, Kn, tr, er, sr, ir, nr, rr, or, ar, hr, cr, lr, ur, pr, dr, fr, _r, mr, gr, vr, yr, xr, wr, br, Tr, Sr, kr, Ar, Cr, Or, Dr, Mr, Er, Rr, qr, Ir, Fr, Vr, Nr, Pr, jr, Lr, zr, Wr, Br, Ur, Gr, Qr, Zr, Xr, Yr, Hr, $r, Jr, Kr, to, eo, so, io, no, ro, oo, ao, ho, co, lo, uo, po, fo, _o, mo, go, vo, yo, xo, wo, bo, To, So, ko, Ao, Co, Oo, Do, Mo, Eo, Ro, qo, Io, Fo, Vo, No, Po, jo, Lo, zo, Wo, Bo, Uo, Go, Qo, p, Zo, Xo, Yo, Ho, $o, Jo, Ko, ta, ea, sa, ia, na, ra, oa, aa, ha, ca, la, ua, pa, da, fa, _a, ma, ga, va, ya, xa, wa, ba, Ta, Sa, ka, Aa, Ca, Oa, Da, Ma, Ea, Ra, qa, Ia, Fa, Va, Na, Pa, ja, La, za, Wa, Ba, Ua, Ga, Qa, Za, Xa, Ya, Ha, $a, Ja, Ka, th, eh, sh, ih, nh, rh, oh, ah, hh, ch, lh, uh, ph, dh, fh, _h, mh, gh, vh, yh, xh, wh, bh, Th, Sh, kh, Ah, Ch, Oh, Dh, Mh, Eh, Rh, qh, Ih, Fh, Vh, Nh, Ph, jh, Lh, zh, Wh, Bh, Uh, Gh, Qh, Zh, Xh, Yh, Hh, $h, Jh, Kh, tc, ec, sc, ic, nc, rc, oc, ac, hc, cc, lc, uc, pc, dc, fc, _c, mc, gc, vc, yc, xc, wc, bc, Tc, Sc, kc, Ac, Cc, Oc, Dc, Mc, Ec, Rc, qc, Ic, Fc, Vc, Nc, Pc, jc, Lc, zc, Wc, Bc, Uc, Gc, Qc, Zc, Xc, Yc, Hc, $c, Jc, Kc, tl, el, sl, il, nl, rl, ol, al, hl, cl, ll, ul, pl, dl, fl, _l, ml, gl, vl, yl, xl, wl, bl, Tl, Sl, kl, Al, s = class extends s { constructor(t, e) { var s = ni(t), e = { ...he, ...e }, e = ii(s, e); super(t, !1, e, ri(s) ? ei() : null), this._nativeAnalyserNode = e } get fftSize() { return this._nativeAnalyserNode.fftSize } set fftSize(t) { this._nativeAnalyserNode.fftSize = t } get frequencyBinCount() { return this._nativeAnalyserNode.frequencyBinCount } get maxDecibels() { return this._nativeAnalyserNode.maxDecibels } set maxDecibels(t) { var e = this._nativeAnalyserNode.maxDecibels; if (!((this._nativeAnalyserNode.maxDecibels = t) > this._nativeAnalyserNode.minDecibels)) throw this._nativeAnalyserNode.maxDecibels = e, si() } get minDecibels() { return this._nativeAnalyserNode.minDecibels } set minDecibels(t) { var e = this._nativeAnalyserNode.minDecibels; if (this._nativeAnalyserNode.minDecibels = t, !(this._nativeAnalyserNode.maxDecibels > t)) throw this._nativeAnalyserNode.minDecibels = e, si() } get smoothingTimeConstant() { return this._nativeAnalyserNode.smoothingTimeConstant } set smoothingTimeConstant(t) { this._nativeAnalyserNode.smoothingTimeConstant = t } getByteFrequencyData(t) { this._nativeAnalyserNode.getByteFrequencyData(t) } getByteTimeDomainData(t) { this._nativeAnalyserNode.getByteTimeDomainData(t) } getFloatFrequencyData(t) { this._nativeAnalyserNode.getFloatFrequencyData(t) } getFloatTimeDomainData(t) { this._nativeAnalyserNode.getFloatTimeDomainData(t) } }, Cl = new WeakSet, n = null !== (n = zs) && n.hasOwnProperty("AudioBuffer") ? n.AudioBuffer : null, r = (oi = new Uint32Array(1), t => (oi[0] = t, oi[0])); Gi = le; const Ol = a => { a.copyFromChannel = (e, t, s = 0) => { var i = Ui(s), s = Ui(t); if (s >= a.numberOfChannels) throw Gi(); var n = a.length, r = a.getChannelData(s), o = e.length; for (let t = i < 0 ? -i : 0; t + i < n && t < o; t += 1)e[t] = r[t + i] }, a.copyToChannel = (e, t, s = 0) => { var i = Ui(s), s = Ui(t); if (s >= a.numberOfChannels) throw Gi(); const n = a.length, r = a.getChannelData(s), o = e.length; for (let t = i < 0 ? -i : 0; t + i < n && t < o; t += 1)r[t + i] = e[t] } }, Dl = (Bi = Ui = r, i => { var n, r; i.copyFromChannel = (r = i.copyFromChannel, (t, e, s = 0) => { s = Bi(s), e = Bi(e); if (s < i.length) return r.call(i, t, e, s) }), i.copyToChannel = (n = i.copyToChannel, (t, e, s = 0) => { s = Bi(s), e = Bi(e); if (s < i.length) return n.call(i, t, e, s) }) }), Ml = ((n, r, o, a, h, c, l, u) => { let p = null; return class e { constructor(t) { if (null === h) throw new Error("Missing the native OfflineAudioContext constructor."); var { length: t, numberOfChannels: e, sampleRate: s } = { ...pe, ...t }; null === p && (p = new h(1, 1, 44100)); const i = null !== a && r(c, c) ? new a({ length: t, numberOfChannels: e, sampleRate: s }) : p.createBuffer(e, t, s); if (0 === i.numberOfChannels) throw o(); return "function" != typeof i.copyFromChannel ? (l(i), ue(i)) : r(ce, () => ce(i)) || u(i), n.add(i), i } static [Symbol.hasInstance](t) { return null !== t && "object" == typeof t && Object.getPrototypeOf(t) === e.prototype || n.has(t) } } })(Cl, Ls, gs, n, t, (Wi = n, () => { if (null === Wi) return !1; try { new Wi({ length: 1, sampleRate: 44100 }) } catch { return !1 } return !0 }), Ol, Dl), El = (zi = fs, (t, e) => { const s = zi(t, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: 0 }), i = (e.connect(s).connect(t.destination), () => { e.removeEventListener("ended", i), e.disconnect(s), s.disconnect() }); e.addEventListener("ended", i) }), Rl = (Pi = Bs, ji = ve, Li = qe, async (t, n, r) => { t = ji(t); await Promise.all(Array.from(t.activeInputs).map(async ([t, e]) => { const s = Pi(t), i = await s.render(t, n); Li(t) || i.connect(r, e) })) }), ql = (Ni = Rl, (t, e, s) => Ni(e, t, s)), Il = (Ai = El, Ci = Ls, Oi = t => { const e = t.createBufferSource(); e.start(); try { e.start() } catch { return !0 } return !1 }, Di = t => { const e = t.createBufferSource(), s = t.createBuffer(1, 1, 44100); e.buffer = s; try { e.start(0, 1) } catch { return !1 } return !0 }, Mi = t => { const e = t.createBufferSource(); e.start(); try { e.stop() } catch { return !1 } return !0 }, Ei = Os, Ri = Ds, qi = Ms, Vi = As, Ii = (s, t) => { const i = t.createBuffer(1, 1, 44100); null === s.buffer && (s.buffer = i), Vi(s, "buffer", e => () => { var t = e.call(s); return t === i ? null : t }, e => t => e.call(s, null === t ? i : t)) }, Fi = qs, (t, e) => { var n, r, o, s = t.createBufferSource(); return R(s, e), i(s, e, "playbackRate"), h(s, e, "buffer"), h(s, e, "loop"), h(s, e, "loopEnd"), h(s, e, "loopStart"), Ci(Oi, () => Oi(t)) || ((o = s).start = (i => { let n = !1; return (t = 0, e = 0, s) => { if (n) throw a(); i.call(o, t, e, s), n = !0 } })(o.start)), Ci(Di, () => Di(t)) || ((n = s).start = (r = n.start, (t = 0, e = 0, s) => { var i = n.buffer, e = null === i ? e : Math.min(i.duration, e); null !== i && e > i.duration - .5 / n.context.sampleRate ? r.call(n, t, 0, 0) : r.call(n, t, e, s) })), Ci(Mi, () => Mi(t)) || Ii(s, t), Ci(Ei, () => Ei(t)) || as(s), Ci(Ri, () => Ri(t)) || Fi(s, t), Ci(qi, () => qi(t)) || hs(s), Ai(t, s), s }), Fl = (ki = ve, Ti = t => { t = ki(t); if (null === t.renderer) throw new Error("Missing the renderer of the given AudioParam in the audio graph."); return t.renderer }, Si = Rl, (t, e, s) => (Ti(e).replay(s), Si(e, t, s))), Vl = (vi = ql, yi = Il, xi = m, wi = Fl, bi = Us, () => { const n = new WeakMap; let r = null, o = null; return { set start(t) { r = t }, set stop(t) { o = t }, render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = xi(t); var i = u(s, e); if (!i) { const vi = { buffer: s.buffer, channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, loop: s.loop, loopEnd: s.loopEnd, loopStart: s.loopStart, playbackRate: s.playbackRate.value }; s = yi(e, vi), null !== r && s.start(...r), null !== o && s.stop(o) } return n.set(e, s), i ? await vi(e, t.playbackRate, s.playbackRate) : await wi(e, t.playbackRate, s.playbackRate), await bi(t, e, s), s })(t, e) } } }), Nl = (Qi = Wt, ai = Xs, hi = Bt, ci = Pt.createCancelAndHoldAutomationEvent, li = Pt.createCancelScheduledValuesAutomationEvent, ui = Pt.createExponentialRampToValueAutomationEvent, pi = Pt.createLinearRampToValueAutomationEvent, di = Pt.createSetTargetAutomationEvent, fi = Pt.createSetValueAutomationEvent, _i = Pt.createSetValueCurveAutomationEvent, mi = Hs, gi = Cs, (p, t, d, e = null, s = null) => { const i = d.value, f = new Pt.AutomationEventList(i), _ = t ? (c = f, { replay(t) { for (const e of c) if ("exponentialRampToValue" === e.type) { const { endTime: c, value: s } = e; t.exponentialRampToValueAtTime(s, c) } else if ("linearRampToValue" === e.type) { const { endTime: c, value: i } = e; t.linearRampToValueAtTime(i, c) } else if ("setTarget" === e.type) { const { startTime: c, target: n, timeConstant: r } = e; t.setTargetAtTime(n, c, r) } else if ("setValue" === e.type) { const { startTime: c, value: o } = e; t.setValueAtTime(o, c) } else { if ("setValueCurve" !== e.type) throw new Error("Can't apply an unknown automation."); { const { duration: c, startTime: a, values: h } = e; t.setValueCurveAtTime(h, a, c) } } } }) : null, m = { get defaultValue() { return i }, get maxValue() { return null === e ? d.maxValue : e }, get minValue() { return null === s ? d.minValue : s }, get value() { return d.value }, set value(t) { d.value = t, m.setValueAtTime(t, p.context.currentTime) }, cancelAndHoldAtTime(t) { var e, s; return "function" == typeof d.cancelAndHoldAtTime ? (null === _ && f.flush(p.context.currentTime), f.add(ci(t)), d.cancelAndHoldAtTime(t)) : (e = Array.from(f).pop(), null === _ && f.flush(p.context.currentTime), f.add(ci(t)), s = Array.from(f).pop(), d.cancelScheduledValues(t), e !== s && void 0 !== s && ("exponentialRampToValue" === s.type ? d.exponentialRampToValueAtTime(s.value, s.endTime) : "linearRampToValue" === s.type ? d.linearRampToValueAtTime(s.value, s.endTime) : "setValue" === s.type ? d.setValueAtTime(s.value, s.startTime) : "setValueCurve" === s.type && d.setValueCurveAtTime(s.values, s.startTime, s.duration))), m }, cancelScheduledValues: t => (null === _ && f.flush(p.context.currentTime), f.add(li(t)), d.cancelScheduledValues(t), m), exponentialRampToValueAtTime(t, e) { if (0 === t) throw new RangeError; if (!Number.isFinite(e) || e < 0) throw new RangeError; var s = p.context.currentTime; return null === _ && f.flush(s), 0 === Array.from(f).length && (f.add(fi(i, s)), d.setValueAtTime(i, s)), f.add(ui(t, e)), d.exponentialRampToValueAtTime(t, e), m }, linearRampToValueAtTime(t, e) { var s = p.context.currentTime; return null === _ && f.flush(s), 0 === Array.from(f).length && (f.add(fi(i, s)), d.setValueAtTime(i, s)), f.add(pi(t, e)), d.linearRampToValueAtTime(t, e), m }, setTargetAtTime: (t, e, s) => (null === _ && f.flush(p.context.currentTime), f.add(di(t, e, s)), d.setTargetAtTime(t, e, s), m), setValueAtTime: (t, e) => (null === _ && f.flush(p.context.currentTime), f.add(fi(t, e)), d.setValueAtTime(t, e), m), setValueCurveAtTime(t, e, s) { var i = t instanceof Float32Array ? t : new Float32Array(t); if (null !== mi && "webkitAudioContext" === mi.name) { const t = e + s, r = p.context.sampleRate, o = Math.ceil(e * r), a = Math.floor(t * r), h = a - o, c = new Float32Array(h); for (let t = 0; t < h; t += 1) { const p = (i.length - 1) / s * ((o + t) / r - e), l = Math.floor(p), u = Math.ceil(p); c[t] = l === u ? i[l] : (1 - (p - l)) * i[l] + (1 - (u - p)) * i[u] } null === _ && f.flush(p.context.currentTime), f.add(_i(c, e, s)), d.setValueCurveAtTime(c, e, s); var n = a / r; n < t && gi(m, c[c.length - 1], n), gi(m, i[i.length - 1], t) } else null === _ && f.flush(p.context.currentTime), f.add(_i(i, e, s)), d.setValueCurveAtTime(i, e, s); return m } }; var c, n; return hi.set(m, d), ai.set(m, p), t = m, n = _, Qi.set(t, { activeInputs: new Set, passiveInputs: new WeakMap, renderer: n }), m }), Pl = (r = e, xl = Vl, bl = a, Tl = Il, Al = Is, class extends r { constructor(t, e) { var s = Sl(t), e = { ...me, ...e }, i = Tl(s, e), s = kl(s), n = s ? xl() : null; super(t, !1, i, n), this._audioBufferSourceNodeRenderer = n, this._isBufferNullified = !1, this._isBufferSet = null !== e.buffer, this._nativeAudioBufferSourceNode = i, this._onended = null, this._playbackRate = wl(this, s, i.playbackRate, fe, de) } get buffer() { return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer } set buffer(t) { if (null !== (this._nativeAudioBufferSourceNode.buffer = t)) { if (this._isBufferSet) throw bl(); this._isBufferSet = !0 } } get loop() { return this._nativeAudioBufferSourceNode.loop } set loop(t) { this._nativeAudioBufferSourceNode.loop = t } get loopEnd() { return this._nativeAudioBufferSourceNode.loopEnd } set loopEnd(t) { this._nativeAudioBufferSourceNode.loopEnd = t } get loopStart() { return this._nativeAudioBufferSourceNode.loopStart } set loopStart(t) { this._nativeAudioBufferSourceNode.loopStart = t } get onended() { return this._onended } set onended(t) { var e = "function" == typeof t ? Al(this, t) : null, s = (this._nativeAudioBufferSourceNode.onended = e, this._nativeAudioBufferSourceNode.onended); this._onended = null !== s && s === e ? t : s } get playbackRate() { return this._playbackRate } start(t = 0, e = 0, s) { if (this._nativeAudioBufferSourceNode.start(t, e, s), null !== this._audioBufferSourceNodeRenderer && (this._audioBufferSourceNodeRenderer.start = void 0 === s ? [t, e] : [t, e, s]), "closed" !== this.context.state) { ne(this); const t = () => { this._nativeAudioBufferSourceNode.removeEventListener("ended", t), _e(this) && oe(this) }; this._nativeAudioBufferSourceNode.addEventListener("ended", t) } } stop(t = 0) { this._nativeAudioBufferSourceNode.stop(t), null !== this._audioBufferSourceNodeRenderer && (this._audioBufferSourceNodeRenderer.stop = t) } }), jl = (n = e, pl = le, dl = a, vl = fs, yl = As, fl = (t, e, s) => { const i = t.destination; if (i.channelCount !== e) try { i.channelCount = e } catch { } s && "explicit" !== i.channelCountMode && (i.channelCountMode = "explicit"), 0 === i.maxChannelCount && Object.defineProperty(i, "maxChannelCount", { value: e }); const n = vl(t, { channelCount: e, channelCountMode: i.channelCountMode, channelInterpretation: i.channelInterpretation, gain: 1 }); return yl(n, "channelCount", t => () => t.call(n), t => e => { t.call(n, e); try { i.channelCount = e } catch (t) { if (e > i.maxChannelCount) throw t } }), yl(n, "channelCountMode", t => () => t.call(n), e => t => { e.call(n, t), i.channelCountMode = t }), yl(n, "channelInterpretation", t => () => t.call(n), e => t => { e.call(n, t), i.channelInterpretation = t }), Object.defineProperty(n, "maxChannelCount", { get: () => i.maxChannelCount }), n.connect(i), n }, class extends n { constructor(t, e) { var s = _l(t), i = ml(s), s = fl(s, e, i); super(t, !1, s, i ? (i => { const n = new WeakMap; return { render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { var s = e.destination; return n.set(e, s), await i(t, e, s), s })(t, e) } } })(gl) : null), this._isNodeOfNativeOfflineAudioContext = i, this._nativeAudioDestinationNode = s } get channelCount() { return this._nativeAudioDestinationNode.channelCount } set channelCount(t) { if (this._isNodeOfNativeOfflineAudioContext) throw dl(); if (t > this._nativeAudioDestinationNode.maxChannelCount) throw pl(); this._nativeAudioDestinationNode.channelCount = t } get channelCountMode() { return this._nativeAudioDestinationNode.channelCountMode } set channelCountMode(t) { if (this._isNodeOfNativeOfflineAudioContext) throw dl(); this._nativeAudioDestinationNode.channelCountMode = t } get maxChannelCount() { return this._nativeAudioDestinationNode.maxChannelCount } }), Ll = (al = ql, cl = m, ll = Fl, ul = gl = Us, () => { const n = new WeakMap; return { render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = cl(t); var i = u(s, e); if (!i) { const al = { Q: s.Q.value, channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, detune: s.detune.value, frequency: s.frequency.value, gain: s.gain.value, type: s.type }; s = hl(e, al) } return n.set(e, s), i ? (await al(e, t.Q, s.Q), await al(e, t.detune, s.detune), await al(e, t.frequency, s.frequency), await al(e, t.gain, s.gain)) : (await ll(e, t.Q, s.Q), await ll(e, t.detune, s.detune), await ll(e, t.frequency, s.frequency), await ll(e, t.gain, s.gain)), await ul(t, e, s), s })(t, e) } } }), zl = (ol = Ps, (t, e) => ol.set(t, e)), Wl = (r = e, Kc = wl = Nl, tl = Ll, el = es, sl = hl = ls, il = _l = Sl = Qs, nl = ml = kl = Zs, rl = zl, class extends r { constructor(t, e) { var s = il(t), e = { ...Ge, ...e }, e = sl(s, e), s = nl(s); super(t, !1, e, s ? tl() : null), this._Q = Kc(this, s, e.Q, fe, de), this._detune = Kc(this, s, e.detune, 1200 * Math.log2(fe), -1200 * Math.log2(fe)), this._frequency = Kc(this, s, e.frequency, t.sampleRate / 2, 0), this._gain = Kc(this, s, e.gain, 40 * Math.log10(fe), de), this._nativeBiquadFilterNode = e, rl(this, 1) } get detune() { return this._detune } get frequency() { return this._frequency } get gain() { return this._gain } get Q() { return this._Q } get type() { return this._nativeBiquadFilterNode.type } set type(t) { this._nativeBiquadFilterNode.type = t } getFrequencyResponse(t, e, s) { try { this._nativeBiquadFilterNode.getFrequencyResponse(t, e, s) } catch (t) { if (11 === t.code) throw el(); throw t } if (t.length !== e.length || e.length !== s.length) throw el() } }), Bl = ($c = Te, Jc = Js, (r, n, o) => { const a = new Set; return r.connect = (c = r.connect, (e, s = 0, i = 0) => { var t = 0 === a.size; if (Jc(e)) return c.call(r, e, s, i), $c(a, [e, s, i], t => t[0] === e && t[1] === s && t[2] === i, !0), t && n(), e; c.call(r, e, s), $c(a, [e, s], t => t[0] === e && t[1] === s, !0), t && n() }), r.disconnect = (h = r.disconnect, (t, e, s) => { var i = 0 < a.size; if (void 0 === t) h.apply(r), a.clear(); else if ("number" == typeof t) { h.call(r, t); for (const h of a) h[1] === t && a.delete(h) } else { Jc(t) ? h.call(r, t, e, s) : h.call(r, t, e); for (const h of a) h[0] !== t || void 0 !== e && h[1] !== e || void 0 !== s && h[2] !== s || a.delete(h) } var n = 0 === a.size; i && n && o() }), r; var h, c }), Ul = (Yc = a, (t, s) => { s.channelCount = 1, s.channelCountMode = "explicit", Object.defineProperty(s, "channelCount", { get: () => 1, set: () => { throw Yc() } }), Object.defineProperty(s, "channelCountMode", { get: () => "explicit", set: () => { throw Yc() } }); const i = t.createBufferSource(); Hc(s, () => { var e = s.numberOfInputs; for (let t = 0; t < e; t += 1)i.connect(s, 0, t) }, () => i.disconnect(s)) }), Gl = (Zc = Hs, Xc = Ul, (t, e) => { var s = t.createChannelMerger(e.numberOfInputs); return null !== Zc && "webkitAudioContext" === Zc.name && Xc(t, s), R(s, e), s }), Ql = (Gc = m, () => { const i = new WeakMap; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Gc(t); if (!u(s, e)) { const Gc = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, numberOfInputs: s.numberOfInputs }; s = Uc(e, Gc) } return i.set(e, s), await Qc(t, e, s), s })(t, e) } } }), Zl = (n = e, Lc = Ql, class extends n { constructor(t, e) { var s = Wc(t), e = { ...Qe, ...e }; super(t, !1, zc(s, e), Bc(s) ? Lc() : null) } }), Xl = (Pc = m, () => { const i = new WeakMap; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Pc(t); if (!u(s, e)) { const Pc = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, numberOfOutputs: s.numberOfOutputs }; s = Nc(e, Pc) } return i.set(e, s), await jc(t, e, s), s })(t, e) } } }), Yl = (r = e, qc = Xl, Ic = Nc = us, class extends r { constructor(t, e) { var s = Fc(t), e = { ...e = { ...Ze, ...e }, channelCount: e.numberOfOutputs }; super(t, !1, Ic(s, e), Vc(s) ? qc() : null) } }), Hl = (Rc = Hc = Bl, (t, { offset: e, ...s }) => { const i = t.createBuffer(1, 2, 44100), n = Mc(t, { buffer: null, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", loop: !1, loopEnd: 0, loopStart: 0, playbackRate: 1 }), r = Ec(t, { ...s, gain: e }), o = i.getChannelData(0); o[0] = 1, o[1] = 1, n.buffer = i, n.loop = !0; s = { get bufferSize() { }, get channelCount() { return r.channelCount }, set channelCount(t) { r.channelCount = t }, get channelCountMode() { return r.channelCountMode }, set channelCountMode(t) { r.channelCountMode = t }, get channelInterpretation() { return r.channelInterpretation }, set channelInterpretation(t) { r.channelInterpretation = t }, get context() { return r.context }, get inputs() { return [] }, get numberOfInputs() { return n.numberOfInputs }, get numberOfOutputs() { return r.numberOfOutputs }, get offset() { return r.gain }, get onended() { return n.onended }, set onended(t) { n.onended = t }, addEventListener: (...t) => n.addEventListener(t[0], t[1], t[2]), dispatchEvent: (...t) => n.dispatchEvent(t[0]), removeEventListener: (...t) => n.removeEventListener(t[0], t[1], t[2]), start(t = 0) { n.start.call(n, t) }, stop(t = 0) { n.stop.call(n, t) } }; return Dc(t, n), Rc(ps(s, r), () => n.connect(r), () => n.disconnect(r)) }), $l = (Sc = Dc = El, kc = Ls, Ac = Hl, Cc = Os, Oc = Ms, (t, e) => { if (void 0 === t.createConstantSource) return Ac(t, e); var s = t.createConstantSource(); return R(s, e), i(s, e, "offset"), kc(Cc, () => Cc(t)) || as(s), kc(Oc, () => Oc(t)) || hs(s), Sc(t, s), s }), Jl = (wc = m, () => { const n = new WeakMap; let r = null, o = null; return { set start(t) { r = t }, set stop(t) { o = t }, render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = wc(t); var i = u(s, e); if (!i) { const yc = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, offset: s.offset.value }; s = xc(e, yc), null !== r && s.start(r), null !== o && s.stop(o) } return n.set(e, s), i ? await yc(e, t.offset, s.offset) : await bc(e, t.offset, s.offset), await Tc(t, e, s), s })(t, e) } } }), Kl = (n = e, fc = Jl, vc = Is, class extends n { constructor(t, e) { var s = mc(t), e = { ...Xe, ...e }, e = _c(s, e), s = gc(s), i = s ? fc() : null; super(t, !1, e, i), this._constantSourceNodeRenderer = i, this._nativeConstantSourceNode = e, this._offset = dc(this, s, e.offset, fe, de), this._onended = null } get offset() { return this._offset } get onended() { return this._onended } set onended(t) { var e = "function" == typeof t ? vc(this, t) : null, s = (this._nativeConstantSourceNode.onended = e, this._nativeConstantSourceNode.onended); this._onended = null !== s && s === e ? t : s } start(t = 0) { if (this._nativeConstantSourceNode.start(t), null !== this._constantSourceNodeRenderer && (this._constantSourceNodeRenderer.start = t), "closed" !== this.context.state) { ne(this); const t = () => { this._nativeConstantSourceNode.removeEventListener("ended", t), _e(this) && oe(this) }; this._nativeConstantSourceNode.addEventListener("ended", t) } } stop(t = 0) { this._nativeConstantSourceNode.stop(t), null !== this._constantSourceNodeRenderer && (this._constantSourceNodeRenderer.stop = t) } }), tu = (t, e) => { const s = t.createConvolver(); if (R(s, e), e.disableNormalization === s.normalize && (s.normalize = !e.disableNormalization), h(s, e, "buffer"), 2 < e.channelCount) throw uc(); if (pc(s, "channelCount", t => () => t.call(s), e => t => { if (2 < t) throw uc(); return e.call(s, t) }), "max" === e.channelCountMode) throw uc(); return pc(s, "channelCountMode", t => () => t.call(s), e => t => { if ("max" === t) throw uc(); return e.call(s, t) }), s }, eu = (cc = m, () => { const i = new WeakMap; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = cc(t); if (!u(s, e)) { const cc = { buffer: s.buffer, channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, disableNormalization: !s.normalize }; s = hc(e, cc) } return i.set(e, s), Ae(s) ? await lc(t, e, s.inputs[0]) : await lc(t, e, s), s })(t, e) } } }), su = (r = e, ic = eu, nc = hc = tu, class extends r { constructor(t, e) { var s = rc(t), e = { ...Ye, ...e }, i = nc(s, e); super(t, !1, i, oc(s) ? ic() : null), this._isBufferNullified = !1, this._nativeConvolverNode = i, null !== e.buffer && ac(this, e.buffer.duration) } get buffer() { return this._isBufferNullified ? null : this._nativeConvolverNode.buffer } set buffer(t) { if (null === (this._nativeConvolverNode.buffer = t) && null !== this._nativeConvolverNode.buffer) { const t = this._nativeConvolverNode.context; this._nativeConvolverNode.buffer = t.createBuffer(1, 1, t.sampleRate), this._isBufferNullified = !0, ac(this, 0) } else this._isBufferNullified = !1, ac(this, null === this._nativeConvolverNode.buffer ? 0 : this._nativeConvolverNode.buffer.duration) } get normalize() { return this._nativeConvolverNode.normalize } set normalize(t) { this._nativeConvolverNode.normalize = t } }), iu = (tc = m, n => { const r = new WeakMap; return { render(t, e) { var s = r.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = tc(t); var i = u(s, e); if (!i) { const Jh = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, delayTime: s.delayTime.value, maxDelayTime: n }; s = Kh(e, Jh) } return r.set(e, s), i ? await Jh(e, t.delayTime, s.delayTime) : await ec(e, t.delayTime, s.delayTime), await sc(t, e, s), s })(t, e) } } }), nu = (n = e, Zh = iu, Xh = Kh = ds, class extends n { constructor(t, e) { var s = Yh(t), e = { ...$e, ...e }, i = Xh(s, e), s = Hh(s); super(t, !1, i, s ? Zh(e.maxDelayTime) : null), this._delayTime = Qh(this, s, i.delayTime), $h(this, e.maxDelayTime) } get delayTime() { return this._delayTime } }), ru = (t, e) => { t = t.createDynamicsCompressor(); if (R(t, e), 2 < e.channelCount) throw Gh(); if ("max" === e.channelCountMode) throw Gh(); return i(t, e, "attack"), i(t, e, "knee"), i(t, e, "ratio"), i(t, e, "release"), i(t, e, "threshold"), t }, ou = (Wh = m, () => { const n = new WeakMap; return { render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Wh(t); var i = u(s, e); if (!i) { const Lh = { attack: s.attack.value, channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, knee: s.knee.value, ratio: s.ratio.value, release: s.release.value, threshold: s.threshold.value }; s = zh(e, Lh) } return n.set(e, s), i ? (await Lh(e, t.attack, s.attack), await Lh(e, t.knee, s.knee), await Lh(e, t.ratio, s.ratio), await Lh(e, t.release, s.release), await Lh(e, t.threshold, s.threshold)) : (await Bh(e, t.attack, s.attack), await Bh(e, t.knee, s.knee), await Bh(e, t.ratio, s.ratio), await Bh(e, t.release, s.release), await Bh(e, t.threshold, s.threshold)), await Uh(t, e, s), s })(t, e) } } }), au = (r = e, Ih = ou, Fh = zh = ru, class extends r { constructor(t, e) { var s = Nh(t), e = { ...Ke, ...e }, e = Fh(s, e), s = Ph(s); super(t, !1, e, s ? Ih() : null), this._attack = qh(this, s, e.attack), this._knee = qh(this, s, e.knee), this._nativeDynamicsCompressorNode = e, this._ratio = qh(this, s, e.ratio), this._release = qh(this, s, e.release), this._threshold = qh(this, s, e.threshold), jh(this, .006) } get attack() { return this._attack } get channelCount() { return this._nativeDynamicsCompressorNode.channelCount } set channelCount(t) { var e = this._nativeDynamicsCompressorNode.channelCount; if (2 < (this._nativeDynamicsCompressorNode.channelCount = t)) throw this._nativeDynamicsCompressorNode.channelCount = e, Vh() } get channelCountMode() { return this._nativeDynamicsCompressorNode.channelCountMode } set channelCountMode(t) { var e = this._nativeDynamicsCompressorNode.channelCountMode; if ("max" === (this._nativeDynamicsCompressorNode.channelCountMode = t)) throw this._nativeDynamicsCompressorNode.channelCountMode = e, Vh() } get knee() { return this._knee } get ratio() { return this._ratio } get reduction() { return "number" == typeof this._nativeDynamicsCompressorNode.reduction.value ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction } get release() { return this._release } get threshold() { return this._threshold } }), hu = (Oh = Lh = Jh = yc = ql, Mh = m, Eh = Bh = ec = bc = Fl, () => { const n = new WeakMap; return { render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Mh(t); var i = u(s, e); if (!i) { const Oh = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, gain: s.gain.value }; s = Dh(e, Oh) } return n.set(e, s), i ? await Oh(e, t.gain, s.gain) : await Eh(e, t.gain, s.gain), await Rh(t, e, s), s })(t, e) } } }), cu = (n = e, Sh = hu, class extends n { constructor(t, e) { var s = Ah(t), e = { ...ts, ...e }, e = kh(s, e), s = Ch(s); super(t, !1, e, s ? Sh() : null), this._gain = Th(this, s, e.gain, fe, de) } get gain() { return this._gain } }), lu = (yh = es, xh = a, (t, e, { channelCount: s, channelCountMode: i, channelInterpretation: n, feedback: r, feedforward: o }) => { const a = cs(e, t.sampleRate), l = r instanceof Float64Array ? r : new Float64Array(r), u = o instanceof Float64Array ? o : new Float64Array(o), h = l.length, c = u.length, p = Math.min(h, c); if (0 === h || 20 < h) throw bh(); if (0 === l[0]) throw xh(); if (0 === c || 20 < c) throw bh(); if (0 === u[0]) throw xh(); if (1 !== l[0]) { for (let t = 0; t < c; t += 1)u[t] /= l[0]; for (let t = 1; t < h; t += 1)l[t] /= l[0] } const d = wh(t, a, s, s), f = (d.channelCount = s, d.channelCountMode = i, d.channelInterpretation = n, []), _ = [], m = []; for (let t = 0; t < s; t += 1) { f.push(0); const yh = new Float32Array(32), xh = new Float32Array(32); yh.fill(0), xh.fill(0), _.push(yh), m.push(xh) } d.onaudioprocess = t => { const e = t.inputBuffer, s = t.outputBuffer, i = e.numberOfChannels; for (let t = 0; t < i; t += 1) { const i = e.getChannelData(t), n = s.getChannelData(t); f[t] = is(l, h, u, c, p, _[t], m[t], f[t], 32, i, n) } }; const g = t.sampleRate / 2; return ps({ get bufferSize() { return a }, get channelCount() { return d.channelCount }, set channelCount(t) { d.channelCount = t }, get channelCountMode() { return d.channelCountMode }, set channelCountMode(t) { d.channelCountMode = t }, get channelInterpretation() { return d.channelInterpretation }, set channelInterpretation(t) { d.channelInterpretation = t }, get context() { return d.context }, get inputs() { return [d] }, get numberOfInputs() { return d.numberOfInputs }, get numberOfOutputs() { return d.numberOfOutputs }, addEventListener: (...t) => d.addEventListener(t[0], t[1], t[2]), dispatchEvent: (...t) => d.dispatchEvent(t[0]), getFrequencyResponse(e, s, i) { if (e.length !== s.length || s.length !== i.length) throw yh(); const n = e.length; for (let t = 0; t < n; t += 1) { const n = -Math.PI * (e[t] / g), h = [Math.cos(n), Math.sin(n)], c = (r = _s(u, h), o = _s(l, h), a = void 0, a = o[0] * o[0] + o[1] * o[1], [(r[0] * o[0] + r[1] * o[1]) / a, (r[1] * o[0] - r[0] * o[1]) / a]); s[t] = Math.sqrt(c[0] * c[0] + c[1] * c[1]), i[t] = Math.atan2(c[1], c[0]) } var r, o, a }, removeEventListener: (...t) => d.removeEventListener(t[0], t[1], t[2]) }, d) }), uu = (dh = Ls, gh = fh = kh = Dh = Ec = fs, vh = t, mh = () => { if (null === vh) return Promise.resolve(!1); const e = new vh(1, 1, 44100), s = gh(e, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: 0 }); return new Promise(t => { e.oncomplete = () => { s.disconnect(), t(0 !== e.currentTime) }, e.startRendering() }) }, i => dh(rs, () => rs(i)) ? Promise.resolve(dh(mh, mh)).then(t => { if (!t) { const t = _h(i, 512, 0, 1); i.oncomplete = () => { t.onaudioprocess = null, t.disconnect() }, t.onaudioprocess = () => i.currentTime, t.connect(i.destination) } return i.startRendering() }) : new Promise(e => { const s = fh(i, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: 0 }); i.oncomplete = t => { s.disconnect(), e(t.renderedBuffer) }, s.connect(i.destination), i.startRendering() })), pu = (hh = Mc = Il, ch = m, lh = t, uh = Rh = Uh = sc = lc = Tc = jc = Qc = Us, ph = uu, (_, m) => { const i = new WeakMap; let n = null; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (d, f) => { let t = null, e = ch(d); var s = u(e, f); if (void 0 === f.createIIRFilter ? t = hh(f, { buffer: null, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", loop: !1, loopEnd: 0, loopStart: 0, playbackRate: 1 }) : s || (e = f.createIIRFilter(m, _)), i.set(f, null === t ? e : t), null === t) return await uh(d, f, e), e; { if (null === n) { if (null === lh) throw new Error("Missing the native OfflineAudioContext constructor."); const hh = new lh(d.context.destination.channelCount, d.context.length, f.sampleRate); n = (async () => { await uh(d, hh, hh.destination); { var e = await ph(hh), t = f, s = _, i = m; const n = s instanceof Float64Array ? s : new Float64Array(s), r = i instanceof Float64Array ? i : new Float64Array(i), o = n.length, a = r.length, h = Math.min(o, a); if (1 !== n[0]) { for (let t = 0; t < o; t += 1)r[t] /= n[0]; for (let t = 1; t < a; t += 1)n[t] /= n[0] } const c = new Float32Array(32), l = new Float32Array(32), u = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate), p = e.numberOfChannels; for (let t = 0; t < p; t += 1) { const s = e.getChannelData(t), i = u.getChannelData(t); c.fill(0), l.fill(0), is(n, o, r, a, h, c, l, 0, 32, s, i) } return u } })() } const hh = await n; return t.buffer = hh, t.start(0), t } })(t, e) } } }), du = (ah = lu, (t, e, s) => { if (void 0 === t.createIIRFilter) return ah(t, e, s); e = t.createIIRFilter(s.feedforward, s.feedback); return R(e, s), e }), fu = (r = e, sh = du, ih = pu, nh = Ah = Nh = Yh = rc = mc = Fc = Wc = Qs, oh = jh = $h = ac = zl, class extends r { constructor(t, e) { var i, n, s = nh(t), r = rh(s), e = { ...ss, ...e }, s = sh(s, r ? null : t.baseLatency, e); super(t, !1, s, r ? ih(e.feedback, e.feedforward) : null), (i = s).getFrequencyResponse = (n = i.getFrequencyResponse, (t, e, s) => { if (t.length !== e.length || e.length !== s.length) throw es(); return n.call(i, t, e, s) }), this._nativeIIRFilterNode = s, oh(this, 1) } getFrequencyResponse(t, e, s) { return this._nativeIIRFilterNode.getFrequencyResponse(t, e, s) } }), _u = (Xa = Th = qh = Qh = dc = Nl, Ya = zc = Uc = Gl, Ha = _c = xc = $l, $a = _h = wh = ms, Ja = bh = Vh = Gh = uc = gs, Ka = Ss, th = rh = Ch = Ph = Hh = oc = gc = Vc = Bc = Zs, eh = pc = As, (_, m) => { const a = m.listener, { forwardX: t, forwardY: e, forwardZ: s, positionX: i, positionY: n, positionZ: r, upX: o, upY: h, upZ: c } = void 0 === a.forwardX ? (() => { const i = new Float32Array(1), p = Ya(m, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: 9 }), d = th(m); let e = !1, n = [0, 0, -1, 0, 1, 0], r = [0, 0, 0]; const f = () => { if (!e) { e = !0; const t = $a(m, 256, 9, 0); t.onaudioprocess = ({ inputBuffer: t }) => { const e = [Ka(t, i, 0), Ka(t, i, 1), Ka(t, i, 2), Ka(t, i, 3), Ka(t, i, 4), Ka(t, i, 5)], s = (e.some((t, e) => t !== n[e]) && (a.setOrientation(...e), n = e), [Ka(t, i, 6), Ka(t, i, 7), Ka(t, i, 8)]); s.some((t, e) => t !== r[e]) && (a.setPosition(...s), r = s) }, p.connect(t) } }, t = e => t => { t !== n[e] && (n[e] = t, a.setOrientation(...n)) }, s = e => t => { t !== r[e] && (r[e] = t, a.setPosition(...r)) }, o = (t, e, s) => { const i = Ha(m, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", offset: e }), n = (i.connect(p, 0, t), i.start(), Object.defineProperty(i.offset, "defaultValue", { get: () => e }), Xa({ context: _ }, d, i.offset, fe, de)); var r, o, a, h, c, l, u; return eh(n, "value", t => () => t.call(n), e => t => { try { e.call(n, t) } catch (t) { if (9 !== t.code) throw t } f(), d && s(t) }), n.cancelAndHoldAtTime = (r = n.cancelAndHoldAtTime, d ? () => { throw Ja() } : (...t) => { t = r.apply(n, t); return f(), t }), n.cancelScheduledValues = (o = n.cancelScheduledValues, d ? () => { throw Ja() } : (...t) => { t = o.apply(n, t); return f(), t }), n.exponentialRampToValueAtTime = (a = n.exponentialRampToValueAtTime, d ? () => { throw Ja() } : (...t) => { t = a.apply(n, t); return f(), t }), n.linearRampToValueAtTime = (h = n.linearRampToValueAtTime, d ? () => { throw Ja() } : (...t) => { t = h.apply(n, t); return f(), t }), n.setTargetAtTime = (c = n.setTargetAtTime, d ? () => { throw Ja() } : (...t) => { t = c.apply(n, t); return f(), t }), n.setValueAtTime = (l = n.setValueAtTime, d ? () => { throw Ja() } : (...t) => { t = l.apply(n, t); return f(), t }), n.setValueCurveAtTime = (u = n.setValueCurveAtTime, d ? () => { throw Ja() } : (...t) => { t = u.apply(n, t); return f(), t }), n }; return { forwardX: o(0, 0, t(0)), forwardY: o(1, 0, t(1)), forwardZ: o(2, -1, t(2)), positionX: o(6, 0, s(0)), positionY: o(7, 0, s(1)), positionZ: o(8, 0, s(2)), upX: o(3, 0, t(3)), upY: o(4, 1, t(4)), upZ: o(5, 0, t(5)) } })() : a; return { get forwardX() { return t }, get forwardY() { return e }, get forwardZ() { return s }, get positionX() { return i }, get positionY() { return n }, get positionZ() { return r }, get upX() { return o }, get upY() { return h }, get upZ() { return c } } }), mu = new WeakMap, gu = (Ba = jl, Ua = _u, Qa = mu, class extends Ys { constructor(t, e) { super(t), this._nativeContext = t, Ut.set(this, t), Ga(t) && Qa.set(t, new Set), this._destination = new Ba(this, e), this._listener = Ua(this, t), this._onstatechange = null } get currentTime() { return this._nativeContext.currentTime } get destination() { return this._destination } get listener() { return this._listener } get onstatechange() { return this._onstatechange } set onstatechange(t) { var e = "function" == typeof t ? Za(this, t) : null, s = (this._nativeContext.onstatechange = e, this._nativeContext.onstatechange); this._onstatechange = null !== s && s === e ? t : s } get sampleRate() { return this._nativeContext.sampleRate } get state() { return this._nativeContext.state } }), vu = (Na = El, Pa = Ls, ja = Os, La = Ds, za = Ms, Wa = qs, (t, e) => { const s = t.createOscillator(); return R(s, e), i(s, e, "detune"), i(s, e, "frequency"), void 0 !== e.periodicWave ? s.setPeriodicWave(e.periodicWave) : h(s, e, "type"), Pa(ja, () => ja(t)) || as(s), Pa(La, () => La(t)) || Wa(s, t), Pa(za, () => za(t)) || hs(s), Na(t, s), s }), yu = (Ia = m, () => { const n = new WeakMap; let r = null, o = null, a = null; return { set periodicWave(t) { r = t }, set start(t) { o = t }, set stop(t) { a = t }, render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Ia(t); var i = u(s, e); if (!i) { const Ra = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, detune: s.detune.value, frequency: s.frequency.value, periodicWave: null === r ? void 0 : r, type: s.type }; s = qa(e, Ra), null !== o && s.start(o), null !== a && s.stop(a) } return n.set(e, s), i ? (await Ra(e, t.detune, s.detune), await Ra(e, t.frequency, s.frequency)) : (await Fa(e, t.detune, s.detune), await Fa(e, t.frequency, s.frequency)), await Va(t, e, s), s })(t, e) } } }), xu = (n = e, Ca = qa = vu, Oa = yu, Ea = Za = Is, class extends n { constructor(t, e) { var s = Da(t), e = { ...ys, ...e }, i = Ca(s, e), s = Ma(s), n = s ? Oa() : null, r = t.sampleRate / 2; super(t, !1, i, n), this._detune = Aa(this, s, i.detune, 153600, -153600), this._frequency = Aa(this, s, i.frequency, r, -r), this._nativeOscillatorNode = i, this._onended = null, this._oscillatorNodeRenderer = n, null !== this._oscillatorNodeRenderer && void 0 !== e.periodicWave && (this._oscillatorNodeRenderer.periodicWave = e.periodicWave) } get detune() { return this._detune } get frequency() { return this._frequency } get onended() { return this._onended } set onended(t) { var e = "function" == typeof t ? Ea(this, t) : null, s = (this._nativeOscillatorNode.onended = e, this._nativeOscillatorNode.onended); this._onended = null !== s && s === e ? t : s } get type() { return this._nativeOscillatorNode.type } set type(t) { this._nativeOscillatorNode.type = t, null !== this._oscillatorNodeRenderer && (this._oscillatorNodeRenderer.periodicWave = null) } setPeriodicWave(t) { this._nativeOscillatorNode.setPeriodicWave(t), null !== this._oscillatorNodeRenderer && (this._oscillatorNodeRenderer.periodicWave = t) } start(t = 0) { if (this._nativeOscillatorNode.start(t), null !== this._oscillatorNodeRenderer && (this._oscillatorNodeRenderer.start = t), "closed" !== this.context.state) { ne(this); const t = () => { this._nativeOscillatorNode.removeEventListener("ended", t), _e(this) && oe(this) }; this._nativeOscillatorNode.addEventListener("ended", t) } } stop(t = 0) { this._nativeOscillatorNode.stop(t), null !== this._oscillatorNodeRenderer && (this._oscillatorNodeRenderer.stop = t) } }), wu = (ka = Il, (t, e) => { const s = ka(t, { buffer: null, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", loop: !1, loopEnd: 0, loopStart: 0, playbackRate: 1 }), i = t.createBuffer(1, 2, 44100); return s.buffer = i, s.loop = !0, s.connect(e), s.start(), () => { s.stop(), s.disconnect(e) } }), bu = (wa = a, (r, { curve: t, oversample: e, ...s }) => { const o = r.createWaveShaper(), a = r.createWaveShaper(), h = (R(o, s), R(a, s), ba(r, { ...s, gain: 1 })), i = ba(r, { ...s, gain: -1 }), n = ba(r, { ...s, gain: 1 }), c = ba(r, { ...s, gain: -1 }); let l = null, u = !1, p = null; const d = { get bufferSize() { }, get channelCount() { return o.channelCount }, set channelCount(t) { h.channelCount = t, i.channelCount = t, o.channelCount = t, n.channelCount = t, a.channelCount = t, c.channelCount = t }, get channelCountMode() { return o.channelCountMode }, set channelCountMode(t) { h.channelCountMode = t, i.channelCountMode = t, o.channelCountMode = t, n.channelCountMode = t, a.channelCountMode = t, c.channelCountMode = t }, get channelInterpretation() { return o.channelInterpretation }, set channelInterpretation(t) { h.channelInterpretation = t, i.channelInterpretation = t, o.channelInterpretation = t, n.channelInterpretation = t, a.channelInterpretation = t, c.channelInterpretation = t }, get context() { return o.context }, get curve() { return p }, set curve(e) { if (null !== e && e.length < 2) throw wa(); if (null === e) o.curve = e, a.curve = e; else { const xa = e.length, wa = new Float32Array(xa + 2 - xa % 2), Ta = new Float32Array(xa + 2 - xa % 2), s = (wa[0] = e[0], Ta[0] = -e[xa - 1], Math.ceil((xa + 1) / 2)), r = (xa + 1) / 2 - 1; for (let t = 1; t < s; t += 1) { const i = t / s * r, n = Math.floor(i), o = Math.ceil(i); wa[t] = n === o ? e[n] : (1 - (i - n)) * e[n] + (1 - (o - i)) * e[o], Ta[t] = n === o ? -e[xa - 1 - n] : -(1 - (i - n)) * e[xa - 1 - n] - (1 - (o - i)) * e[xa - 1 - o] } wa[s] = xa % 2 == 1 ? e[s - 1] : (e[s - 2] + e[s - 1]) / 2, o.curve = wa, a.curve = Ta } p = e, u && (Ta(p) && null === l ? l = xa(r, h) : null !== l && (l(), l = null)) }, get inputs() { return [h] }, get numberOfInputs() { return o.numberOfInputs }, get numberOfOutputs() { return o.numberOfOutputs }, get oversample() { return o.oversample }, set oversample(t) { o.oversample = t, a.oversample = t }, addEventListener: (...t) => h.addEventListener(t[0], t[1], t[2]), dispatchEvent: (...t) => h.dispatchEvent(t[0]), removeEventListener: (...t) => h.removeEventListener(t[0], t[1], t[2]) }; return null !== t && (d.curve = t instanceof Float32Array ? t : new Float32Array(t)), e !== d.oversample && (d.oversample = e), Sa(ps(d, n), () => { h.connect(o).connect(n), h.connect(i).connect(a).connect(c).connect(n), u = !0, Ta(p) && (l = xa(r, h)) }, () => { h.disconnect(o), o.disconnect(n), h.disconnect(i), i.disconnect(a), a.disconnect(c), c.disconnect(n), u = !1, null !== l && (l(), l = null) }) }), Tu = (da = xa = wu, fa = a, _a = bu, ma = Ta = ks, va = Hs, ya = As, (s, t) => { const i = s.createWaveShaper(); if (null !== va && "webkitAudioContext" === va.name && void 0 === s.createGain().gain.automationRate) return _a(s, t); R(i, t); var e = null === t.curve || t.curve instanceof Float32Array ? t.curve : new Float32Array(t.curve); if (null !== e && e.length < 2) throw fa(); h(i, { curve: e }, "curve"), h(i, t, "oversample"); let n = null, r = !1; return ya(i, "curve", t => () => t.call(i), e => t => (e.call(i, t), r && (ma(t) && null === n ? n = da(s, i) : ma(t) || null === n || (n(), n = null)), t)), ga(i, () => { r = !0, ma(i.curve) && (n = da(s, i)) }, () => { r = !1, null !== n && (n(), n = null) }) }), Su = (ia = Ce, na = a, aa = ms, ha = Tu, ca = gs, la = Ee, ua = Ss, pa = ga = Sa = Bl, (t, { coneInnerAngle: e, coneOuterAngle: s, coneOuterGain: i, distanceModel: n, maxDistance: r, orientationX: o, orientationY: a, orientationZ: h, panningModel: c, positionX: l, positionY: u, positionZ: p, refDistance: d, rolloffFactor: f, ..._ }) => { const m = t.createPanner(); if (2 < _.channelCount) throw ca(); if ("max" === _.channelCountMode) throw ca(); R(m, _); const g = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, v = ra(t, { ...g, channelInterpretation: "speakers", numberOfInputs: 6 }), y = oa(t, { ..._, gain: 1 }), x = oa(t, { ...g, gain: 1 }), w = oa(t, { ...g, gain: 0 }), b = oa(t, { ...g, gain: 0 }), T = oa(t, { ...g, gain: 0 }), S = oa(t, { ...g, gain: 0 }), k = oa(t, { ...g, gain: 0 }), A = aa(t, 256, 6, 1), C = ha(t, { ...g, curve: new Float32Array([1, 1]), oversample: "none" }); let O = [o, a, h], D = [l, u, p]; const M = new Float32Array(1), E = (A.onaudioprocess = ({ inputBuffer: t }) => { const e = [ua(t, M, 0), ua(t, M, 1), ua(t, M, 2)], s = (e.some((t, e) => t !== O[e]) && (m.setOrientation(...e), O = e), [ua(t, M, 3), ua(t, M, 4), ua(t, M, 5)]); s.some((t, e) => t !== D[e]) && (m.setPosition(...s), D = s) }, Object.defineProperty(w.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(b.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(T.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(S.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(k.gain, "defaultValue", { get: () => 0 }), { get bufferSize() { }, get channelCount() { return m.channelCount }, set channelCount(t) { if (2 < t) throw ca(); y.channelCount = t, m.channelCount = t }, get channelCountMode() { return m.channelCountMode }, set channelCountMode(t) { if ("max" === t) throw ca(); y.channelCountMode = t, m.channelCountMode = t }, get channelInterpretation() { return m.channelInterpretation }, set channelInterpretation(t) { y.channelInterpretation = t, m.channelInterpretation = t }, get coneInnerAngle() { return m.coneInnerAngle }, set coneInnerAngle(t) { m.coneInnerAngle = t }, get coneOuterAngle() { return m.coneOuterAngle }, set coneOuterAngle(t) { m.coneOuterAngle = t }, get coneOuterGain() { return m.coneOuterGain }, set coneOuterGain(t) { if (t < 0 || 1 < t) throw na(); m.coneOuterGain = t }, get context() { return m.context }, get distanceModel() { return m.distanceModel }, set distanceModel(t) { m.distanceModel = t }, get inputs() { return [y] }, get maxDistance() { return m.maxDistance }, set maxDistance(t) { if (t < 0) throw new RangeError; m.maxDistance = t }, get numberOfInputs() { return m.numberOfInputs }, get numberOfOutputs() { return m.numberOfOutputs }, get orientationX() { return x.gain }, get orientationY() { return w.gain }, get orientationZ() { return b.gain }, get panningModel() { return m.panningModel }, set panningModel(t) { m.panningModel = t }, get positionX() { return T.gain }, get positionY() { return S.gain }, get positionZ() { return k.gain }, get refDistance() { return m.refDistance }, set refDistance(t) { if (t < 0) throw new RangeError; m.refDistance = t }, get rolloffFactor() { return m.rolloffFactor }, set rolloffFactor(t) { if (t < 0) throw new RangeError; m.rolloffFactor = t }, addEventListener: (...t) => y.addEventListener(t[0], t[1], t[2]), dispatchEvent: (...t) => y.dispatchEvent(t[0]), removeEventListener: (...t) => y.removeEventListener(t[0], t[1], t[2]) }); return e !== E.coneInnerAngle && (E.coneInnerAngle = e), s !== E.coneOuterAngle && (E.coneOuterAngle = s), i !== E.coneOuterGain && (E.coneOuterGain = i), n !== E.distanceModel && (E.distanceModel = n), r !== E.maxDistance && (E.maxDistance = r), o !== E.orientationX.value && (E.orientationX.value = o), a !== E.orientationY.value && (E.orientationY.value = a), h !== E.orientationZ.value && (E.orientationZ.value = h), c !== E.panningModel && (E.panningModel = c), l !== E.positionX.value && (E.positionX.value = l), u !== E.positionY.value && (E.positionY.value = u), p !== E.positionZ.value && (E.positionZ.value = p), d !== E.refDistance && (E.refDistance = d), f !== E.rolloffFactor && (E.rolloffFactor = f), 1 === O[0] && 0 === O[1] && 0 === O[2] || m.setOrientation(...O), 0 === D[0] && 0 === D[1] && 0 === D[2] || m.setPosition(...D), pa(ps(E, m), () => { y.connect(m), ia(y, C, 0, 0), C.connect(x).connect(v, 0, 0), C.connect(w).connect(v, 0, 1), C.connect(b).connect(v, 0, 2), C.connect(T).connect(v, 0, 3), C.connect(S).connect(v, 0, 4), C.connect(k).connect(v, 0, 5), v.connect(A).connect(t.destination) }, () => { y.disconnect(m), la(y, C, 0, 0), C.disconnect(x), x.disconnect(v), C.disconnect(w), w.disconnect(v), C.disconnect(b), b.disconnect(v), C.disconnect(T), T.disconnect(v), C.disconnect(S), S.disconnect(v), C.disconnect(k), k.disconnect(v), v.disconnect(A), A.disconnect(t.destination) }) }), ku = (sa = Su, (t, e) => { var s = t.createPanner(); return void 0 === s.orientationX ? sa(t, e) : (R(s, e), i(s, e, "orientationX"), i(s, e, "orientationY"), i(s, e, "orientationZ"), i(s, e, "positionX"), i(s, e, "positionY"), i(s, e, "positionZ"), h(s, e, "coneInnerAngle"), h(s, e, "coneOuterAngle"), h(s, e, "coneOuterGain"), h(s, e, "distanceModel"), h(s, e, "maxDistance"), h(s, e, "panningModel"), h(s, e, "refDistance"), h(s, e, "rolloffFactor"), s) }), Au = (p = Ra = ql, Zo = ra = Gl, Xo = $l, Yo = oa = ba = fs, $o = m, Jo = t, Ko = Fa = Fl, ta = Va = Us, ea = uu, () => { const c = new WeakMap; let l = null; return { render(t, e) { var s = c.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, r) => { let o = null, e = $o(t); var a = { channelCount: e.channelCount, channelCountMode: e.channelCountMode, channelInterpretation: e.channelInterpretation }, h = { ...a, coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, panningModel: e.panningModel, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor }, s = u(e, r); if ("bufferSize" in e) o = Yo(r, { ...a, gain: 1 }); else if (!s) { const p = { ...h, orientationX: e.orientationX.value, orientationY: e.orientationY.value, orientationZ: e.orientationZ.value, positionX: e.positionX.value, positionY: e.positionY.value, positionZ: e.positionZ.value }; e = Ho(r, p) } if (c.set(r, null === o ? e : o), null === o) return s ? (await p(r, t.orientationX, e.orientationX), await p(r, t.orientationY, e.orientationY), await p(r, t.orientationZ, e.orientationZ), await p(r, t.positionX, e.positionX), await p(r, t.positionY, e.positionY), await p(r, t.positionZ, e.positionZ)) : (await Ko(r, t.orientationX, e.orientationX), await Ko(r, t.orientationY, e.orientationY), await Ko(r, t.orientationZ, e.orientationZ), await Ko(r, t.positionX, e.positionX), await Ko(r, t.positionY, e.positionY), await Ko(r, t.positionZ, e.positionZ)), Ae(e) ? await ta(t, r, e.inputs[0]) : await ta(t, r, e), e; { if (null === l) { if (null === Jo) throw new Error("Missing the native OfflineAudioContext constructor."); const p = new Jo(6, t.context.length, r.sampleRate), Yo = Zo(p, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: 6 }); Yo.connect(p.destination), l = (async () => { const e = await Promise.all([t.orientationX, t.orientationY, t.orientationZ, t.positionX, t.positionY, t.positionZ].map(async (t, e) => { e = Xo(p, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", offset: 0 === e ? 1 : 0 }); return await Ko(p, t, e.offset), e })); for (let t = 0; t < 6; t += 1)e[t].connect(Yo, 0, t), e[t].start(0); return ea(p) })() } const p = await l, $o = Yo(r, { ...a, gain: 1 }), c = (await ta(t, r, $o), []); for (let t = 0; t < p.numberOfChannels; t += 1)c.push(p.getChannelData(t)); let s = [c[0][0], c[1][0], c[2][0]], i = [c[3][0], c[4][0], c[5][0]], e = Yo(r, { ...a, gain: 1 }), n = Ho(r, { ...h, orientationX: s[0], orientationY: s[1], orientationZ: s[2], positionX: i[0], positionY: i[1], positionZ: i[2] }); $o.connect(e).connect(n.inputs[0]), n.connect(o); for (let t = 128; t < p.length; t += 128) { const p = [c[0][t], c[1][t], c[2][t]], Xo = [c[3][t], c[4][t], c[5][t]]; if (p.some((t, e) => t !== s[e]) || Xo.some((t, e) => t !== i[e])) { s = p, i = Xo; const Jo = t / r.sampleRate; e.gain.setValueAtTime(0, Jo), e = Yo(r, { ...a, gain: 0 }), n = Ho(r, { ...h, orientationX: s[0], orientationY: s[1], orientationZ: s[2], positionX: i[0], positionY: i[1], positionZ: i[2] }), e.gain.setValueAtTime(1, Jo), $o.connect(e).connect(n.inputs[0]), n.connect(o) } } return o } })(t, e) } } }), Cu = (r = e, zo = Aa = Nl, Wo = Ho = ku, Bo = Au, Go = Ma = Ga = Zs, Qo = zl, class extends r { constructor(t, e) { var s = Uo(t), e = { ...xs, ...e }, e = Wo(s, e), s = Go(s); super(t, !1, e, s ? Bo() : null), this._nativePannerNode = e, this._orientationX = zo(this, s, e.orientationX, fe, de), this._orientationY = zo(this, s, e.orientationY, fe, de), this._orientationZ = zo(this, s, e.orientationZ, fe, de), this._positionX = zo(this, s, e.positionX, fe, de), this._positionY = zo(this, s, e.positionY, fe, de), this._positionZ = zo(this, s, e.positionZ, fe, de), Qo(this, 1) } get coneInnerAngle() { return this._nativePannerNode.coneInnerAngle } set coneInnerAngle(t) { this._nativePannerNode.coneInnerAngle = t } get coneOuterAngle() { return this._nativePannerNode.coneOuterAngle } set coneOuterAngle(t) { this._nativePannerNode.coneOuterAngle = t } get coneOuterGain() { return this._nativePannerNode.coneOuterGain } set coneOuterGain(t) { this._nativePannerNode.coneOuterGain = t } get distanceModel() { return this._nativePannerNode.distanceModel } set distanceModel(t) { this._nativePannerNode.distanceModel = t } get maxDistance() { return this._nativePannerNode.maxDistance } set maxDistance(t) { this._nativePannerNode.maxDistance = t } get orientationX() { return this._orientationX } get orientationY() { return this._orientationY } get orientationZ() { return this._orientationZ } get panningModel() { return this._nativePannerNode.panningModel } set panningModel(t) { this._nativePannerNode.panningModel = t } get positionX() { return this._positionX } get positionY() { return this._positionY } get positionZ() { return this._positionZ } get refDistance() { return this._nativePannerNode.refDistance } set refDistance(t) { this._nativePannerNode.refDistance = t } get rolloffFactor() { return this._nativePannerNode.rolloffFactor } set rolloffFactor(t) { this._nativePannerNode.rolloffFactor = t } }), Ou = (Lo = le, (t, { disableNormalization: e, imag: s, real: i }) => { var n = s instanceof Float32Array ? s : new Float32Array(s), i = i instanceof Float32Array ? i : new Float32Array(i), t = t.createPeriodicWave(i, n, { disableNormalization: e }); if (Array.from(s).length < 2) throw Lo(); return t }), Du = (No = Ou, Po = Uo = Da = Qs, jo = new WeakSet, class Om { constructor(t, e) { t = Po(t), e = (t => { var { imag: e, real: s } = t; return void 0 === e ? void 0 === s ? { ...t, imag: [0, 0], real: [0, 0] } : { ...t, imag: Array.from(s, () => 0), real: s } : void 0 === s ? { ...t, imag: e, real: Array.from(e, () => 0) } : { ...t, imag: e, real: s } })({ ...ws, ...e }), t = No(t, e); return jo.add(t), t } static [Symbol.hasInstance](t) { return null !== t && "object" == typeof t && Object.getPrototypeOf(t) === Om.prototype || jo.has(t) } }), Mu = ((u, I, F, V, N, p) => { const P = 16385, j = new Float32Array([1, 1]), L = Math.PI / 2, z = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, W = { ...z, oversample: "none" }, d = (t, e, s, i, n) => { if (1 === e) { var r = t, o = s, a = i, h = n; const p = new Float32Array(P), d = new Float32Array(P); for (let t = 0; t < P; t += 1) { const o = t / 16384 * L; p[t] = Math.cos(o), d[t] = Math.sin(o) } const f = F(r, { ...z, gain: 0 }), _ = V(r, { ...W, curve: p }), m = V(r, { ...W, curve: j }), g = F(r, { ...z, gain: 0 }), v = V(r, { ...W, curve: d }); return { connectGraph() { o.connect(f), o.connect(void 0 === m.inputs ? m : m.inputs[0]), o.connect(g), m.connect(a), a.connect(void 0 === _.inputs ? _ : _.inputs[0]), a.connect(void 0 === v.inputs ? v : v.inputs[0]), _.connect(f.gain), v.connect(g.gain), f.connect(h, 0, 0), g.connect(h, 0, 1) }, disconnectGraph() { o.disconnect(f), o.disconnect(void 0 === m.inputs ? m : m.inputs[0]), o.disconnect(g), m.disconnect(a), a.disconnect(void 0 === _.inputs ? _ : _.inputs[0]), a.disconnect(void 0 === v.inputs ? v : v.inputs[0]), _.disconnect(f.gain), v.disconnect(g.gain), f.disconnect(h, 0, 0), g.disconnect(h, 0, 1) } } } if (2 !== e) throw N(); { var r = t, c = s, l = i, u = n; const y = new Float32Array(P), x = new Float32Array(P), w = new Float32Array(P), b = new Float32Array(P), T = Math.floor(8192.5); for (let t = 0; t < P; t += 1)if (t > T) { const I = (t - T) / (16384 - T) * L; y[t] = Math.cos(I), x[t] = Math.sin(I), w[t] = 0, b[t] = 1 } else { const I = t / (16384 - T) * L; y[t] = 1, x[t] = 0, w[t] = Math.cos(I), b[t] = Math.sin(I) } const S = I(r, { channelCount: 2, channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: 2 }), k = F(r, { ...z, gain: 0 }), A = V(r, { ...W, curve: y }), C = F(r, { ...z, gain: 0 }), O = V(r, { ...W, curve: x }), D = V(r, { ...W, curve: j }), M = F(r, { ...z, gain: 0 }), E = V(r, { ...W, curve: w }), R = F(r, { ...z, gain: 0 }), q = V(r, { ...W, curve: b }); return { connectGraph() { c.connect(S), c.connect(void 0 === D.inputs ? D : D.inputs[0]), S.connect(k, 0), S.connect(C, 0), S.connect(M, 1), S.connect(R, 1), D.connect(l), l.connect(void 0 === A.inputs ? A : A.inputs[0]), l.connect(void 0 === O.inputs ? O : O.inputs[0]), l.connect(void 0 === E.inputs ? E : E.inputs[0]), l.connect(void 0 === q.inputs ? q : q.inputs[0]), A.connect(k.gain), O.connect(C.gain), E.connect(M.gain), q.connect(R.gain), k.connect(u, 0, 0), M.connect(u, 0, 0), C.connect(u, 0, 1), R.connect(u, 0, 1) }, disconnectGraph() { c.disconnect(S), c.disconnect(void 0 === D.inputs ? D : D.inputs[0]), S.disconnect(k, 0), S.disconnect(C, 0), S.disconnect(M, 1), S.disconnect(R, 1), D.disconnect(l), l.disconnect(void 0 === A.inputs ? A : A.inputs[0]), l.disconnect(void 0 === O.inputs ? O : O.inputs[0]), l.disconnect(void 0 === E.inputs ? E : E.inputs[0]), l.disconnect(void 0 === q.inputs ? q : q.inputs[0]), A.disconnect(k.gain), O.disconnect(C.gain), E.disconnect(M.gain), q.disconnect(R.gain), k.disconnect(u, 0, 0), M.disconnect(u, 0, 0), C.disconnect(u, 0, 1), R.disconnect(u, 0, 1) } } } }; return (e, { channelCount: t, channelCountMode: s, pan: i, ...n }) => { if ("max" === s) throw N(); const r = u(e, { ...n, channelCount: 1, channelCountMode: s, numberOfInputs: 2 }), o = F(e, { ...n, channelCount: t, channelCountMode: s, gain: 1 }), a = F(e, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: i }); let { connectGraph: h, disconnectGraph: c } = d(e, t, o, a, r); Object.defineProperty(a.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(a.gain, "maxValue", { get: () => 1 }), Object.defineProperty(a.gain, "minValue", { get: () => -1 }); n = { get bufferSize() { }, get channelCount() { return o.channelCount }, set channelCount(t) { o.channelCount !== t && (l && c(), { connectGraph: h, disconnectGraph: c } = d(e, t, o, a, r), l && h()), o.channelCount = t }, get channelCountMode() { return o.channelCountMode }, set channelCountMode(t) { if ("clamped-max" === t || "max" === t) throw N(); o.channelCountMode = t }, get channelInterpretation() { return o.channelInterpretation }, set channelInterpretation(t) { o.channelInterpretation = t }, get context() { return o.context }, get inputs() { return [o] }, get numberOfInputs() { return o.numberOfInputs }, get numberOfOutputs() { return o.numberOfOutputs }, get pan() { return a.gain }, addEventListener: (...t) => o.addEventListener(t[0], t[1], t[2]), dispatchEvent: (...t) => o.dispatchEvent(t[0]), removeEventListener: (...t) => o.removeEventListener(t[0], t[1], t[2]) }; let l = !1; return p(ps(n, r), () => { h(), l = !0 }, () => { c(), l = !1 }) } })(Gl, us, fs, Tu, gs, Bl), Eu = (Fo = Mu, Vo = gs, (t, e) => { const s = e.channelCountMode; if ("clamped-max" === s) throw Vo(); if (void 0 === t.createStereoPanner) return Fo(t, e); t = t.createStereoPanner(); return R(t, e), i(t, e, "pan"), Object.defineProperty(t, "channelCountMode", { get: () => s, set: t => { if (t !== s) throw Vo() } }), t }), Ru = (Mo = ql, Ro = m, qo = Fl, () => { const n = new WeakMap; return { render(t, e) { var s = n.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = Ro(t); var i = u(s, e); if (!i) { const Mo = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, pan: s.pan.value }; s = Eo(e, Mo) } return n.set(e, s), i ? await Mo(e, t.pan, s.pan) : await qo(e, t.pan, s.pan), Ae(s) ? await Io(t, e, s.inputs[0]) : await Io(t, e, s), s })(t, e) } } }), qu = (n = e, ko = Nl, Ao = Eo = Eu, Co = Ru, class extends n { constructor(t, e) { var s = Oo(t), e = { ...bs, ...e }, e = Ao(s, e), s = Do(s); super(t, !1, e, s ? Co() : null), this._pan = ko(this, s, e.pan) } get pan() { return this._pan } }), Iu = (To = m, So = Io = Us, () => { const i = new WeakMap; return { render(t, e) { var s = i.get(e); return void 0 !== s ? Promise.resolve(s) : (async (t, e) => { let s = To(t); if (!u(s, e)) { const To = { channelCount: s.channelCount, channelCountMode: s.channelCountMode, channelInterpretation: s.channelInterpretation, curve: s.curve, oversample: s.oversample }; s = bo(e, To) } return i.set(e, s), Ae(s) ? await So(t, e, s.inputs[0]) : await So(t, e, s), s })(t, e) } } }), Fu = (r = e, mo = a, go = bo = Tu, vo = Iu, yo = Oo = Qs, xo = Do = Zs, wo = zl, class extends r { constructor(t, e) { var s = yo(t), e = { ...Ts, ...e }, e = go(s, e); super(t, !0, e, xo(s) ? vo() : null), this._isCurveNullified = !1, this._nativeWaveShaperNode = e, wo(this, 1) } get curve() { return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve } set curve(t) { if (null === t) this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]); else { if (t.length < 2) throw mo(); this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = t } } get oversample() { return this._nativeWaveShaperNode.oversample } set oversample(t) { this._nativeWaveShaperNode.oversample = t } }), Vu = null !== (n = zs) && n.isSecureContext, Nu = (_o = zs, (t, e, s) => { Object.defineProperties(_o, { currentFrame: { configurable: !0, get: () => Math.round(t * e) }, currentTime: { configurable: !0, get: () => t } }); try { return s() } finally { null !== _o && (delete _o.currentFrame, delete _o.currentTime) } }), Pu = new WeakMap, ju = (po = Pu, fo = t, t => { let e = po.get(t); if (void 0 !== e) return e; if (null === fo) throw new Error("Missing the native OfflineAudioContext constructor."); return e = new fo(1, 1, 44100), po.set(t, e), e }), Lu = Vu ? ((r, o, a, l, u, p, d, f, _, m, g, v, y) => {
      let x = 0; return (e, s, h = { credentials: "omit" }) => {
        const t = g.get(e); if (void 0 !== t && t.has(s)) return Promise.resolve(); const i = m.get(e); if (void 0 !== i) { const r = i.get(s); if (void 0 !== r) return r } const c = p(e), n = void 0 === c.audioWorklet ? u(s).then(([t, e]) => {
          var [t, e] = $t(t, e); return a(t + `;((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${e}
})})(window,'_AWGS')`)
        }).then(() => { const t = y._AWGS.pop(); if (void 0 === t) throw new SyntaxError; l(c.currentTime, c.sampleRate, () => t(class { }, void 0, (t, e) => { if ("" === t.trim()) throw o(); const s = Zt.get(c); if (void 0 !== s) { if (s.has(t)) throw o(); Kt(e), Jt(e.parameterDescriptors), s.set(t, e) } else Kt(e), Jt(e.parameterDescriptors), Zt.set(c, new Map([[t, e]])) }, c.sampleRate, void 0, void 0)) }) : Promise.all([u(s), Promise.resolve(r(v, v))]).then(([[t, e], s]) => { const i = x + 1, [n, r] = (x = i, $t(t, e)), o = new Blob([`${n};((AudioWorkletProcessor,registerProcessor)=>{${r}\n})(${s ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${s ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${s ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${i}',class extends AudioWorkletProcessor{process(){return !1}})`], { type: "application/javascript; charset=utf-8" }), a = URL.createObjectURL(o); return c.audioWorklet.addModule(a, h).then(() => { if (f(c)) return c; const t = d(c); return t.audioWorklet.addModule(a, h).then(() => t) }).then(t => { if (null === _) throw new SyntaxError; try { new _(t, "__sac" + i) } catch { throw new SyntaxError } }).finally(() => URL.revokeObjectURL(a)) }); return void 0 === i ? m.set(e, new Map([[s, n]])) : i.set(s, n), n.then(() => { const t = g.get(e); void 0 === t ? g.set(e, new Set([s])) : t.add(s) }).finally(() => { const t = m.get(e); void 0 !== t && t.delete(s) }), n
      }
    })(Ls, gs, (uo = zs, n => new Promise((t, r) => { if (null === uo) r(new SyntaxError); else { const e = uo.document.head; if (null === e) r(new SyntaxError); else { const s = uo.document.createElement("script"), i = new Blob([n], { type: "application/javascript" }), o = URL.createObjectURL(i), a = uo.onerror, h = () => { uo.onerror = a, URL.revokeObjectURL(o) }; uo.onerror = (t, e, s, i, n) => e === o || e === uo.location.href && 1 === s && 1 === i ? (h(), r(n), !1) : null !== a ? a(t, e, s, i, n) : void 0, s.onerror = () => { h(), r(new SyntaxError) }, s.onload = () => { h(), t() }, s.src = o, s.type = "module", e.appendChild(s) } } })), Nu, async t => { try { const e = await fetch(t); if (e.ok) return [await e.text(), e.url] } catch { } throw new DOMException("", "AbortError") }, Qs, ju, Zs, ti, new WeakMap, new WeakMap, (co = ti, lo = t, async () => { if (null === co) return !0; if (null === lo) return !1; const t = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], { type: "application/javascript; charset=utf-8" }), e = new lo(1, 128, 44100), s = URL.createObjectURL(t); let i = !1, n = !1; try { await e.audioWorklet.addModule(s); const lo = new co(e, "a", { numberOfOutputs: 0 }), t = e.createOscillator(); lo.port.onmessage = () => i = !0, lo.onprocessorerror = () => n = !0, t.connect(lo), t.start(0), await e.startRendering(), await new Promise(t => setTimeout(t)) } catch { } finally { URL.revokeObjectURL(s) } return i && !n }), zs) : void 0, zu = (ao = $s, ho = Zs, t => ao(t) || ho(t)), Wu = (Jr = Cl, Kr = Ls, to = new WeakSet, eo = Qs, so = zu, io = ce, no = rs, ro = Ol, oo = Dl, (t, r) => { const o = so(t) ? t : eo(t); if (to.has(r)) { const Jr = new DOMException("", "DataCloneError"); return Promise.reject(Jr) } try { to.add(r) } catch { } return Kr(no, () => no(o)) ? o.decodeAudioData(r).then(t => (He(r).catch(() => { }), Kr(io, () => io(t)) || oo(t), Jr.add(t), t)) : new Promise((e, s) => { const i = async () => { try { await He(r) } catch { } }, n = t => { s(t), i() }; try { o.decodeAudioData(r, t => { "function" != typeof t.copyFromChannel && (ro(t), ue(t)), Jr.add(t), i().then(() => e(t)) }, t => { n(null === t ? new DOMException("", "EncodingError") : t) }) } catch (t) { n(t) } }) }), Bu = (qr = Lu, Ir = s, Fr = Ml, Vr = Pl, Nr = Wl, Pr = Zl, jr = Yl, Lr = Kl, zr = su, Wr = Wu, Br = nu, Ur = au, Gr = cu, Qr = fu, Zr = xu, Xr = Cu, Yr = Du, Hr = qu, $r = Fu, class extends gu { constructor(t, e) { super(t, e), this._nativeContext = t, this._audioWorklet = void 0 === qr ? void 0 : { addModule: (t, e) => qr(this, t, e) } } get audioWorklet() { return this._audioWorklet } createAnalyser() { return new Ir(this) } createBiquadFilter() { return new Nr(this) } createBuffer(t, e, s) { return new Fr({ length: e, numberOfChannels: t, sampleRate: s }) } createBufferSource() { return new Vr(this) } createChannelMerger(t = 6) { return new Pr(this, { numberOfInputs: t }) } createChannelSplitter(t = 6) { return new jr(this, { numberOfOutputs: t }) } createConstantSource() { return new Lr(this) } createConvolver() { return new zr(this) } createDelay(t = 1) { return new Br(this, { maxDelayTime: t }) } createDynamicsCompressor() { return new Ur(this) } createGain() { return new Gr(this) } createIIRFilter(t, e) { return new Qr(this, { feedback: e, feedforward: t }) } createOscillator() { return new Zr(this) } createPanner() { return new Xr(this) } createPeriodicWave(t, e, s = { disableNormalization: !1 }) { return new Yr(this, { ...s, imag: e, real: t }) } createStereoPanner() { return new Hr(this) } createWaveShaper() { return new $r(this) } decodeAudioData(t, e, s) { return Wr(this._nativeContext, t).then(t => ("function" == typeof e && e(t), t), t => { throw "function" == typeof s && s(t), t }) } }), Uu = class extends e { constructor(t, e) { const s = Er(t), i = s.createMediaElementSource(e.mediaElement); if (Rr(s)) throw TypeError(); super(t, !0, i, null), this._nativeMediaElementAudioSourceNode = i } get mediaElement() { return this._nativeMediaElementAudioSourceNode.mediaElement } }, Gu = class extends e { constructor(t, e) { var s = Dr(t); if (Mr(s)) throw new TypeError; s = ((t, e) => { t = t.createMediaStreamDestination(); return R(t, e), 1 === t.numberOfOutputs && Object.defineProperty(t, "numberOfOutputs", { get: () => 0 }), t })(s, { ...ns, ...e }); super(t, !1, s, null), this._nativeMediaStreamAudioDestinationNode = s } get stream() { return this._nativeMediaStreamAudioDestinationNode.stream } }, Qu = class extends e { constructor(t, e) { var s = Cr(t), e = ((t, { mediaStream: e }) => { const s = e.getAudioTracks(); s.sort((t, e) => t.id < e.id ? -1 : t.id > e.id ? 1 : 0); var i = s.slice(0, 1), t = t.createMediaStreamSource(new MediaStream(i)); return Object.defineProperty(t, "mediaStream", { value: e }), t })(s, e); if (Or(s)) throw new TypeError; super(t, !0, e, null), this._nativeMediaStreamAudioSourceNode = e } get mediaStream() { return this._nativeMediaStreamAudioSourceNode.mediaStream } }, Zu = (kr = a, Ar = Or = Mr = Rr = Zs, (t, { mediaStreamTrack: e }) => { if ("function" == typeof t.createMediaStreamTrackSource) return t.createMediaStreamTrackSource(e); var s = new MediaStream([e]), s = t.createMediaStreamSource(s); if ("audio" !== e.kind) throw kr(); if (Ar(t)) throw new TypeError; return s }), Xu = (r = e, Tr = Zu, Sr = Cr = Dr = Er = Qs, class extends r { constructor(t, e) { var s = Sr(t); super(t, !0, Tr(s, e), null) } }), Yu = (n = Bu, _r = a, mr = gs, gr = () => new DOMException("", "UnknownError"), vr = Uu, yr = Gu, xr = Qu, wr = Xu, br = Hs, class extends n { constructor(t = {}) { if (null === br) throw new Error("Missing the native AudioContext constructor."); let e; try { e = new br(t) } catch (t) { if (12 === t.code && "sampleRate is not in range" === t.message) throw mr(); throw t } if (null === e) throw gr(); if (void 0 !== (s = t.latencyHint) && "number" != typeof s && ("string" != typeof s || "balanced" !== s && "interactive" !== s && "playback" !== s)) throw new TypeError(`The provided value '${t.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`); if (void 0 !== t.sampleRate && e.sampleRate !== t.sampleRate) throw mr(); super(e, 2); var s = t["latencyHint"], i = e["sampleRate"]; if (this._baseLatency = "number" == typeof e.baseLatency ? e.baseLatency : "balanced" === s ? 512 / i : "interactive" === s || void 0 === s ? 256 / i : "playback" === s ? 1024 / i : 128 * Math.max(2, Math.min(128, Math.round(s * i / 128))) / i, this._nativeAudioContext = e, "webkitAudioContext" === br.name ? (this._nativeGainNode = e.createGain(), this._nativeOscillatorNode = e.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(e.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, "running" === e.state) { this._state = "suspended"; const t = () => { "suspended" === this._state && (this._state = null), e.removeEventListener("statechange", t) }; e.addEventListener("statechange", t) } } get baseLatency() { return this._baseLatency } get state() { return null !== this._state ? this._state : this._nativeAudioContext.state } close() { return "closed" === this.state ? this._nativeAudioContext.close().then(() => { throw _r() }) : ("suspended" === this._state && (this._state = null), this._nativeAudioContext.close().then(() => { null !== this._nativeGainNode && null !== this._nativeOscillatorNode && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), xe(this) })) } createMediaElementSource(t) { return new vr(this, { mediaElement: t }) } createMediaStreamDestination() { return new yr(this) } createMediaStreamSource(t) { return new xr(this, { mediaStream: t }) } createMediaStreamTrackSource(t) { return new wr(this, { mediaStreamTrack: t }) } resume() { return "suspended" === this._state ? new Promise((t, e) => { const s = () => { this._nativeAudioContext.removeEventListener("statechange", s), "running" === this._nativeAudioContext.state ? t() : this.resume().then(t, e) }; this._nativeAudioContext.addEventListener("statechange", s) }) : this._nativeAudioContext.resume().catch(t => { if (void 0 === t || 15 === t.code) throw _r(); throw t }) } suspend() { return this._nativeAudioContext.suspend().catch(t => { if (void 0 === t) throw _r(); throw t }) } }), Hu = (fr = mu, t => { t = fr.get(t); if (void 0 === t) throw new Error("The context has no set of AudioWorkletNodes."); return t }), $u = (t, e) => { dr(t).add(e) }, Ju = (pr = le, (t, e, s = 0, i = 0) => { const n = t[s]; if (void 0 === n) throw pr(); return Ne(e) ? n.connect(e, 0, i) : n.connect(e, 0) }), Ku = (ur = dr = Hu, (t, e) => { ur(t).delete(e) }), tp = (lr = le, (t, e = void 0, s = void 0, i = 0) => void 0 === e ? t.forEach(t => t.disconnect()) : "number" == typeof e ? Je(lr, t, e).disconnect() : Ne(e) ? void 0 === s ? t.forEach(t => t.disconnect(e)) : void 0 === i ? Je(lr, t, s).disconnect(e, 0) : Je(lr, t, s).disconnect(e, 0, i) : void 0 === s ? t.forEach(t => t.disconnect(e)) : Je(lr, t, s).disconnect(e, 0)), ep = new WeakMap, sp = (hr = ep, cr = te, t => cr(hr, t)), ip = (Hn = le, $n = a, sr = ms, or = sp, (o, t, e, a) => { if (0 === a.numberOfInputs && 0 === a.numberOfOutputs) throw ir(); const h = Array.isArray(a.outputChannelCount) ? a.outputChannelCount : Array.from(a.outputChannelCount); if (h.some(t => t < 1)) throw ir(); if (h.length !== a.numberOfOutputs) throw Hn(); if ("explicit" !== a.channelCountMode) throw ir(); const c = a.channelCount * a.numberOfInputs, s = h.reduce((t, e) => t + e, 0), i = void 0 === e.parameterDescriptors ? 0 : e.parameterDescriptors.length; if (6 < c + i || 6 < s) throw ir(); const n = new MessageChannel, l = [], u = []; for (let t = 0; t < a.numberOfInputs; t += 1)l.push(er(o, { channelCount: a.channelCount, channelCountMode: a.channelCountMode, channelInterpretation: a.channelInterpretation, gain: 1 })), u.push(Kn(o, { channelCount: a.channelCount, channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: a.channelCount })); const p = []; if (void 0 !== e.parameterDescriptors) for (const { defaultValue: Yn, maxValue: Hn, minValue: $n, name: Jn } of e.parameterDescriptors) { const Kn = tr(o, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", offset: void 0 !== a.parameterData[Jn] ? a.parameterData[Jn] : void 0 === Yn ? 0 : Yn }); Object.defineProperties(Kn.offset, { defaultValue: { get: () => void 0 === Yn ? 0 : Yn }, maxValue: { get: () => void 0 === Hn ? fe : Hn }, minValue: { get: () => void 0 === $n ? de : $n } }), p.push(Kn) } const d = Jn(o, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: Math.max(1, c + i) }), f = cs(t, o.sampleRate), _ = sr(o, f, c + i, Math.max(1, s)), r = Kn(o, { channelCount: Math.max(1, s), channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: Math.max(1, s) }), m = []; for (let t = 0; t < a.numberOfOutputs; t += 1)m.push(Jn(o, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: h[t] })); for (let e = 0; e < a.numberOfInputs; e += 1) { l[e].connect(u[e]); for (let t = 0; t < a.channelCount; t += 1)u[e].connect(d, t, e * a.channelCount + t) } const V = new Le(void 0 === e.parameterDescriptors ? [] : e.parameterDescriptors.map(({ name: t }, e) => { const s = p[e]; return s.connect(d, 0, c + e), s.start(0), [t, s.offset] })); d.connect(_); let g = a.channelInterpretation, v = null; const y = 0 === a.numberOfOutputs ? [_] : m, x = { get bufferSize() { return f }, get channelCount() { return a.channelCount }, set channelCount(t) { throw $n() }, get channelCountMode() { return a.channelCountMode }, set channelCountMode(t) { throw $n() }, get channelInterpretation() { return g }, set channelInterpretation(t) { for (const e of l) e.channelInterpretation = t; g = t }, get context() { return _.context }, get inputs() { return l }, get numberOfInputs() { return a.numberOfInputs }, get numberOfOutputs() { return a.numberOfOutputs }, get onprocessorerror() { return v }, set onprocessorerror(t) { "function" == typeof v && x.removeEventListener("processorerror", v), "function" == typeof (v = "function" == typeof t ? t : null) && x.addEventListener("processorerror", v) }, get parameters() { return V }, get port() { return n.port2 }, addEventListener: (...t) => _.addEventListener(t[0], t[1], t[2]), connect: Yn.bind(null, y), disconnect: nr.bind(null, y), dispatchEvent: (...t) => _.dispatchEvent(t[0]), removeEventListener: (...t) => _.removeEventListener(t[0], t[1], t[2]) }, w = new Map; var b, T; n.port1.addEventListener = (b = n.port1.addEventListener, (...t) => { if ("message" === t[0]) { const s = "function" == typeof t[1] ? t[1] : "object" == typeof t[1] && null !== t[1] && "function" == typeof t[1].handleEvent ? t[1].handleEvent : null; var e; null !== s && (void 0 !== (e = w.get(t[1])) ? t[1] = e : (t[1] = t => { rr(o.currentTime, o.sampleRate, () => s(t)) }, w.set(s, t[1]))) } return b.call(n.port1, t[0], t[1], t[2]) }), n.port1.removeEventListener = (T = n.port1.removeEventListener, (...t) => { var e; return "message" === t[0] && void 0 !== (e = w.get(t[1])) && (w.delete(t[1]), t[1] = e), T.call(n.port1, t[0], t[1], t[2]) }); let S = null, k = (Object.defineProperty(n.port1, "onmessage", { get: () => S, set: t => { "function" == typeof S && n.port1.removeEventListener("message", S), "function" == typeof (S = "function" == typeof t ? t : null) && (n.port1.addEventListener("message", S), n.port1.start()) } }), e.prototype.port = n.port1, null); const N = ((t, e, s, i) => { let n = Xt.get(t); void 0 === n && (n = new WeakMap, Xt.set(t, n)); t = (async () => { var t; return t = i, new s(await new Promise((e, s) => { const { port1: i, port2: n } = new MessageChannel; i.onmessage = ({ data: t }) => { i.close(), n.close(), e(t) }, i.onmessageerror = ({ data: t }) => { i.close(), n.close(), s(t) }, n.postMessage(t) })) })(); return n.set(e, t), t })(o, x, e, a), A = (N.then(t => k = t), Ue(a.numberOfInputs, a.channelCount)), C = Ue(a.numberOfOutputs, h), O = void 0 === e.parameterDescriptors ? [] : e.parameterDescriptors.reduce((t, { name: e }) => ({ ...t, [e]: new Float32Array(128) }), {}); let D = !0; const M = () => { 0 < a.numberOfOutputs && _.disconnect(r); for (let e = 0, s = 0; e < a.numberOfOutputs; e += 1) { var i = m[e]; for (let t = 0; t < h[e]; t += 1)r.disconnect(i, s + t, t); s += h[e] } }, E = new Map; let R = !(_.onaudioprocess = ({ inputBuffer: s, outputBuffer: n }) => { if (null !== k) { const r = or(x); for (let i = 0; i < f; i += 128) { for (let e = 0; e < a.numberOfInputs; e += 1)for (let t = 0; t < a.channelCount; t += 1)We(s, A[e], t, t, i); void 0 !== e.parameterDescriptors && e.parameterDescriptors.forEach(({ name: t }, e) => { We(s, O, t, c + e, i) }); for (let e = 0; e < a.numberOfInputs; e += 1)for (let t = 0; t < h[e]; t += 1)0 === C[e][t].byteLength && (C[e][t] = new Float32Array(128)); try { const s = A.map((t, e) => { if (0 < r[e].size) return E.set(e, f / 128), t; var s = E.get(e); return void 0 === s ? [] : (t.every(t => t.every(t => 0 === t)) && (1 === s ? E.delete(e) : E.set(e, s - 1)), t) }), t = rr(o.currentTime + i / o.sampleRate, o.sampleRate, () => k.process(s, C, O)); D = t; for (let e = 0, s = 0; e < a.numberOfOutputs; e += 1) { for (let t = 0; t < h[e]; t += 1)Be(n, C[e], t, s + t, i); s += h[e] } } catch (s) { D = !1, x.dispatchEvent(new ErrorEvent("processorerror", { colno: s.colno, filename: s.filename, lineno: s.lineno, message: s.message })) } if (!D) { for (let e = 0; e < a.numberOfInputs; e += 1) { l[e].disconnect(u[e]); for (let t = 0; t < a.channelCount; t += 1)u[i].disconnect(d, t, e * a.channelCount + t) } if (void 0 !== e.parameterDescriptors) { const s = e.parameterDescriptors.length; for (let t = 0; t < s; t += 1) { const s = p[t]; s.disconnect(d, 0, c + t), s.stop() } } d.disconnect(_), _.onaudioprocess = null, (R ? M : F)(); break } } } }); const q = er(o, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: 0 }), I = () => _.connect(q).connect(o.destination), F = () => { _.disconnect(q), q.disconnect() }; return I(), ar(x, () => { if (D) { F(), 0 < a.numberOfOutputs && _.connect(r); for (let e = 0, s = 0; e < a.numberOfOutputs; e += 1) { var i = m[e]; for (let t = 0; t < h[e]; t += 1)r.connect(i, s + t, t); s += h[e] } } R = !0 }, () => { D && (I(), M()), R = !1 }) }), np = (Gn = a, c = ip, Zn = ir = gs, Xn = ar = Bl, (t, e, s, i, n, r) => { if (null !== s) try { const c = new s(t, i, r), Zn = new Map; let e = null; if (Object.defineProperties(c, { channelCount: { get: () => r.channelCount, set: () => { throw Gn() } }, channelCountMode: { get: () => "explicit", set: () => { throw Gn() } }, onprocessorerror: { get: () => e, set: t => { "function" == typeof e && c.removeEventListener("processorerror", e), "function" == typeof (e = "function" == typeof t ? t : null) && c.addEventListener("processorerror", e) } } }), c.addEventListener = (a = c.addEventListener, (...e) => { if ("processorerror" === e[0]) { const c = "function" == typeof e[1] ? e[1] : "object" == typeof e[1] && null !== e[1] && "function" == typeof e[1].handleEvent ? e[1].handleEvent : null; var t; null !== c && (void 0 !== (t = Zn.get(e[1])) ? e[1] = t : (e[1] = t => { "error" === t.type ? (Object.defineProperties(t, { type: { value: "processorerror" } }), c(t)) : c(new ErrorEvent(e[0], { ...t })) }, Zn.set(c, e[1]))) } return a.call(c, "error", e[1], e[2]), a.call(c, ...e) }), c.removeEventListener = (o = c.removeEventListener, (...t) => { if ("processorerror" === t[0]) { const c = Zn.get(t[1]); void 0 !== c && (Zn.delete(t[1]), t[1] = c) } return o.call(c, "error", t[1], t[2]), o.call(c, t[0], t[1], t[2]) }), 0 === r.numberOfOutputs) return c; { const Gn = Qn(t, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", gain: 0 }); return c.connect(Gn).connect(t.destination), Xn(c, () => Gn.disconnect(), () => Gn.connect(t.destination)) } } catch (t) { if (11 === t.code) throw Zn(); throw t } var o, a; if (void 0 === n) throw Zn(); { s = r; const h = (new MessageChannel)["port1"]; try { h.postMessage(s) } finally { h.close() } } return c(t, e, n, r) }), rp = (Dn = ql, Mn = Yn = Ju, En = Il, Rn = Jn = Gl, qn = Kn = us, In = tr = $l, Fn = Qn = er = fs, Vn = Ku, Nn = nr = tp, Pn = rr = Nu, jn = m, Ln = ti, zn = t, Wn = Fl, Bn = Us, Un = uu, (r, a, h) => { const c = new WeakMap; let l = null; return { render(t, e) { Vn(e, t); var s = c.get(e); return void 0 !== s ? Promise.resolve(s) : (async (o, e) => { let t = jn(o), s = null; const i = u(t, e), n = Array.isArray(a.outputChannelCount) ? a.outputChannelCount : Array.from(a.outputChannelCount); if (null === Ln) { const Dn = n.reduce((t, e) => t + e, 0), En = qn(e, { channelCount: Math.max(1, Dn), channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: Math.max(1, Dn) }), In = []; for (let t = 0; t < o.numberOfOutputs; t += 1)In.push(Rn(e, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: n[t] })); const Pn = Fn(e, { channelCount: a.channelCount, channelCountMode: a.channelCountMode, channelInterpretation: a.channelInterpretation, gain: 1 }); Pn.connect = Mn.bind(null, In), Pn.disconnect = Nn.bind(null, In), s = [En, In, Pn] } else i || (t = new Ln(e, r)); if (c.set(e, null === s ? t : s[2]), null !== s) { if (null === l) { if (void 0 === h) throw new Error("Missing the processor constructor."); if (null === zn) throw new Error("Missing the native OfflineAudioContext constructor."); const Dn = o.channelCount * o.numberOfInputs, Mn = void 0 === h.parameterDescriptors ? 0 : h.parameterDescriptors.length, En = Dn + Mn, Nn = async () => { const s = new zn(En, 128 * Math.ceil(o.context.length / 128), e.sampleRate), i = [], n = []; for (let t = 0; t < a.numberOfInputs; t += 1)i.push(Fn(s, { channelCount: a.channelCount, channelCountMode: a.channelCountMode, channelInterpretation: a.channelInterpretation, gain: 1 })), n.push(qn(s, { channelCount: a.channelCount, channelCountMode: "explicit", channelInterpretation: "discrete", numberOfOutputs: a.channelCount })); const t = await Promise.all(Array.from(o.parameters.values()).map(async t => { var e = In(s, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete", offset: t.value }); return await Wn(s, t, e.offset), e })), r = Rn(s, { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "speakers", numberOfInputs: Math.max(1, Dn + Mn) }); for (let e = 0; e < a.numberOfInputs; e += 1) { i[e].connect(n[e]); for (let t = 0; t < a.channelCount; t += 1)n[e].connect(r, t, e * a.channelCount + t) } for (const [Mn, En] of t.entries()) En.connect(r, 0, Dn + Mn), En.start(0); return r.connect(s.destination), await Promise.all(i.map(t => Bn(o, s, t))), Un(s) }; l = (async (t, s, e, n, r, o, a) => { const h = null === s ? 128 * Math.ceil(t.context.length / 128) : s.length, c = n.channelCount * n.numberOfInputs, i = r.reduce((t, e) => t + e, 0), l = 0 === i ? null : e.createBuffer(i, h, e.sampleRate); if (void 0 === o) throw new Error("Missing the processor constructor."); const u = ge(t), p = await ((t, e) => { t = te(Xt, t), e = m(e); return te(t, e) })(e, t), d = Ue(n.numberOfInputs, n.channelCount), f = Ue(n.numberOfOutputs, r), _ = Array.from(t.parameters.keys()).reduce((t, e) => ({ ...t, [e]: new Float32Array(128) }), {}); for (let i = 0; i < h; i += 128) { if (0 < n.numberOfInputs && null !== s) for (let e = 0; e < n.numberOfInputs; e += 1)for (let t = 0; t < n.channelCount; t += 1)We(s, d[e], t, t, i); void 0 !== o.parameterDescriptors && null !== s && o.parameterDescriptors.forEach(({ name: t }, e) => { We(s, _, t, c + e, i) }); for (let e = 0; e < n.numberOfInputs; e += 1)for (let t = 0; t < r[e]; t += 1)0 === f[e][t].byteLength && (f[e][t] = new Float32Array(128)); try { const t = d.map((t, e) => 0 === u.activeInputs[e].size ? [] : t), s = a(i / e.sampleRate, e.sampleRate, () => p.process(t, f, _)); if (null !== l) for (let e = 0, s = 0; e < n.numberOfOutputs; e += 1) { for (let t = 0; t < r[e]; t += 1)Be(l, f[e], t, s + t, i); s += r[e] } if (!s) break } catch (s) { t.dispatchEvent(new ErrorEvent("processorerror", { colno: s.colno, filename: s.filename, lineno: s.lineno, message: s.message })); break } } return l })(o, 0 === En ? null : await Nn(), e, a, n, h, Pn) } const Dn = await l, Mn = En(e, { buffer: null, channelCount: 2, channelCountMode: "max", channelInterpretation: "speakers", loop: !1, loopEnd: 0, loopStart: 0, playbackRate: 1 }), [Nn, jn, Ln] = s; null !== Dn && (Mn.buffer = Dn, Mn.start(0)), Mn.connect(Nn); for (let e = 0, s = 0; e < o.numberOfOutputs; e += 1) { const En = jn[e]; for (let t = 0; t < n[e]; t += 1)Nn.connect(En, s + t, t); s += n[e] } return Ln } if (i) for (const [Mn, En] of o.parameters.entries()) await Dn(e, En, t.parameters.get(Mn)); else for (const [Dn, Mn] of o.parameters.entries()) await Wn(e, Mn, t.parameters.get(Dn)); return await Bn(o, e, t), t })(t, e) } } }), op = (On = Pu, t => On.get(t)), ap = (Cn = ep, (t, e) => { Cn.set(t, e) }), hp = Vu ? (mn = $u, gn = Nl, vn = rp, yn = np, xn = ge, wn = op, bn = Qs, Tn = Zs, Sn = ti, kn = ap, An = Is, class extends e { constructor(t, e, s) { const i = bn(t), n = Tn(i), r = { ...s = { ...ze, ...s }, outputChannelCount: void 0 !== s.outputChannelCount ? s.outputChannelCount : 1 === s.numberOfInputs && 1 === s.numberOfOutputs ? [s.channelCount] : Array.from({ length: s.numberOfOutputs }, () => 1) }; { var s = r; const { port1: u, port2: p } = new MessageChannel; try { u.postMessage(s) } finally { u.close(), p.close() } } const o = Zt.get(i), a = null == o ? void 0 : o.get(e), h = !n && "closed" === i.state && null != (s = wn(i)) ? s : i, c = yn(h, n ? null : t.baseLatency, Sn, e, a, r), l = (super(t, !0, c, n ? vn(e, r, a) : null), []); c.parameters.forEach((t, e) => { t = gn(this, n, t); l.push([e, t]) }), this._nativeAudioWorkletNode = c, this._onprocessorerror = null, this._parameters = new Le(l), n && mn(i, this); s = xn(this).activeInputs; kn(c, s) } get onprocessorerror() { return this._onprocessorerror } set onprocessorerror(t) { var e = "function" == typeof t ? An(this, t) : null, s = (this._nativeAudioWorkletNode.onprocessorerror = e, this._nativeAudioWorkletNode.onprocessorerror); this._onprocessorerror = null !== s && s === e ? t : s } get parameters() { return null === this._parameters ? this._nativeAudioWorkletNode.parameters : this._parameters } get port() { return this._nativeAudioWorkletNode.port } }) : void 0, cp = (fn = gs, _n = t, (t, e, s) => { if (null === _n) throw new Error("Missing the native OfflineAudioContext constructor."); try { return new _n(t, e, s) } catch (t) { if ("SyntaxError" === t.name) throw fn(); throw t } }), lp = (on = Cl, an = Ls, hn = Bs, cn = Hu, ln = uu, un = ce, pn = Ol, dn = Dl, (t, e) => hn(t).render(t, e).then(() => Promise.all(Array.from(cn(e)).map(t => hn(t).render(t, e)))).then(() => ln(e)).then(t => ("function" != typeof t.copyFromChannel ? (pn(t), ue(t)) : an(un, () => un(t)) || dn(t), on.add(t), t))), up = (en = Ls, sn = a, nn = cp, rn = lp, class extends Bu { constructor(t, e, s) { let i; if ("number" == typeof t && void 0 !== e && void 0 !== s) i = { length: e, numberOfChannels: t, sampleRate: s }; else { if ("object" != typeof t) throw new Error("The given parameters are not valid."); i = t } const { length: n, numberOfChannels: r, sampleRate: o } = { ...vs, ...i }, a = nn(r, n, o); en(rs, () => rs(a)) || a.addEventListener("statechange", (() => { let e = 0; const s = t => { "running" === this._state && (0 < e ? (a.removeEventListener("statechange", s), t.stopImmediatePropagation(), this._waitForThePromiseToSettle(t)) : e += 1) }; return s })()), super(a, r), this._length = n, this._nativeOfflineAudioContext = a, this._state = null } get length() { return void 0 === this._nativeOfflineAudioContext.length ? this._length : this._nativeOfflineAudioContext.length } get state() { return null === this._state ? this._nativeOfflineAudioContext.state : this._state } startRendering() { return "running" === this._state ? Promise.reject(sn()) : (this._state = "running", rn(this.destination, this._nativeOfflineAudioContext).finally(() => { this._state = null, xe(this) })) } _waitForThePromiseToSettle(t) { null === this._state ? this._nativeOfflineAudioContext.dispatchEvent(t) : setTimeout(() => this._waitForThePromiseToSettle(t)) } }), pp = (Ki = Ut, tn = $s, t => { var e = Ki.get(t); return tn(e) || tn(t) }), dp = ($i = zt, Ji = Js, t => $i.has(t) || Ji(t)), fp = (Yi = Bt, Hi = Ks, t => Yi.has(t) || Hi(t)), _p = (Zi = Ut, Xi = Zs, t => { var e = Zi.get(t); return Xi(e) || Xi(t) }), mp = () => (async (t, e, s, i, n, r, o, a, h, c, l, u, p, d, f, _) => !!(t(e, e) && t(s, s) && t(n, n) && t(r, r) && t(a, a) && t(h, h) && t(c, c) && t(l, l) && t(u, u) && t(p, p) && t(d, d)) && (await Promise.all([t(i, i), t(o, o), t(f, f), t(_, _)])).every(t => t))(Ls, (s => () => { if (null === s) return !1; const t = new s(1, 1, 44100).createBuffer(1, 1, 44100); if (void 0 === t.copyToChannel) return !0; var e = new Float32Array(2); try { t.copyFromChannel(e, 0, 0) } catch { return !1 } return !0 })(t), (s => () => { if (null === s) return !1; if (void 0 !== s.prototype && void 0 !== s.prototype.close) return !0; const t = new s, e = void 0 !== t.close; try { t.close() } catch { } return e })(Hs), (t => () => { if (null === t) return Promise.resolve(!1); const n = new t(1, 1, 44100); return new Promise(e => { let s = !0; var t = t => { s && (s = !1, n.startRendering(), e(t instanceof TypeError)) }; let i; try { i = n.decodeAudioData(null, () => { }, t) } catch (e) { t(e) } void 0 !== i && i.catch(t) }) })(t), (e => () => { if (null === e) return !1; let t; try { t = new e({ latencyHint: "balanced" }) } catch { return !1 } return t.close(), !0 })(Hs), (s => () => { if (null === s) return !1; const t = new s(1, 1, 44100).createGain(), e = t.connect(t) === t; return t.disconnect(t), e })(t), ((r, o) => async () => { if (null === r) return !0; if (null === o) return !1; const t = new Blob(['let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor("a",A)'], { type: "application/javascript; charset=utf-8" }), s = new MessageChannel, e = new o(1, 128, 44100), i = URL.createObjectURL(t); let n = !1; try { await e.audioWorklet.addModule(i); const o = new r(e, "a", { numberOfOutputs: 0 }), t = e.createOscillator(); await new Promise(t => { o.port.onmessage = () => t(), o.port.postMessage(s.port2, [s.port2]) }), o.port.onmessage = () => n = !0, t.connect(o), t.start(0), await e.startRendering(), n = await new Promise(e => { s.port1.onmessage = ({ data: t }) => e(1 === t), s.port1.postMessage(0) }) } catch { } finally { s.port1.close(), URL.revokeObjectURL(i) } return n })(ti, t), (e => () => { if (null === e) return !1; const t = new e(1, 1, 44100).createChannelMerger(); if ("max" === t.channelCountMode) return !0; try { t.channelCount = 2 } catch { return !0 } return !1 })(t), (e => () => { if (null === e) return !1; const t = new e(1, 1, 44100); return void 0 === t.createConstantSource || t.createConstantSource().offset.maxValue !== Number.POSITIVE_INFINITY })(t), (s => () => { if (null === s) return !1; const t = new s(1, 1, 44100), e = t.createConvolver(); e.buffer = t.createBuffer(1, 1, t.sampleRate); try { e.buffer = t.createBuffer(1, 1, t.sampleRate) } catch { return !1 } return !0 })(t), (e => () => { if (null === e) return !1; const t = new e(1, 1, 44100).createConvolver(); try { t.channelCount = 1 } catch { return !1 } return !0 })(t), Es, (t => () => null !== t && t.hasOwnProperty("isSecureContext"))(zs), (e => () => { if (null === e) return !1; const t = new e; try { return t.createMediaStreamSource(new MediaStream), !1 } catch (t) { return !0 } finally { t.close() } })(Hs), (i => () => { if (null === i) return Promise.resolve(!1); const t = new i(1, 1, 44100); if (void 0 === t.createStereoPanner) return Promise.resolve(!0); if (void 0 === t.createConstantSource) return Promise.resolve(!0); const e = t.createConstantSource(), s = t.createStereoPanner(); return e.channelCount = 1, e.offset.value = 1, s.channelCount = 1, e.start(), e.connect(s).connect(t.destination), t.startRendering().then(t => 1 !== t.getChannelData(0)[0]) })(t), Rs); function gp(t) { return void 0 === t } function o(t) { return void 0 !== t } function vp(t) { return "function" == typeof t } function yp(t) { return "number" == typeof t } function xp(t) { return "[object Object]" === Object.prototype.toString.call(t) && t.constructor === Object } function wp(t) { return "boolean" == typeof t } function d(t) { return Array.isArray(t) } function bp(t) { return "string" == typeof t } function Tp(t) { return bp(t) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t) } function l(t, e) { if (!t) throw new Error(e) } function f(t, e, s = 1 / 0) { if (!(e <= t && t <= s)) throw new RangeError(`Value must be within [${e}, ${s}], got: ` + t) } function Sp(t) { t.isOffline || "running" === t.state || Ep('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.') } let kp = !1, Ap = !1; function Cp(t) { kp = t } function Op(t) { gp(t) && kp && !Ap && (Ap = !0, Ep("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing")) } let Dp = console; function Mp(...t) { Dp.log(...t) } function Ep(...t) { Dp.warn(...t) } const Rp = "object" == typeof self ? self : null, qp = Rp && (Rp.hasOwnProperty("AudioContext") || Rp.hasOwnProperty("webkitAudioContext")); function Ip(t, e, s, i) { var n, r = arguments.length, o = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, s) : i; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, s, i); else for (var a = t.length - 1; 0 <= a; a--)(n = t[a]) && (o = (r < 3 ? n(o) : 3 < r ? n(e, s, o) : n(e, s)) || o); 3 < r && o && Object.defineProperty(e, s, o) } function _(t, o, a, h) { return new (a = a || Promise)(function (s, e) { function i(t) { try { r(h.next(t)) } catch (t) { e(t) } } function n(t) { try { r(h.throw(t)) } catch (t) { e(t) } } function r(t) { var e; t.done ? s(t.value) : ((e = t.value) instanceof a ? e : new a(function (t) { t(e) })).then(i, n) } r((h = h.apply(t, o || [])).next()) }) } Object.create, Object.create; class Fp {
      constructor(t, e, s, i) { this._callback = t, this._type = e, this._minimumUpdateInterval = Math.max(128 / (i || 44100), .001), this.updateInterval = s, this._createClock() } _createWorker() {
        const t = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(1e3 * this._updateInterval).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`], { type: "text/javascript" }), e = URL.createObjectURL(t), s = new Worker(e); s.onmessage = this._callback.bind(this), this._worker = s
      } _createTimeout() { this._timeout = setTimeout(() => { this._createTimeout(), this._callback() }, 1e3 * this._updateInterval) } _createClock() { if ("worker" === this._type) try { this._createWorker() } catch (t) { this._type = "timeout", this._createClock() } else "timeout" === this._type && this._createTimeout() } _disposeClock() { this._timeout && clearTimeout(this._timeout), this._worker && (this._worker.terminate(), this._worker.onmessage = null) } get updateInterval() { return this._updateInterval } set updateInterval(t) { this._updateInterval = Math.max(t, this._minimumUpdateInterval), "worker" === this._type && null != (t = this._worker) && t.postMessage(1e3 * this._updateInterval) } get type() { return this._type } set type(t) { this._disposeClock(), this._type = t, this._createClock() } dispose() { this._disposeClock() }
    } function Vp(t) { return fp(t) } function Np(t) { return dp(t) } function Pp(t) { return _p(t) } function jp(t) { return pp(t) } function Lp(t, ...e) { if (!e.length) return t; var s, i, n = e.shift(); if (xp(t) && xp(n)) for (const e in n) s = e, i = n[e], "value" === s || Vp(i) || Np(i) || i instanceof Ml ? t[e] = n[e] : xp(n[e]) ? (t[e] || Object.assign(t, { [e]: {} }), Lp(t[e], n[e])) : Object.assign(t, { [e]: n[e] }); return Lp(t, ...e) } function g(e, t, s = [], i) { const n = {}, r = Array.from(t); if (!xp(r[0]) || !i || Reflect.has(r[0], i) || Object.keys(r[0]).some(t => Reflect.has(e, t)) || (Lp(n, { [i]: r[0] }), s.splice(s.indexOf(i), 1), r.shift()), 1 === r.length && xp(r[0])) Lp(n, r[0]); else for (let t = 0; t < s.length; t++)o(r[t]) && (n[s[t]] = r[t]); return Lp(e, n) } function zp(t, e) { return gp(t) ? e : t } function v(e, t) { return t.forEach(t => { Reflect.has(e, t) && delete e[t] }), e } class Wp { constructor() { this.debug = !1, this._wasDisposed = !1 } static getDefaults() { return {} } log(...t) { (this.debug || Rp && this.toString() === Rp.TONE_DEBUG_CLASS) && Mp(this, ...t) } dispose() { return this._wasDisposed = !0, this } get disposed() { return this._wasDisposed } toString() { return this.name } } Wp.version = P; const Bp = 1e-6; function Up(t, e) { return t > e + Bp } function Gp(t, e) { return Up(t, e) || Zp(t, e) } function Qp(t, e) { return t + Bp < e } function Zp(t, e) { return Math.abs(t - e) < Bp } function Xp(t, e, s) { return Math.max(Math.min(t, s), e) } class Yp extends Wp { constructor() { super(), this.name = "Timeline", this._timeline = []; var t = g(Yp.getDefaults(), arguments, ["memory"]); this.memory = t.memory, this.increasing = t.increasing } static getDefaults() { return { memory: 1 / 0, increasing: !1 } } get length() { return this._timeline.length } add(t) { var e; if (l(Reflect.has(t, "time"), "Timeline: events must have a time attribute"), t.time = t.time.valueOf(), this.increasing && this.length ? (e = this._timeline[this.length - 1], l(Gp(t.time, e.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(t)) : (e = this._search(t.time), this._timeline.splice(e + 1, 0, t)), this.length > this.memory) { const t = this.length - this.memory; this._timeline.splice(0, t) } return this } remove(t) { t = this._timeline.indexOf(t); return -1 !== t && this._timeline.splice(t, 1), this } get(t, e = "time") { t = this._search(t, e); return -1 !== t ? this._timeline[t] : null } peek() { return this._timeline[0] } shift() { return this._timeline.shift() } getAfter(t, e = "time") { t = this._search(t, e); return t + 1 < this._timeline.length ? this._timeline[t + 1] : null } getBefore(t) { var e = this._timeline.length; if (0 < e && this._timeline[e - 1].time < t) return this._timeline[e - 1]; e = this._search(t); return 0 <= e - 1 ? this._timeline[e - 1] : null } cancel(s) { if (1 < this._timeline.length) { let e = this._search(s); if (0 <= e) if (Zp(this._timeline[e].time, s)) { for (let t = e; 0 <= t && Zp(this._timeline[t].time, s); t--)e = t; this._timeline = this._timeline.slice(0, e) } else this._timeline = this._timeline.slice(0, e + 1); else this._timeline = [] } else 1 === this._timeline.length && Gp(this._timeline[0].time, s) && (this._timeline = []); return this } cancelBefore(t) { t = this._search(t); return 0 <= t && (this._timeline = this._timeline.slice(t + 1)), this } previousEvent(t) { t = this._timeline.indexOf(t); return 0 < t ? this._timeline[t - 1] : null } _search(s, i = "time") { if (0 === this._timeline.length) return -1; let t = 0; var e = this._timeline.length; let n = e; if (0 < e && this._timeline[e - 1][i] <= s) return e - 1; for (; t < n;) { let e = Math.floor(t + (n - t) / 2); var r = this._timeline[e], o = this._timeline[e + 1]; if (Zp(r[i], s)) { for (let t = e; t < this._timeline.length && Zp(this._timeline[t][i], s); t++)e = t; return e } if (Qp(r[i], s) && Up(o[i], s)) return e; Up(r[i], s) ? n = e : t = e + 1 } return -1 } _iterate(t, e = 0, s = this._timeline.length - 1) { this._timeline.slice(e, s + 1).forEach(t) } forEach(t) { return this._iterate(t), this } forEachBefore(t, e) { t = this._search(t); return -1 !== t && this._iterate(e, 0, t), this } forEachAfter(t, e) { t = this._search(t); return this._iterate(e, t + 1), this } forEachBetween(t, e, s) { let i = this._search(t), n = this._search(e); return -1 !== i && -1 !== n ? (this._timeline[i].time !== t && (i += 1), this._timeline[n].time === e && --n, this._iterate(s, i, n)) : -1 === i && this._iterate(s, 0, n), this } forEachFrom(t, e) { let s = this._search(t); for (; 0 <= s && this._timeline[s].time >= t;)s--; return this._iterate(e, s + 1), this } forEachAtTime(s, i) { var n = this._search(s); if (-1 !== n && Zp(this._timeline[n].time, s)) { let e = n; for (let t = n; 0 <= t && Zp(this._timeline[t].time, s); t--)e = t; this._iterate(t => { i(t) }, e, n) } return this } dispose() { return super.dispose(), this._timeline = [], this } } const Hp = []; function $p(t) { Hp.push(t) } const Jp = []; function Kp(t) { Jp.push(t) } class td extends Wp { constructor() { super(...arguments), this.name = "Emitter" } on(t, e) { return t.split(/\W+/).forEach(t => { gp(this._events) && (this._events = {}), this._events.hasOwnProperty(t) || (this._events[t] = []), this._events[t].push(e) }), this } once(e, s) { const i = (...t) => { s(...t), this.off(e, i) }; return this.on(e, i), this } off(t, s) { return t.split(/\W+/).forEach(t => { if (gp(this._events) && (this._events = {}), this._events.hasOwnProperty(t)) if (gp(s)) this._events[t] = []; else { const e = this._events[t]; for (let t = e.length - 1; 0 <= t; t--)e[t] === s && e.splice(t, 1) } }), this } emit(t, ...s) { if (this._events && this._events.hasOwnProperty(t)) { const i = this._events[t].slice(0); for (let t = 0, e = i.length; t < e; t++)i[t].apply(this, s) } return this } static mixin(s) { ["on", "once", "off", "emit"].forEach(t => { var e = Object.getOwnPropertyDescriptor(td.prototype, t); Object.defineProperty(s.prototype, t, e) }) } dispose() { return super.dispose(), this._events = void 0, this } } class ed extends td { constructor() { super(...arguments), this.isOffline = !1 } toJSON() { return {} } } class sd extends ed { constructor() { super(), this.name = "Context", this._constants = new Map, this._timeouts = new Yp, this._timeoutIds = 0, this._initialized = !1, this._closeStarted = !1, this.isOffline = !1, this._workletPromise = null; var t, e, s = g(sd.getDefaults(), arguments, ["context"]); s.context ? (this._context = s.context, this._latencyHint = (null == (e = arguments[0]) ? void 0 : e.latencyHint) || "") : (this._context = (e = { latencyHint: s.latencyHint }, new Yu(e)), this._latencyHint = s.latencyHint), this._ticker = new Fp(this.emit.bind(this, "tick"), s.clockSource, s.updateInterval, this._context.sampleRate), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => { this.emit("statechange", this.state) }, this[null != (t = arguments[0]) && t.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = s.lookAhead } static getDefaults() { return { clockSource: "worker", latencyHint: "interactive", lookAhead: .1, updateInterval: .05 } } initialize() { var e; return this._initialized || (e = this, Hp.forEach(t => t(e)), this._initialized = !0), this } createAnalyser() { return this._context.createAnalyser() } createOscillator() { return this._context.createOscillator() } createBufferSource() { return this._context.createBufferSource() } createBiquadFilter() { return this._context.createBiquadFilter() } createBuffer(t, e, s) { return this._context.createBuffer(t, e, s) } createChannelMerger(t) { return this._context.createChannelMerger(t) } createChannelSplitter(t) { return this._context.createChannelSplitter(t) } createConstantSource() { return this._context.createConstantSource() } createConvolver() { return this._context.createConvolver() } createDelay(t) { return this._context.createDelay(t) } createDynamicsCompressor() { return this._context.createDynamicsCompressor() } createGain() { return this._context.createGain() } createIIRFilter(t, e) { return this._context.createIIRFilter(t, e) } createPanner() { return this._context.createPanner() } createPeriodicWave(t, e, s) { return this._context.createPeriodicWave(t, e, s) } createStereoPanner() { return this._context.createStereoPanner() } createWaveShaper() { return this._context.createWaveShaper() } createMediaStreamSource(t) { return l(jp(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(t) } createMediaElementSource(t) { return l(jp(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(t) } createMediaStreamDestination() { return l(jp(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination() } decodeAudioData(t) { return this._context.decodeAudioData(t) } get currentTime() { return this._context.currentTime } get state() { return this._context.state } get sampleRate() { return this._context.sampleRate } get listener() { return this.initialize(), this._listener } set listener(t) { l(!this._initialized, "The listener cannot be set after initialization."), this._listener = t } get transport() { return this.initialize(), this._transport } set transport(t) { l(!this._initialized, "The transport cannot be set after initialization."), this._transport = t } get draw() { return this.initialize(), this._draw } set draw(t) { l(!this._initialized, "Draw cannot be set after initialization."), this._draw = t } get destination() { return this.initialize(), this._destination } set destination(t) { l(!this._initialized, "The destination cannot be set after initialization."), this._destination = t } createAudioWorkletNode(t, e) { return s = this.rawContext, t = t, e = e, l(o(hp), "AudioWorkletNode only works in a secure context (https or localhost)"), new (s instanceof (null == Rp ? void 0 : Rp.BaseAudioContext) ? null == Rp ? void 0 : Rp.AudioWorkletNode : hp)(s, t, e); var s } addAudioWorkletModule(t) { return _(this, void 0, void 0, function* () { l(o(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)), yield this._workletPromise }) } workletsAreReady() { return _(this, void 0, void 0, function* () { (yield this._workletPromise) ? this._workletPromise : Promise.resolve() }) } get updateInterval() { return this._ticker.updateInterval } set updateInterval(t) { this._ticker.updateInterval = t } get clockSource() { return this._ticker.type } set clockSource(t) { this._ticker.type = t } get lookAhead() { return this._lookAhead } set lookAhead(t) { this._lookAhead = t, this.updateInterval = t ? t / 2 : .01 } get latencyHint() { return this._latencyHint } get rawContext() { return this._context } now() { return this._context.currentTime + this._lookAhead } immediate() { return this._context.currentTime } resume() { return jp(this._context) ? this._context.resume() : Promise.resolve() } close() { return _(this, void 0, void 0, function* () { var e; jp(this._context) && "closed" !== this.state && !this._closeStarted && (this._closeStarted = !0, yield this._context.close()), this._initialized && (e = this, Jp.forEach(t => t(e))) }) } getConstant(e) { if (this._constants.has(e)) return this._constants.get(e); { const t = this._context.createBuffer(1, 128, this._context.sampleRate), s = t.getChannelData(0); for (let t = 0; t < s.length; t++)s[t] = e; const i = this._context.createBufferSource(); return i.channelCount = 1, i.channelCountMode = "explicit", i.buffer = t, i.loop = !0, i.start(0), this._constants.set(e, i), i } } dispose() { return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map(t => this._constants[t].disconnect()), this.close(), this } _timeoutLoop() { var t = this.now(); let e = this._timeouts.peek(); for (; this._timeouts.length && e && e.time <= t;)e.callback(), this._timeouts.shift(), e = this._timeouts.peek() } setTimeout(t, e) { this._timeoutIds++; var s = this.now(); return this._timeouts.add({ callback: t, id: this._timeoutIds, time: s + e }), this._timeoutIds } clearTimeout(e) { return this._timeouts.forEach(t => { t.id === e && this._timeouts.remove(t) }), this } clearInterval(t) { return this.clearTimeout(t) } setInterval(e, s) { const i = ++this._timeoutIds, n = () => { var t = this.now(); this._timeouts.add({ callback: () => { e(), n() }, id: i, time: t + s }) }; return n(), i } } function y(e, t) { d(t) ? t.forEach(t => y(e, t)) : Object.defineProperty(e, t, { enumerable: !0, writable: !1 }) } function id(e, t) { d(t) ? t.forEach(t => id(e, t)) : Object.defineProperty(e, t, { writable: !0 }) } const x = () => { }; class w extends Wp { constructor() { super(), this.name = "ToneAudioBuffer", this.onload = x; var t = g(w.getDefaults(), arguments, ["url", "onload", "onerror"]); this.reverse = t.reverse, this.onload = t.onload, bp(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url) } static getDefaults() { return { onerror: x, onload: x, reverse: !1 } } get sampleRate() { return (this._buffer || b()).sampleRate } set(t) { return t instanceof w ? t.loaded ? this._buffer = t.get() : t.onload = () => { this.set(t), this.onload(this) } : this._buffer = t, this._reversed && this._reverse(), this } get() { return this._buffer } load(e) { return _(this, void 0, void 0, function* () { var t = w.load(e).then(t => { this.set(t), this.onload(this) }); w.downloads.push(t); try { yield t } finally { const e = w.downloads.indexOf(t); w.downloads.splice(e, 1) } return this }) } dispose() { return super.dispose(), this._buffer = void 0, this } fromArray(t) { const e = d(t) && 0 < t[0].length, s = e ? t.length : 1, i = (e ? t[0] : t).length, n = b(), r = n.createBuffer(s, i, n.sampleRate), o = e || 1 !== s ? t : [t]; for (let t = 0; t < s; t++)r.copyToChannel(o[t], t); return this._buffer = r, this } toMono(t) { if (yp(t)) this.fromArray(this.toArray(t)); else { let e = new Float32Array(this.length); const i = this.numberOfChannels; for (let t = 0; t < i; t++) { var s = this.toArray(t); for (let t = 0; t < s.length; t++)e[t] += s[t] } e = e.map(t => t / i), this.fromArray(e) } return this } toArray(e) { if (yp(e)) return this.getChannelData(e); if (1 === this.numberOfChannels) return this.toArray(0); { const e = []; for (let t = 0; t < this.numberOfChannels; t++)e[t] = this.getChannelData(t); return e } } getChannelData(t) { return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0) } slice(t, e = this.duration) { l(this.loaded, "Buffer is not loaded"); var s = Math.floor(t * this.sampleRate), i = Math.floor(e * this.sampleRate); l(s < i, "The start time must be less than the end time"); const n = i - s, r = b().createBuffer(this.numberOfChannels, n, this.sampleRate); for (let t = 0; t < this.numberOfChannels; t++)r.copyToChannel(this.getChannelData(t).subarray(s, i), t); return new w(r) } _reverse() { if (this.loaded) for (let t = 0; t < this.numberOfChannels; t++)this.getChannelData(t).reverse(); return this } get loaded() { return 0 < this.length } get duration() { return this._buffer ? this._buffer.duration : 0 } get length() { return this._buffer ? this._buffer.length : 0 } get numberOfChannels() { return this._buffer ? this._buffer.numberOfChannels : 0 } get reverse() { return this._reversed } set reverse(t) { this._reversed !== t && (this._reversed = t, this._reverse()) } static fromArray(t) { return (new w).fromArray(t) } static fromUrl(e) { return _(this, void 0, void 0, function* () { const t = new w; return yield t.load(e) }) } static load(i) { return _(this, void 0, void 0, function* () { const t = "" === w.baseUrl || w.baseUrl.endsWith("/") ? w.baseUrl : w.baseUrl + "/", e = yield fetch(t + i); if (!e.ok) throw new Error("could not load url: " + i); var s = yield e.arrayBuffer(); return yield b().decodeAudioData(s) }) } static supportsType(t) { t = t.split("."), t = t[t.length - 1]; return "" !== document.createElement("audio").canPlayType("audio/" + t) } static loaded() { return _(this, void 0, void 0, function* () { for (yield Promise.resolve(); w.downloads.length;)yield w.downloads[0] }) } } w.baseUrl = "", w.downloads = []; class nd extends sd { constructor() { var t, e, s; super({ clockSource: "offline", context: Pp(arguments[0]) ? arguments[0] : (t = arguments[0], e = arguments[1] * arguments[2], s = arguments[2], new up(t, e, s)), lookAhead: 0, updateInterval: Pp(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2] }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = Pp(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1] } now() { return this._currentTime } get currentTime() { return this._currentTime } _renderClock(s) { return _(this, void 0, void 0, function* () { let t = 0; for (; 0 <= this._duration - this._currentTime;) { this.emit("tick"), this._currentTime += 128 / this.sampleRate, t++; var e = Math.floor(this.sampleRate / 128); s && t % e == 0 && (yield new Promise(t => setTimeout(t, 1))) } }) } render() { return _(this, arguments, void 0, function* (t = !0) { yield this.workletsAreReady(), yield this._renderClock(t); t = yield this._context.startRendering(); return new w(t) }) } close() { return Promise.resolve() } } const rd = new class extends ed { constructor() { super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1 } createAnalyser() { return {} } createOscillator() { return {} } createBufferSource() { return {} } createBiquadFilter() { return {} } createBuffer(t, e, s) { return {} } createChannelMerger(t) { return {} } createChannelSplitter(t) { return {} } createConstantSource() { return {} } createConvolver() { return {} } createDelay(t) { return {} } createDynamicsCompressor() { return {} } createGain() { return {} } createIIRFilter(t, e) { return {} } createPanner() { return {} } createPeriodicWave(t, e, s) { return {} } createStereoPanner() { return {} } createWaveShaper() { return {} } createMediaStreamSource(t) { return {} } createMediaElementSource(t) { return {} } createMediaStreamDestination() { return {} } decodeAudioData(t) { return Promise.resolve({}) } createAudioWorkletNode(t, e) { return {} } get rawContext() { return {} } addAudioWorkletModule(t) { return _(this, void 0, void 0, function* () { return Promise.resolve() }) } resume() { return Promise.resolve() } setTimeout(t, e) { return 0 } clearTimeout(t) { return this } setInterval(t, e) { return 0 } clearInterval(t) { return this } getConstant(t) { return {} } get currentTime() { return 0 } get state() { return {} } get sampleRate() { return 0 } get listener() { return {} } get transport() { return {} } get draw() { return {} } set draw(t) { } get destination() { return {} } set destination(t) { } now() { return 0 } immediate() { return 0 } }; let od = rd; function b() { return od === rd && qp && ad(new sd), od } function ad(t, e = !1) { e && od.dispose(), od = jp(t) ? new sd(t) : Pp(t) ? new nd(t) : t } if (Rp && !Rp.TONE_SILENCE_LOGGING) { let t = "v"; const N = ` * Tone.js ${t = "dev" === P ? "" : t}${P} * `; console.log("%c" + N, "background: #000; color: #fff") } function hd(t) { return Math.pow(10, t / 20) } function cd(t) { return Math.log(t) / Math.LN10 * 20 } function ld(t) { return Math.pow(2, t / 12) } let ud = 440; function pd(t) { return Math.round(dd(t)) } function dd(t) { return 69 + 12 * Math.log2(t / ud) } function fd(t) { return ud * Math.pow(2, (t - 69) / 12) } class _d extends Wp { constructor(t, e, s) { super(), this.defaultUnits = "s", this._val = e, this._units = s, this.context = t, this._expressions = this._getExpressions() } _getExpressions() { return { hz: { method: t => this._frequencyToUnits(parseFloat(t)), regexp: /^(\d+(?:\.\d+)?)hz$/i }, i: { method: t => this._ticksToUnits(parseInt(t, 10)), regexp: /^(\d+)i$/i }, m: { method: t => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()), regexp: /^(\d+)m$/i }, n: { method: (t, e) => { t = parseInt(t, 10), e = "." === e ? 1.5 : 1; return 1 === t ? this._beatsToUnits(this._getTimeSignature()) * e : this._beatsToUnits(4 / t) * e }, regexp: /^(\d+)n(\.?)$/i }, number: { method: t => this._expressions[this.defaultUnits].method.call(this, t), regexp: /^(\d+(?:\.\d+)?)$/ }, s: { method: t => this._secondsToUnits(parseFloat(t)), regexp: /^(\d+(?:\.\d+)?)s$/ }, samples: { method: t => parseInt(t, 10) / this.context.sampleRate, regexp: /^(\d+)samples$/ }, t: { method: t => { t = parseInt(t, 10); return this._beatsToUnits(8 / (3 * Math.floor(t))) }, regexp: /^(\d+)t$/i }, tr: { method: (t, e, s) => { let i = 0; return t && "0" !== t && (i += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), e && "0" !== e && (i += this._beatsToUnits(parseFloat(e))), s && "0" !== s && (i += this._beatsToUnits(parseFloat(s) / 4)), i }, regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/ } } } valueOf() { if (this._val instanceof _d && this.fromType(this._val), gp(this._val)) return this._noArg(); if (bp(this._val) && gp(this._units)) { for (const t in this._expressions) if (this._expressions[t].regexp.test(this._val.trim())) { this._units = t; break } } else if (xp(this._val)) { let t = 0; for (const s in this._val) { var e; o(this._val[s]) && (e = this._val[s], t += new this.constructor(this.context, s).valueOf() * e) } return t } if (o(this._units)) { const i = this._expressions[this._units], n = this._val.toString().trim().match(i.regexp); return n ? i.method.apply(this, n.slice(1)) : i.method.call(this, this._val) } return bp(this._val) ? parseFloat(this._val) : this._val } _frequencyToUnits(t) { return 1 / t } _beatsToUnits(t) { return 60 / this._getBpm() * t } _secondsToUnits(t) { return t } _ticksToUnits(t) { return t * this._beatsToUnits(1) / this._getPPQ() } _noArg() { return this._now() } _getBpm() { return this.context.transport.bpm.value } _getTimeSignature() { return this.context.transport.timeSignature } _getPPQ() { return this.context.transport.PPQ } fromType(t) { switch (this._units = void 0, this.defaultUnits) { case "s": this._val = t.toSeconds(); break; case "i": this._val = t.toTicks(); break; case "hz": this._val = t.toFrequency(); break; case "midi": this._val = t.toMidi() }return this } toFrequency() { return 1 / this.toSeconds() } toSamples() { return this.toSeconds() * this.context.sampleRate } toMilliseconds() { return 1e3 * this.toSeconds() } } class md extends _d { constructor() { super(...arguments), this.name = "TimeClass" } _getExpressions() { return Object.assign(super._getExpressions(), { now: { method: t => this._now() + new this.constructor(this.context, t).valueOf(), regexp: /^\+(.+)/ }, quantize: { method: t => { t = new md(this.context, t).valueOf(); return this._secondsToUnits(this.context.transport.nextSubdivision(t)) }, regexp: /^@(.+)/ } }) } quantize(t, e = 1) { var t = new this.constructor(this.context, t).valueOf(), s = this.valueOf(); return s + (Math.round(s / t) * t - s) * e } toNotation() { const s = this.toSeconds(), e = ["1m"]; for (let t = 1; t < 9; t++) { const i = Math.pow(2, t); e.push(i + "n."), e.push(i + "n"), e.push(i + "t") } e.push("0"); let i = e[0], n = new md(this.context, e[0]).toSeconds(); return e.forEach(t => { var e = new md(this.context, t).toSeconds(); Math.abs(e - s) < Math.abs(n - s) && (i = t, n = e) }), i } toBarsBeatsSixteenths() { var t = this._beatsToUnits(1); let e = this.valueOf() / t; e = parseFloat(e.toFixed(4)); const s = Math.floor(e / this._getTimeSignature()); let i = e % 1 * 4; e = Math.floor(e) % this._getTimeSignature(); t = i.toString(); return 3 < t.length && (i = parseFloat(parseFloat(t).toFixed(3))), [s, e, i].join(":") } toTicks() { var t = this._beatsToUnits(1); return this.valueOf() / t * this._getPPQ() } toSeconds() { return this.valueOf() } toMidi() { return pd(this.toFrequency()) } _now() { return this.context.now() } } class gd extends md { constructor() { super(...arguments), this.name = "Frequency", this.defaultUnits = "hz" } static get A4() { return ud } static set A4(t) { t = t, ud = t } _getExpressions() { return Object.assign({}, super._getExpressions(), { midi: { regexp: /^(\d+(?:\.\d+)?midi)/, method(t) { return "midi" === this.defaultUnits ? t : gd.mtof(t) } }, note: { regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i, method(t, e) { t = vd[t.toLowerCase()] + 12 * (parseInt(e, 10) + 1); return "midi" === this.defaultUnits ? t : gd.mtof(t) } }, tr: { regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/, method(t, e, s) { let i = 1; return t && "0" !== t && (i *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), e && "0" !== e && (i *= this._beatsToUnits(parseFloat(e))), s && "0" !== s && (i *= this._beatsToUnits(parseFloat(s) / 4)), i } } }) } transpose(t) { return new gd(this.context, this.valueOf() * ld(t)) } harmonize(t) { return t.map(t => this.transpose(t)) } toMidi() { return pd(this.valueOf()) } toNote() { var t = this.toFrequency(), t = Math.log2(t / gd.A4); let e = Math.round(12 * t) + 57; const s = Math.floor(e / 12); return s < 0 && (e += -12 * s), yd[e % 12] + s.toString() } toSeconds() { return 1 / super.toSeconds() } toTicks() { var t = this._beatsToUnits(1), t = this.valueOf() / t; return Math.floor(t * this._getPPQ()) } _noArg() { return 0 } _frequencyToUnits(t) { return t } _ticksToUnits(t) { return 1 / (60 * t / (this._getBpm() * this._getPPQ())) } _beatsToUnits(t) { return 1 / super._beatsToUnits(t) } _secondsToUnits(t) { return 1 / t } static mtof(t) { return fd(t) } static ftom(t) { return pd(t) } } const vd = { cbbb: -3, cbb: -2, cb: -1, c: 0, "c#": 1, cx: 2, "c##": 2, "c###": 3, "cx#": 3, "c#x": 3, dbbb: -1, dbb: 0, db: 1, d: 2, "d#": 3, dx: 4, "d##": 4, "d###": 5, "dx#": 5, "d#x": 5, ebbb: 1, ebb: 2, eb: 3, e: 4, "e#": 5, ex: 6, "e##": 6, "e###": 7, "ex#": 7, "e#x": 7, fbbb: 2, fbb: 3, fb: 4, f: 5, "f#": 6, fx: 7, "f##": 7, "f###": 8, "fx#": 8, "f#x": 8, gbbb: 4, gbb: 5, gb: 6, g: 7, "g#": 8, gx: 9, "g##": 9, "g###": 10, "gx#": 10, "g#x": 10, abbb: 6, abb: 7, ab: 8, a: 9, "a#": 10, ax: 11, "a##": 11, "a###": 12, "ax#": 12, "a#x": 12, bbbb: 8, bbb: 9, bb: 10, b: 11, "b#": 12, bx: 13, "b##": 13, "b###": 14, "bx#": 14, "b#x": 14 }, yd = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]; class T extends md { constructor() { super(...arguments), this.name = "TransportTime" } _now() { return this.context.transport.seconds } } class S extends Wp { constructor() { super(); var t = g(S.getDefaults(), arguments, ["context"]); this.defaultContext ? this.context = this.defaultContext : this.context = t.context } static getDefaults() { return { context: b() } } now() { return this.context.currentTime + this.context.lookAhead } immediate() { return this.context.currentTime } get sampleTime() { return 1 / this.context.sampleRate } get blockTime() { return 128 / this.context.sampleRate } toSeconds(t) { return Op(t), new md(this.context, t).toSeconds() } toFrequency(t) { return new gd(this.context, t).toFrequency() } toTicks(t) { return new T(this.context, t).toTicks() } _getPartialProperties(e) { const s = this.get(); return Object.keys(s).forEach(t => { gp(e[t]) && delete s[t] }), s } get() { const s = this.constructor.getDefaults(); return Object.keys(s).forEach(t => { if (Reflect.has(this, t)) { const e = this[t]; o(e) && o(e.value) && o(e.setValueAtTime) ? s[t] = e.value : e instanceof S ? s[t] = e._getPartialProperties(s[t]) : d(e) || yp(e) || bp(e) || wp(e) ? s[t] = e : delete s[t] } }), s } set(e) { return Object.keys(e).forEach(t => { Reflect.has(this, t) && o(this[t]) && (this[t] && o(this[t].value) && o(this[t].setValueAtTime) ? this[t].value !== e[t] && (this[t].value = e[t]) : this[t] instanceof S ? this[t].set(e[t]) : this[t] = e[t]) }), this } } class xd extends Yp { constructor(t = "stopped") { super(), this.name = "StateTimeline", this._initial = t, this.setStateAtTime(this._initial, 0) } getValueAtTime(t) { t = this.get(t); return null !== t ? t.state : this._initial } setStateAtTime(t, e, s) { return f(e, 0), this.add(Object.assign({}, s, { state: t, time: e })), this } getLastState(e, s) { for (let t = this._search(s); 0 <= t; t--) { const s = this._timeline[t]; if (s.state === e) return s } } getNextState(e, t) { const s = this._search(t); if (-1 !== s) for (let t = s; t < this._timeline.length; t++) { const s = this._timeline[t]; if (s.state === e) return s } } } class k extends S { constructor() { const t = g(k.getDefaults(), arguments, ["param", "units", "convert"]); for (super(t), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7, l(o(t.param) && (Vp(t.param) || t.param instanceof k), "param must be an AudioParam"); !Vp(t.param);)t.param = t.param._param; this._swappable = !!o(t.swappable) && t.swappable, this._swappable ? (this.input = this.context.createGain(), this._param = t.param, this.input.connect(this._param)) : this._param = this.input = t.param, this._events = new Yp(1e3), this._initialValue = this._param.defaultValue, this.units = t.units, this.convert = t.convert, this._minValue = t.minValue, this._maxValue = t.maxValue, o(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0) } static getDefaults() { return Object.assign(S.getDefaults(), { convert: !0, units: "number" }) } get value() { var t = this.now(); return this.getValueAtTime(t) } set value(t) { this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now()) } get minValue() { return o(this._minValue) ? this._minValue : "time" === this.units || "frequency" === this.units || "normalRange" === this.units || "positive" === this.units || "transportTime" === this.units || "ticks" === this.units || "bpm" === this.units || "hertz" === this.units || "samples" === this.units ? 0 : "audioRange" === this.units ? -1 : "decibels" === this.units ? -1 / 0 : this._param.minValue } get maxValue() { return o(this._maxValue) ? this._maxValue : "normalRange" === this.units || "audioRange" === this.units ? 1 : this._param.maxValue } _is(t, e) { return this.units === e } _assertRange(t) { return o(this.maxValue) && o(this.minValue) && f(t, this._fromType(this.minValue), this._fromType(this.maxValue)), t } _fromType(t) { return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? hd(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t } _toType(t) { return this.convert && "decibels" === this.units ? cd(t) : t } setValueAtTime(t, e) { var s = this.toSeconds(e), i = this._fromType(t); return l(isFinite(i) && isFinite(s), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ` + JSON.stringify(e)), this._assertRange(i), this.log(this.units, "setValueAtTime", t, s), this._events.add({ time: s, type: "setValueAtTime", value: i }), this._param.setValueAtTime(i, s), this } getValueAtTime(t) { const e = Math.max(this.toSeconds(t), 0), s = this._events.getAfter(e), i = this._events.get(e); let n = this._initialValue; if (null === i) n = this._initialValue; else if ("setTargetAtTime" !== i.type || null !== s && "setValueAtTime" !== s.type) if (null === s) n = i.value; else if ("linearRampToValueAtTime" === s.type || "exponentialRampToValueAtTime" === s.type) { let t = i.value; if ("setTargetAtTime" === i.type) { const e = this._events.getBefore(i.time); t = null === e ? this._initialValue : e.value } n = "linearRampToValueAtTime" === s.type ? this._linearInterpolate(i.time, t, s.time, s.value, e) : this._exponentialInterpolate(i.time, t, s.time, s.value, e) } else n = i.value; else { const t = this._events.getBefore(i.time); var r = null === t ? this._initialValue : t.value; "setTargetAtTime" === i.type && (n = this._exponentialApproach(i.time, r, i.value, i.constant, e)) } return this._toType(n) } setRampPoint(t) { t = this.toSeconds(t); let e = this.getValueAtTime(t); return this.cancelAndHoldAtTime(t), 0 === this._fromType(e) && (e = this._toType(this._minOutput)), this.setValueAtTime(e, t), this } linearRampToValueAtTime(t, e) { var s = this._fromType(t), i = this.toSeconds(e); return l(isFinite(s) && isFinite(i), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ` + JSON.stringify(e)), this._assertRange(s), this._events.add({ time: i, type: "linearRampToValueAtTime", value: s }), this.log(this.units, "linearRampToValueAtTime", t, i), this._param.linearRampToValueAtTime(s, i), this } exponentialRampToValueAtTime(t, e) { let s = this._fromType(t); s = Zp(s, 0) ? this._minOutput : s, this._assertRange(s); var i = this.toSeconds(e); return l(isFinite(s) && isFinite(i), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ` + JSON.stringify(e)), this._events.add({ time: i, type: "exponentialRampToValueAtTime", value: s }), this.log(this.units, "exponentialRampToValueAtTime", t, i), this._param.exponentialRampToValueAtTime(s, i), this } exponentialRampTo(t, e, s) { return s = this.toSeconds(s), this.setRampPoint(s), this.exponentialRampToValueAtTime(t, s + this.toSeconds(e)), this } linearRampTo(t, e, s) { return s = this.toSeconds(s), this.setRampPoint(s), this.linearRampToValueAtTime(t, s + this.toSeconds(e)), this } targetRampTo(t, e, s) { return s = this.toSeconds(s), this.setRampPoint(s), this.exponentialApproachValueAtTime(t, s, e), this } exponentialApproachValueAtTime(t, e, s) { e = this.toSeconds(e), s = this.toSeconds(s); var i = Math.log(s + 1) / Math.log(200); return this.setTargetAtTime(t, e, i), this.cancelAndHoldAtTime(e + .9 * s), this.linearRampToValueAtTime(t, e + s), this } setTargetAtTime(t, e, s) { var i = this._fromType(t), n = (l(isFinite(s) && 0 < s, "timeConstant must be a number greater than 0"), this.toSeconds(e)); return this._assertRange(i), l(isFinite(i) && isFinite(n), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ` + JSON.stringify(e)), this._events.add({ constant: s, time: n, type: "setTargetAtTime", value: i }), this.log(this.units, "setTargetAtTime", t, n, s), this._param.setTargetAtTime(i, n, s), this } setValueCurveAtTime(e, s, t, i = 1) { t = this.toSeconds(t), s = this.toSeconds(s); const n = this._fromType(e[0]) * i; this.setValueAtTime(this._toType(n), s); var r = t / (e.length - 1); for (let t = 1; t < e.length; t++) { const n = this._fromType(e[t]) * i; this.linearRampToValueAtTime(this._toType(n), s + t * r) } return this } cancelScheduledValues(t) { var e = this.toSeconds(t); return l(isFinite(e), "Invalid argument to cancelScheduledValues: " + JSON.stringify(t)), this._events.cancel(e), this._param.cancelScheduledValues(e), this.log(this.units, "cancelScheduledValues", e), this } cancelAndHoldAtTime(t) { var e = this.toSeconds(t), s = this._fromType(this.getValueAtTime(e)), t = (l(isFinite(e), "Invalid argument to cancelAndHoldAtTime: " + JSON.stringify(t)), this.log(this.units, "cancelAndHoldAtTime", e, "value=" + s), this._events.get(e)), i = this._events.getAfter(e); return t && Zp(t.time, e) ? i ? (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time)) : (this._param.cancelAndHoldAtTime(e), this._events.cancel(e + this.sampleTime)) : i && (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time), "linearRampToValueAtTime" === i.type ? this.linearRampToValueAtTime(this._toType(s), e) : "exponentialRampToValueAtTime" === i.type && this.exponentialRampToValueAtTime(this._toType(s), e)), this._events.add({ time: e, type: "setValueAtTime", value: s }), this._param.setValueAtTime(s, e), this } rampTo(t, e = .1, s) { return "frequency" === this.units || "bpm" === this.units || "decibels" === this.units ? this.exponentialRampTo(t, e, s) : this.linearRampTo(t, e, s), this } apply(e) { var s = this.context.currentTime, t = (e.setValueAtTime(this.getValueAtTime(s), s), this._events.get(s)); if (t && "setTargetAtTime" === t.type) { var t = this._events.getAfter(t.time), i = t ? t.time : s + 2, n = (i - s) / 10; for (let t = s; t < i; t += n)e.linearRampToValueAtTime(this.getValueAtTime(t), t) } return this._events.forEachAfter(this.context.currentTime, t => { "cancelScheduledValues" === t.type ? e.cancelScheduledValues(t.time) : "setTargetAtTime" === t.type ? e.setTargetAtTime(t.value, t.time, t.constant) : e[t.type](t.value, t.time) }), this } setParam(t) { l(this._swappable, "The Param must be assigned as 'swappable' in the constructor"); const e = this.input; return e.disconnect(this._param), this.apply(t), this._param = t, e.connect(this._param), this } dispose() { return super.dispose(), this._events.dispose(), this } get defaultValue() { return this._toType(this._param.defaultValue) } _exponentialApproach(t, e, s, i, n) { return s + (e - s) * Math.exp(-(n - t) / i) } _linearInterpolate(t, e, s, i, n) { return e + (n - t) / (s - t) * (i - e) } _exponentialInterpolate(t, e, s, i, n) { return e * Math.pow(i / e, (n - t) / (s - t)) } } class A extends S { constructor() { super(...arguments), this._internalChannels = [] } get numberOfInputs() { return o(this.input) ? Vp(this.input) || this.input instanceof k ? 1 : this.input.numberOfInputs : 0 } get numberOfOutputs() { return o(this.output) ? this.output.numberOfOutputs : 0 } _isAudioNode(t) { return o(t) && (t instanceof A || Np(t)) } _getInternalNodes() { const t = this._internalChannels.slice(0); return this._isAudioNode(this.input) && t.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output), t } _setChannelProperties(e) { this._getInternalNodes().forEach(t => { t.channelCount = e.channelCount, t.channelCountMode = e.channelCountMode, t.channelInterpretation = e.channelInterpretation }) } _getChannelProperties() { var t = this._getInternalNodes(), t = (l(0 < t.length, "ToneAudioNode does not have any internal nodes"), t[0]); return { channelCount: t.channelCount, channelCountMode: t.channelCountMode, channelInterpretation: t.channelInterpretation } } get channelCount() { return this._getChannelProperties().channelCount } set channelCount(t) { var e = this._getChannelProperties(); this._setChannelProperties(Object.assign(e, { channelCount: t })) } get channelCountMode() { return this._getChannelProperties().channelCountMode } set channelCountMode(t) { var e = this._getChannelProperties(); this._setChannelProperties(Object.assign(e, { channelCountMode: t })) } get channelInterpretation() { return this._getChannelProperties().channelInterpretation } set channelInterpretation(t) { var e = this._getChannelProperties(); this._setChannelProperties(Object.assign(e, { channelInterpretation: t })) } connect(t, e = 0, s = 0) { return bd(this, t, e, s), this } toDestination() { return this.connect(this.context.destination), this } toMaster() { return Ep("toMaster() has been renamed toDestination()"), this.toDestination() } disconnect(t, e = 0, s = 0) { return Td(this, t, e, s), this } chain(...t) { return wd(this, ...t), this } fan(...t) { return t.forEach(t => this.connect(t)), this } dispose() { return super.dispose(), o(this.input) && (this.input instanceof A ? this.input.dispose() : Np(this.input) && this.input.disconnect()), o(this.output) && (this.output instanceof A ? this.output.dispose() : Np(this.output) && this.output.disconnect()), this._internalChannels = [], this } } function wd(...t) { var e = t.shift(); t.reduce((t, e) => (t instanceof A ? t.connect(e) : Np(t) && bd(t, e), e), e) } function bd(t, e, s = 0, i = 0) { for (l(o(t), "Cannot connect from undefined node"), l(o(e), "Cannot connect to undefined node"), (e instanceof A || Np(e)) && l(0 < e.numberOfInputs, "Cannot connect to node with no inputs"), l(0 < t.numberOfOutputs, "Cannot connect from node with no outputs"); e instanceof A || e instanceof k;)o(e.input) && (e = e.input); for (; t instanceof A;)o(t.output) && (t = t.output); Vp(e) ? t.connect(e, s) : t.connect(e, s, i) } function Td(t, e, s = 0, i = 0) { if (o(e)) for (; e instanceof A;)e = e.input; for (; !Np(t);)o(t.output) && (t = t.output); Vp(e) ? t.disconnect(e, s) : Np(e) ? t.disconnect(e, s, i) : t.disconnect() } class C extends A { constructor() { var t = g(C.getDefaults(), arguments, ["gain", "units"]); super(t), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode, this.gain = new k({ context: this.context, convert: t.convert, param: this._gainNode.gain, units: t.units, value: t.gain, minValue: t.minValue, maxValue: t.maxValue }), y(this, "gain") } static getDefaults() { return Object.assign(A.getDefaults(), { convert: !0, gain: 1, units: "gain" }) } dispose() { return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this } } class Sd extends A { constructor(t) { super(t), this.onended = x, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new C({ context: this.context, gain: 0 }), this._gainNode = this.output, this.getStateAtTime = function (t) { t = this.toSeconds(t); return -1 !== this._startTime && t >= this._startTime && (-1 === this._stopTime || t <= this._stopTime) ? "started" : "stopped" }, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut, this._curve = t.curve, this.onended = t.onended } static getDefaults() { return Object.assign(A.getDefaults(), { curve: "linear", fadeIn: 0, fadeOut: 0, onended: x }) } _startGain(t, e = 1) { l(-1 === this._startTime, "Source cannot be started more than once"); var s = this.toSeconds(this._fadeIn); return this._startTime = t + s, this._startTime = Math.max(this._startTime, this.context.currentTime), 0 < s ? (this._gainNode.gain.setValueAtTime(0, t), "linear" === this._curve ? this._gainNode.gain.linearRampToValueAtTime(e, t + s) : this._gainNode.gain.exponentialApproachValueAtTime(e, t, s)) : this._gainNode.gain.setValueAtTime(e, t), this } stop(t) { return this.log("stop", t), this._stopGain(this.toSeconds(t)), this } _stopGain(t) { l(-1 !== this._startTime, "'start' must be called before 'stop'"), this.cancelStop(); const e = this.toSeconds(this._fadeOut); return this._stopTime = this.toSeconds(t) + e, this._stopTime = Math.max(this._stopTime, this.now()), 0 < e ? "linear" === this._curve ? this._gainNode.gain.linearRampTo(0, e, t) : this._gainNode.gain.targetRampTo(0, e, t) : (this._gainNode.gain.cancelAndHoldAtTime(t), this._gainNode.gain.setValueAtTime(0, t)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => { var t = "exponential" === this._curve ? 2 * e : 0; this._stopSource(this.now() + t), this._onended() }, this._stopTime - this.context.currentTime), this } _onended() { var t; this.onended === x || (this.onended(this), this.onended = x, this.context.isOffline) || (t = () => this.dispose(), void 0 !== window.requestIdleCallback ? window.requestIdleCallback(t) : setTimeout(t, 1e3)) } get state() { return this.getStateAtTime(this.now()) } cancelStop() { return this.log("cancelStop"), l(-1 !== this._startTime, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this } dispose() { return super.dispose(), this._gainNode.dispose(), this.onended = x, this } } class kd extends Sd { constructor() { var t = g(kd.getDefaults(), arguments, ["offset"]); super(t), this.name = "ToneConstantSource", this._source = this.context.createConstantSource(), bd(this._source, this._gainNode), this.offset = new k({ context: this.context, convert: t.convert, param: this._source.offset, units: t.units, value: t.offset, minValue: t.minValue, maxValue: t.maxValue }) } static getDefaults() { return Object.assign(Sd.getDefaults(), { convert: !0, offset: 1, units: "number" }) } start(t) { t = this.toSeconds(t); return this.log("start", t), this._startGain(t), this._source.start(t), this } _stopSource(t) { this._source.stop(t) } dispose() { return super.dispose(), "started" === this.state && this.stop(), this._source.disconnect(), this.offset.dispose(), this } } class O extends A { constructor() { var t = g(O.getDefaults(), arguments, ["value", "units"]); super(t), this.name = "Signal", this.override = !0, this.output = this._constantSource = new kd({ context: this.context, convert: t.convert, offset: t.value, units: t.units, minValue: t.minValue, maxValue: t.maxValue }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset } static getDefaults() { return Object.assign(A.getDefaults(), { convert: !0, units: "number", value: 0 }) } connect(t, e = 0, s = 0) { return Ad(this, t, e, s), this } dispose() { return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this } setValueAtTime(t, e) { return this._param.setValueAtTime(t, e), this } getValueAtTime(t) { return this._param.getValueAtTime(t) } setRampPoint(t) { return this._param.setRampPoint(t), this } linearRampToValueAtTime(t, e) { return this._param.linearRampToValueAtTime(t, e), this } exponentialRampToValueAtTime(t, e) { return this._param.exponentialRampToValueAtTime(t, e), this } exponentialRampTo(t, e, s) { return this._param.exponentialRampTo(t, e, s), this } linearRampTo(t, e, s) { return this._param.linearRampTo(t, e, s), this } targetRampTo(t, e, s) { return this._param.targetRampTo(t, e, s), this } exponentialApproachValueAtTime(t, e, s) { return this._param.exponentialApproachValueAtTime(t, e, s), this } setTargetAtTime(t, e, s) { return this._param.setTargetAtTime(t, e, s), this } setValueCurveAtTime(t, e, s, i) { return this._param.setValueCurveAtTime(t, e, s, i), this } cancelScheduledValues(t) { return this._param.cancelScheduledValues(t), this } cancelAndHoldAtTime(t) { return this._param.cancelAndHoldAtTime(t), this } rampTo(t, e, s) { return this._param.rampTo(t, e, s), this } get value() { return this._param.value } set value(t) { this._param.value = t } get convert() { return this._param.convert } set convert(t) { this._param.convert = t } get units() { return this._param.units } get overridden() { return this._param.overridden } set overridden(t) { this._param.overridden = t } get maxValue() { return this._param.maxValue } get minValue() { return this._param.minValue } apply(t) { return this._param.apply(t), this } } function Ad(t, e, s, i) { (e instanceof k || Vp(e) || e instanceof O && e.override) && (e.cancelScheduledValues(0), e.setValueAtTime(0, 0), e instanceof O && (e.overridden = !0)), bd(t, e, s, i) } class Cd extends k { constructor() { var t = g(Cd.getDefaults(), arguments, ["value"]); super(t), this.name = "TickParam", this._events = new Yp(1 / 0), this._multiplier = 1, this._multiplier = t.multiplier, this._events.cancel(0), this._events.add({ ticks: 0, time: 0, type: "setValueAtTime", value: this._fromType(t.value) }), this.setValueAtTime(t.value, 0) } static getDefaults() { return Object.assign(k.getDefaults(), { multiplier: 1, units: "hertz", value: 1 }) } setTargetAtTime(t, e, s) { e = this.toSeconds(e), this.setRampPoint(e); const i = this._fromType(t), n = this._events.get(e), r = Math.round(Math.max(1 / s, 1)); for (let t = 0; t <= r; t++) { const r = s * t + e, o = this._exponentialApproach(n.time, n.value, i, s, r); this.linearRampToValueAtTime(this._toType(o), r) } return this } setValueAtTime(t, e) { var s = this.toSeconds(e); super.setValueAtTime(t, e); const i = this._events.get(s), n = this._events.previousEvent(i), r = this._getTicksUntilEvent(n, s); return i.ticks = Math.max(r, 0), this } linearRampToValueAtTime(t, e) { var s = this.toSeconds(e); super.linearRampToValueAtTime(t, e); const i = this._events.get(s), n = this._events.previousEvent(i), r = this._getTicksUntilEvent(n, s); return i.ticks = Math.max(r, 0), this } exponentialRampToValueAtTime(t, e) { e = this.toSeconds(e); const s = this._fromType(t), i = this._events.get(e), n = Math.round(Math.max(10 * (e - i.time), 1)), r = (e - i.time) / n; for (let t = 0; t <= n; t++) { const n = r * t + i.time, o = this._exponentialInterpolate(i.time, i.value, e, s, n); this.linearRampToValueAtTime(this._toType(o), n) } return this } _getTicksUntilEvent(t, e) { if (null === t) t = { ticks: 0, time: 0, type: "setValueAtTime", value: 0 }; else if (gp(t.ticks)) { const e = this._events.previousEvent(t); t.ticks = this._getTicksUntilEvent(e, t.time) } var s = this._fromType(this.getValueAtTime(t.time)); let i = this._fromType(this.getValueAtTime(e)); var n = this._events.get(e); return n && n.time === e && "setValueAtTime" === n.type && (i = this._fromType(this.getValueAtTime(e - this.sampleTime))), .5 * (e - t.time) * (s + i) + t.ticks } getTicksAtTime(t) { var t = this.toSeconds(t), e = this._events.get(t); return Math.max(this._getTicksUntilEvent(e, t), 0) } getDurationOfTicks(t, e) { var s = this.toSeconds(e), e = this.getTicksAtTime(e); return this.getTimeOfTick(e + t) - s } getTimeOfTick(t) { var e, s, i, n = this._events.get(t, "ticks"), r = this._events.getAfter(t, "ticks"); return n && n.ticks === t ? n.time : n && r && "linearRampToValueAtTime" === r.type && n.value !== r.value ? (e = this._fromType(this.getValueAtTime(n.time)), r = (this._fromType(this.getValueAtTime(r.time)) - e) / (r.time - n.time), (0 < (i = (-e + (s = Math.sqrt(Math.pow(e, 2) - 2 * r * (n.ticks - t)))) / r) ? i : (-e - s) / r) + n.time) : n ? 0 === n.value ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue } ticksToTime(t, e) { return this.getDurationOfTicks(t, e) } timeToTicks(t, e) { var e = this.toSeconds(e), t = this.toSeconds(t), s = this.getTicksAtTime(e); return this.getTicksAtTime(e + t) - s } _fromType(t) { return "bpm" === this.units && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t) } _toType(t) { return "bpm" === this.units && this.multiplier ? t / this.multiplier * 60 : super._toType(t) } get multiplier() { return this._multiplier } set multiplier(t) { var e = this.value; this._multiplier = t, this.cancelScheduledValues(0), this.setValueAtTime(e, 0) } } class Od extends O { constructor() { var t = g(Od.getDefaults(), arguments, ["value"]); super(t), this.name = "TickSignal", this.input = this._param = new Cd({ context: this.context, convert: t.convert, multiplier: t.multiplier, param: this._constantSource.offset, units: t.units, value: t.value }) } static getDefaults() { return Object.assign(O.getDefaults(), { multiplier: 1, units: "hertz", value: 1 }) } ticksToTime(t, e) { return this._param.ticksToTime(t, e) } timeToTicks(t, e) { return this._param.timeToTicks(t, e) } getTimeOfTick(t) { return this._param.getTimeOfTick(t) } getDurationOfTicks(t, e) { return this._param.getDurationOfTicks(t, e) } getTicksAtTime(t) { return this._param.getTicksAtTime(t) } get multiplier() { return this._param.multiplier } set multiplier(t) { this._param.multiplier = t } dispose() { return super.dispose(), this._param.dispose(), this } } class Dd extends S { constructor() { var t = g(Dd.getDefaults(), arguments, ["frequency"]); super(t), this.name = "TickSource", this._state = new xd, this._tickOffset = new Yp, this._ticksAtTime = new Yp, this._secondsAtTime = new Yp, this.frequency = new Od({ context: this.context, units: t.units, value: t.frequency }), y(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0) } static getDefaults() { return Object.assign({ frequency: 1, units: "hertz" }, S.getDefaults()) } get state() { return this.getStateAtTime(this.now()) } start(t, e) { t = this.toSeconds(t); return "started" !== this._state.getValueAtTime(t) && (this._state.setStateAtTime("started", t), o(e) && this.setTicksAtTime(e, t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t)), this } stop(t) { var e = this.toSeconds(t); if ("stopped" === this._state.getValueAtTime(e)) { const t = this._state.get(e); t && 0 < t.time && (this._tickOffset.cancel(t.time), this._state.cancel(t.time)) } return this._state.cancel(e), this._state.setStateAtTime("stopped", e), this.setTicksAtTime(0, e), this._ticksAtTime.cancel(e), this._secondsAtTime.cancel(e), this } pause(t) { t = this.toSeconds(t); return "started" === this._state.getValueAtTime(t) && (this._state.setStateAtTime("paused", t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t)), this } cancel(t) { return t = this.toSeconds(t), this._state.cancel(t), this._tickOffset.cancel(t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t), this } getTicksAtTime(t) { const e = this.toSeconds(t), s = this._state.getLastState("stopped", e), i = this._ticksAtTime.get(e), n = { state: "paused", time: e }; this._state.add(n); let r = i || s, o = i ? i.ticks : 0, a = null; return this._state.forEachBetween(r.time, e + this.sampleTime, t => { let e = r.time; var s = this._tickOffset.get(t.time); s && s.time >= r.time && (o = s.ticks, e = s.time), "started" === r.state && "started" !== t.state && (o += this.frequency.getTicksAtTime(t.time) - this.frequency.getTicksAtTime(e), t.time !== n.time && (a = { state: t.state, time: t.time, ticks: o })), r = t }), this._state.remove(n), a && this._ticksAtTime.add(a), o } get ticks() { return this.getTicksAtTime(this.now()) } set ticks(t) { this.setTicksAtTime(t, this.now()) } get seconds() { return this.getSecondsAtTime(this.now()) } set seconds(t) { var e = this.now(), t = this.frequency.timeToTicks(t, e); this.setTicksAtTime(t, e) } getSecondsAtTime(t) { t = this.toSeconds(t); const e = this._state.getLastState("stopped", t), i = { state: "paused", time: t }; this._state.add(i); var s = this._secondsAtTime.get(t); let n = s || e, r = s ? s.seconds : 0, o = null; return this._state.forEachBetween(n.time, t + this.sampleTime, t => { let e = n.time; var s = this._tickOffset.get(t.time); s && s.time >= n.time && (r = s.seconds, e = s.time), "started" === n.state && "started" !== t.state && (r += t.time - e, t.time !== i.time && (o = { state: t.state, time: t.time, seconds: r })), n = t }), this._state.remove(i), o && this._secondsAtTime.add(o), r } setTicksAtTime(t, e) { return e = this.toSeconds(e), this._tickOffset.cancel(e), this._tickOffset.add({ seconds: this.frequency.getDurationOfTicks(t, e), ticks: t, time: e }), this._ticksAtTime.cancel(e), this._secondsAtTime.cancel(e), this } getStateAtTime(t) { return t = this.toSeconds(t), this._state.getValueAtTime(t) } getTimeOfTick(t, e = this.now()) { var s = this._tickOffset.get(e), e = this._state.get(e), e = Math.max(s.time, e.time), e = this.frequency.getTicksAtTime(e) + t - s.ticks; return this.frequency.getTimeOfTick(e) } forEachTickBetween(s, i, n) { let r = this._state.get(s), o = (this._state.forEachBetween(s, i, t => { r && "started" === r.state && "started" !== t.state && this.forEachTickBetween(Math.max(r.time, s), t.time - this.sampleTime, n), r = t }), null); if (r && "started" === r.state) { var a = Math.max(r.time, s), a = this.frequency.getTicksAtTime(a), h = a - this.frequency.getTicksAtTime(r.time); let t = Math.ceil(h) - h, e = (t = Zp(t, 1) ? 0 : t, this.frequency.getTimeOfTick(a + t)); for (; e < i;) { try { n(e, Math.round(this.getTicksAtTime(e))) } catch (s) { o = s; break } e += this.frequency.getDurationOfTicks(1, e) } } if (o) throw o; return this } dispose() { return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this._ticksAtTime.dispose(), this._secondsAtTime.dispose(), this.frequency.dispose(), this } } class Md extends S { constructor() { var t = g(Md.getDefaults(), arguments, ["callback", "frequency"]); super(t), this.name = "Clock", this.callback = x, this._lastUpdate = 0, this._state = new xd("stopped"), this._boundLoop = this._loop.bind(this), this.callback = t.callback, this._tickSource = new Dd({ context: this.context, frequency: t.frequency, units: t.units }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, y(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop) } static getDefaults() { return Object.assign(S.getDefaults(), { callback: x, frequency: 1, units: "hertz" }) } get state() { return this._state.getValueAtTime(this.now()) } start(t, e) { Sp(this.context); t = this.toSeconds(t); return this.log("start", t), "started" !== this._state.getValueAtTime(t) && (this._state.setStateAtTime("started", t), this._tickSource.start(t, e), t < this._lastUpdate && this.emit("start", t, e)), this } stop(t) { t = this.toSeconds(t); return this.log("stop", t), this._state.cancel(t), this._state.setStateAtTime("stopped", t), this._tickSource.stop(t), t < this._lastUpdate && this.emit("stop", t), this } pause(t) { t = this.toSeconds(t); return "started" === this._state.getValueAtTime(t) && (this._state.setStateAtTime("paused", t), this._tickSource.pause(t), t < this._lastUpdate && this.emit("pause", t)), this } get ticks() { return Math.ceil(this.getTicksAtTime(this.now())) } set ticks(t) { this._tickSource.ticks = t } get seconds() { return this._tickSource.seconds } set seconds(t) { this._tickSource.seconds = t } getSecondsAtTime(t) { return this._tickSource.getSecondsAtTime(t) } setTicksAtTime(t, e) { return this._tickSource.setTicksAtTime(t, e), this } getTimeOfTick(t, e = this.now()) { return this._tickSource.getTimeOfTick(t, e) } getTicksAtTime(t) { return this._tickSource.getTicksAtTime(t) } nextTickTime(t, e) { var e = this.toSeconds(e), s = this.getTicksAtTime(e); return this._tickSource.getTimeOfTick(s + t, e) } _loop() { var t = this._lastUpdate, e = this.now(); this._lastUpdate = e, this.log("loop", t, e), t !== e && (this._state.forEachBetween(t, e, t => { switch (t.state) { case "started": var e = this._tickSource.getTicksAtTime(t.time); this.emit("start", t.time, e); break; case "stopped": 0 !== t.time && this.emit("stop", t.time); break; case "paused": this.emit("pause", t.time) } }), this._tickSource.forEachTickBetween(t, e, (t, e) => { this.callback(t, e) })) } getStateAtTime(t) { t = this.toSeconds(t); return this._state.getValueAtTime(t) } dispose() { return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this } } td.mixin(Md); class Ed extends A { constructor() { var t = g(Ed.getDefaults(), arguments, ["delayTime", "maxDelay"]), e = (super(t), this.name = "Delay", this.toSeconds(t.maxDelay)); this._maxDelay = Math.max(e, this.toSeconds(t.delayTime)), this._delayNode = this.input = this.output = this.context.createDelay(e), this.delayTime = new k({ context: this.context, param: this._delayNode.delayTime, units: "time", value: t.delayTime, minValue: 0, maxValue: this.maxDelay }), y(this, "delayTime") } static getDefaults() { return Object.assign(A.getDefaults(), { delayTime: 0, maxDelay: 1 }) } get maxDelay() { return this._maxDelay } dispose() { return super.dispose(), this._delayNode.disconnect(), this.delayTime.dispose(), this } } class Rd extends A { constructor() { var t = g(Rd.getDefaults(), arguments, ["volume"]); super(t), this.name = "Volume", this.input = this.output = new C({ context: this.context, gain: t.volume, units: "decibels" }), this.volume = this.output.gain, y(this, "volume"), this._unmutedVolume = t.volume, this.mute = t.mute } static getDefaults() { return Object.assign(A.getDefaults(), { mute: !1, volume: 0 }) } get mute() { return this.volume.value === -1 / 0 } set mute(t) { !this.mute && t ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume) } dispose() { return super.dispose(), this.input.dispose(), this.volume.dispose(), this } } class qd extends A { constructor() { var t = g(qd.getDefaults(), arguments); super(t), this.name = "Destination", this.input = new Rd({ context: this.context }), this.output = new C({ context: this.context }), this.volume = this.input.volume, wd(this.input, this.output, this.context.rawContext.destination), this.mute = t.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output] } static getDefaults() { return Object.assign(A.getDefaults(), { mute: !1, volume: 0 }) } get mute() { return this.input.mute } set mute(t) { this.input.mute = t } chain(...t) { return this.input.disconnect(), t.unshift(this.input), t.push(this.output), wd(...t), this } get maxChannelCount() { return this.context.rawContext.destination.maxChannelCount } dispose() { return super.dispose(), this.volume.dispose(), this } } $p(t => { t.destination = new qd({ context: t }) }), Kp(t => { t.destination.dispose() }); class Id extends A { constructor() { super(...arguments), this.name = "Listener", this.positionX = new k({ context: this.context, param: this.context.rawContext.listener.positionX }), this.positionY = new k({ context: this.context, param: this.context.rawContext.listener.positionY }), this.positionZ = new k({ context: this.context, param: this.context.rawContext.listener.positionZ }), this.forwardX = new k({ context: this.context, param: this.context.rawContext.listener.forwardX }), this.forwardY = new k({ context: this.context, param: this.context.rawContext.listener.forwardY }), this.forwardZ = new k({ context: this.context, param: this.context.rawContext.listener.forwardZ }), this.upX = new k({ context: this.context, param: this.context.rawContext.listener.upX }), this.upY = new k({ context: this.context, param: this.context.rawContext.listener.upY }), this.upZ = new k({ context: this.context, param: this.context.rawContext.listener.upZ }) } static getDefaults() { return Object.assign(A.getDefaults(), { positionX: 0, positionY: 0, positionZ: 0, forwardX: 0, forwardY: 0, forwardZ: -1, upX: 0, upY: 1, upZ: 0 }) } dispose() { return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this } } $p(t => { t.listener = new Id({ context: t }) }), Kp(t => { t.listener.dispose() }); class Fd extends Wp { constructor() { super(), this.name = "ToneAudioBuffers", this._buffers = new Map, this._loadingCount = 0; const s = g(Fd.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"); this.baseUrl = s.baseUrl, Object.keys(s.urls).forEach(t => { this._loadingCount++; var e = s.urls[t]; this.add(t, e, this._bufferLoaded.bind(this, s.onload), s.onerror) }) } static getDefaults() { return { baseUrl: "", onerror: x, onload: x, urls: {} } } has(t) { return this._buffers.has(t.toString()) } get(t) { return l(this.has(t), "ToneAudioBuffers has no buffer named: " + t), this._buffers.get(t.toString()) } _bufferLoaded(t) { this._loadingCount--, 0 === this._loadingCount && t && t() } get loaded() { return Array.from(this._buffers).every(([, t]) => t.loaded) } add(t, e, s = x, i = x) { return bp(e) ? (this.baseUrl && "data:audio/" === e.trim().substring(0, 11).toLowerCase() && (this.baseUrl = ""), this._buffers.set(t.toString(), new w(this.baseUrl + e, s, i))) : this._buffers.set(t.toString(), new w(e, s, i)), this } dispose() { return super.dispose(), this._buffers.forEach(t => t.dispose()), this._buffers.clear(), this } } class Vd extends gd { constructor() { super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi" } _frequencyToUnits(t) { return pd(super._frequencyToUnits(t)) } _ticksToUnits(t) { return pd(super._ticksToUnits(t)) } _beatsToUnits(t) { return pd(super._beatsToUnits(t)) } _secondsToUnits(t) { return pd(super._secondsToUnits(t)) } toMidi() { return this.valueOf() } toFrequency() { return fd(this.toMidi()) } transpose(t) { return new Vd(this.context, this.toMidi() + t) } } class D extends T { constructor() { super(...arguments), this.name = "Ticks", this.defaultUnits = "i" } _now() { return this.context.transport.ticks } _beatsToUnits(t) { return this._getPPQ() * t } _secondsToUnits(t) { return Math.floor(t / (60 / this._getBpm()) * this._getPPQ()) } _ticksToUnits(t) { return t } toTicks() { return this.valueOf() } toSeconds() { return this.valueOf() / this._getPPQ() * (60 / this._getBpm()) } } class Nd extends S { constructor() { super(...arguments), this.name = "Draw", this.expiration = .25, this.anticipation = .008, this._events = new Yp, this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1 } schedule(t, e) { return this._events.add({ callback: t, time: this.toSeconds(e) }), 1 === this._events.length && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this } cancel(t) { return this._events.cancel(this.toSeconds(t)), this } _drawLoop() { for (var t = this.context.currentTime; this._events.length && this._events.peek().time - this.anticipation <= t;) { const e = this._events.shift(); e && t - e.time <= this.expiration && e.callback() } 0 < this._events.length && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)) } dispose() { return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this } } $p(t => { t.draw = new Nd({ context: t }) }), Kp(t => { t.draw.dispose() }); class Pd extends Wp { constructor() { super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0 } add(t) { l(o(t.time), "Events must have a time property"), l(o(t.duration), "Events must have a duration parameter"), t.time = t.time.valueOf(); let e = new jd(t.time, t.time + t.duration, t); for (null === this._root ? this._root = e : this._root.insert(e), this._length++; null !== e;)e.updateHeight(), e.updateMax(), this._rebalance(e), e = e.parent; return this } remove(t) { if (null !== this._root) { var e = []; this._root.search(t.time, e); for (const s of e) if (s.event === t) { this._removeNode(s), this._length--; break } } return this } get length() { return this._length } cancel(t) { return this.forEachFrom(t, t => this.remove(t)), this } _setRoot(t) { this._root = t, null !== this._root && (this._root.parent = null) } _replaceNodeInParent(t, e) { null !== t.parent ? (t.isLeftChild() ? t.parent.left = e : t.parent.right = e, this._rebalance(t.parent)) : this._setRoot(e) } _removeNode(s) { if (null === s.left && null === s.right) this._replaceNodeInParent(s, null); else if (null === s.right) this._replaceNodeInParent(s, s.left); else if (null === s.left) this._replaceNodeInParent(s, s.right); else { let t, e = null; if (0 < s.getBalance()) if (null === s.left.right) (t = s.left).right = s.right, e = t; else { for (t = s.left.right; null !== t.right;)t = t.right; t.parent && (t.parent.right = t.left, e = t.parent, t.left = s.left, t.right = s.right) } else if (null === s.right.left) (t = s.right).left = s.left, e = t; else { for (t = s.right.left; null !== t.left;)t = t.left; t.parent && (t.parent.left = t.right, e = t.parent, t.left = s.left, t.right = s.right) } null !== s.parent ? s.isLeftChild() ? s.parent.left = t : s.parent.right = t : this._setRoot(t), e && this._rebalance(e) } s.dispose() } _rotateLeft(t) { const e = t.parent, s = t.isLeftChild(), i = t.right; i && (t.right = i.left, i.left = t), null !== e ? s ? e.left = i : e.right = i : this._setRoot(i) } _rotateRight(t) { const e = t.parent, s = t.isLeftChild(), i = t.left; i && (t.left = i.right, i.right = t), null !== e ? s ? e.left = i : e.right = i : this._setRoot(i) } _rebalance(t) { var e = t.getBalance(); 1 < e && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : e < -1 && t.right && (0 < t.right.getBalance() ? this._rotateRight(t.right) : this._rotateLeft(t)) } get(t) { if (null !== this._root) { var s = []; if (this._root.search(t, s), 0 < s.length) { let e = s[0]; for (let t = 1; t < s.length; t++)s[t].low > e.low && (e = s[t]); return e.event } } return null } forEach(e) { if (null !== this._root) { const s = []; this._root.traverse(t => s.push(t)), s.forEach(t => { t.event && e(t.event) }) } return this } forEachAtTime(t, e) { if (null !== this._root) { const s = []; this._root.search(t, s), s.forEach(t => { t.event && e(t.event) }) } return this } forEachFrom(t, e) { if (null !== this._root) { const s = []; this._root.searchAfter(t, s), s.forEach(t => { t.event && e(t.event) }) } return this } dispose() { return super.dispose(), null !== this._root && this._root.traverse(t => t.dispose()), this._root = null, this } } class jd { constructor(t, e, s) { this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = s, this.low = t, this.high = e, this.max = this.high } insert(t) { t.low <= this.low ? null === this.left ? this.left = t : this.left.insert(t) : null === this.right ? this.right = t : this.right.insert(t) } search(t, e) { t > this.max || (null !== this.left && this.left.search(t, e), this.low <= t && this.high > t && e.push(this), this.low > t || null !== this.right && this.right.search(t, e)) } searchAfter(t, e) { this.low >= t && (e.push(this), null !== this.left && this.left.searchAfter(t, e)), null !== this.right && this.right.searchAfter(t, e) } traverse(t) { t(this), null !== this.left && this.left.traverse(t), null !== this.right && this.right.traverse(t) } updateHeight() { null !== this.left && null !== this.right ? this.height = Math.max(this.left.height, this.right.height) + 1 : null !== this.right ? this.height = this.right.height + 1 : null !== this.left ? this.height = this.left.height + 1 : this.height = 0 } updateMax() { this.max = this.high, null !== this.left && (this.max = Math.max(this.max, this.left.max)), null !== this.right && (this.max = Math.max(this.max, this.right.max)) } getBalance() { let t = 0; return null !== this.left && null !== this.right ? t = this.left.height - this.right.height : null !== this.left ? t = this.left.height + 1 : null !== this.right && (t = -(this.right.height + 1)), t } isLeftChild() { return null !== this.parent && this.parent.left === this } get left() { return this._left } set left(t) { null !== (this._left = t) && (t.parent = this), this.updateHeight(), this.updateMax() } get right() { return this._right } set right(t) { null !== (this._right = t) && (t.parent = this), this.updateHeight(), this.updateMax() } dispose() { this.parent = null, this._left = null, this._right = null, this.event = null } } class Ld extends Wp { constructor(t) { super(), this.name = "TimelineValue", this._timeline = new Yp({ memory: 10 }), this._initialValue = t } set(t, e) { return this._timeline.add({ value: t, time: e }), this } get(t) { t = this._timeline.get(t); return t ? t.value : this._initialValue } } class zd extends A { constructor() { super(g(zd.getDefaults(), arguments, ["context"])) } connect(t, e = 0, s = 0) { return Ad(this, t, e, s), this } } class Wd extends zd { constructor() { var t = g(Wd.getDefaults(), arguments, ["mapping", "length"]); super(t), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper, d(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : vp(t.mapping) && this.setMap(t.mapping, t.length) } static getDefaults() { return Object.assign(O.getDefaults(), { length: 1024 }) } setMap(s, i = 1024) { const n = new Float32Array(i); for (let t = 0, e = i; t < e; t++) { const i = t / (e - 1) * 2 - 1; n[t] = s(i, t) } return this.curve = n, this } get curve() { return this._shaper.curve } set curve(t) { this._shaper.curve = t } get oversample() { return this._shaper.oversample } set oversample(e) { l(["none", "2x", "4x"].some(t => t.includes(e)), "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = e } dispose() { return super.dispose(), this._shaper.disconnect(), this } } class Bd extends zd { constructor() { var t = g(Bd.getDefaults(), arguments, ["value"]); super(t), this.name = "Pow", this._exponentScaler = this.input = this.output = new Wd({ context: this.context, mapping: this._expFunc(t.value), length: 8192 }), this._exponent = t.value } static getDefaults() { return Object.assign(zd.getDefaults(), { value: 1 }) } _expFunc(e) { return t => Math.pow(Math.abs(t), e) } get value() { return this._exponent } set value(t) { this._exponent = t, this._exponentScaler.setMap(this._expFunc(this._exponent)) } dispose() { return super.dispose(), this._exponentScaler.dispose(), this } } class Ud { constructor(t, e) { this.id = Ud._eventId++, this._remainderTime = 0; e = Object.assign(Ud.getDefaults(), e); this.transport = t, this.callback = e.callback, this._once = e.once, this.time = Math.floor(e.time), this._remainderTime = e.time - this.time } static getDefaults() { return { callback: x, once: !1, time: 0 } } get floatTime() { return this.time + this._remainderTime } invoke(t) { var e; this.callback && (e = this.transport.bpm.getDurationOfTicks(1, t), this.callback(t + this._remainderTime * e), this._once && this.transport.clear(this.id)) } dispose() { return this.callback = void 0, this } } Ud._eventId = 0; class Gd extends Ud { constructor(t, e) { super(t, e), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this); t = Object.assign(Gd.getDefaults(), e); this.duration = t.duration, this._interval = t.interval, this._nextTick = t.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.transport.on("ticks", this._boundRestart), this.context = this.transport.context, this._restart() } static getDefaults() { return Object.assign({}, Ud.getDefaults(), { duration: 1 / 0, interval: 1, once: !1 }) } invoke(t) { this._createEvents(t), super.invoke(t) } _createEvent() { return Qp(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new D(this.context, this._nextTick).toSeconds()) : -1 } _createEvents(t) { Qp(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new D(this.context, this._nextTick).toSeconds())) } _restart(t) { this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.floatTime; t = this.transport.getTicksAtTime(t); Up(t, this.time) && (this._nextTick = this.floatTime + Math.ceil((t - this.floatTime) / this._interval) * this._interval), this._currentId = this._createEvent(), this._nextTick += this._interval, this._nextId = this._createEvent() } dispose() { return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this.transport.off("ticks", this._boundRestart), this } } class Qd extends S { constructor() { var t = g(Qd.getDefaults(), arguments); super(t), this.name = "Transport", this._loop = new Ld(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Yp, this._repeatedEvents = new Pd, this._syncedSignals = [], this._swingAmount = 0, this._ppq = t.ppq, this._clock = new Md({ callback: this._processTick.bind(this), context: this.context, frequency: 0, units: "bpm" }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = t.ppq, this.bpm.setValueAtTime(t.bpm, 0), y(this, "bpm"), this._timeSignature = t.timeSignature, this._swingTicks = t.ppq / 2 } static getDefaults() { return Object.assign(S.getDefaults(), { bpm: 120, loopEnd: "4m", loopStart: 0, ppq: 192, swing: 0, swingSubdivision: "8n", timeSignature: 4 }) } _processTick(e, t) { var s; this._loop.get(e) && t >= this._loopEnd && (this.emit("loopEnd", e), this._clock.setTicksAtTime(this._loopStart, e), t = this._loopStart, this.emit("loopStart", e, this._clock.getSecondsAtTime(e)), this.emit("loop", e)), 0 < this._swingAmount && t % this._ppq != 0 && t % (2 * this._swingTicks) != 0 && (s = t % (2 * this._swingTicks) / (2 * this._swingTicks), s = Math.sin(s * Math.PI) * this._swingAmount, e += new D(this.context, 2 * this._swingTicks / 3).toSeconds() * s), Cp(!0), this._timeline.forEachAtTime(t, t => t.invoke(e)), Cp(!1) } schedule(t, e) { t = new Ud(this, { callback: t, time: new T(this.context, e).toTicks() }); return this._addEvent(t, this._timeline) } scheduleRepeat(t, e, s, i = 1 / 0) { t = new Gd(this, { callback: t, duration: new md(this.context, i).toTicks(), interval: new md(this.context, e).toTicks(), time: new T(this.context, s).toTicks() }); return this._addEvent(t, this._repeatedEvents) } scheduleOnce(t, e) { t = new Ud(this, { callback: t, once: !0, time: new T(this.context, e).toTicks() }); return this._addEvent(t, this._timeline) } clear(t) { if (this._scheduledEvents.hasOwnProperty(t)) { const e = this._scheduledEvents[t.toString()]; e.timeline.remove(e.event), e.event.dispose(), delete this._scheduledEvents[t.toString()] } return this } _addEvent(t, e) { return this._scheduledEvents[t.id.toString()] = { event: t, timeline: e }, e.add(t), t.id } cancel(t = 0) { t = this.toTicks(t); return this._timeline.forEachFrom(t, t => this.clear(t.id)), this._repeatedEvents.forEachFrom(t, t => this.clear(t.id)), this } _bindClockEvents() { this._clock.on("start", (t, e) => { e = new D(this.context, e).toSeconds(), this.emit("start", t, e) }), this._clock.on("stop", t => { this.emit("stop", t) }), this._clock.on("pause", t => { this.emit("pause", t) }) } get state() { return this._clock.getStateAtTime(this.now()) } start(t, e) { let s; return this.context.resume(), o(e) && (s = this.toTicks(e)), this._clock.start(t, s), this } stop(t) { return this._clock.stop(t), this } pause(t) { return this._clock.pause(t), this } toggle(t) { return t = this.toSeconds(t), "started" !== this._clock.getStateAtTime(t) ? this.start(t) : this.stop(t), this } get timeSignature() { return this._timeSignature } set timeSignature(t) { d(t) && (t = t[0] / t[1] * 4), this._timeSignature = t } get loopStart() { return new md(this.context, this._loopStart, "i").toSeconds() } set loopStart(t) { this._loopStart = this.toTicks(t) } get loopEnd() { return new md(this.context, this._loopEnd, "i").toSeconds() } set loopEnd(t) { this._loopEnd = this.toTicks(t) } get loop() { return this._loop.get(this.now()) } set loop(t) { this._loop.set(t, this.now()) } setLoopPoints(t, e) { return this.loopStart = t, this.loopEnd = e, this } get swing() { return this._swingAmount } set swing(t) { this._swingAmount = t } get swingSubdivision() { return new D(this.context, this._swingTicks).toNotation() } set swingSubdivision(t) { this._swingTicks = this.toTicks(t) } get position() { var t = this.now(), t = this._clock.getTicksAtTime(t); return new D(this.context, t).toBarsBeatsSixteenths() } set position(t) { t = this.toTicks(t); this.ticks = t } get seconds() { return this._clock.seconds } set seconds(t) { var e = this.now(), t = this._clock.frequency.timeToTicks(t, e); this.ticks = t } get progress() { var t; return this.loop ? (t = this.now(), (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart)) : 0 } get ticks() { return this._clock.ticks } set ticks(t) { var e, s; this._clock.ticks !== t && (e = this.now(), "started" === this.state ? (s = this._clock.getTicksAtTime(e), s = e + this._clock.frequency.getDurationOfTicks(Math.ceil(s) - s, e), this.emit("stop", s), this._clock.setTicksAtTime(t, s), this.emit("start", s, this._clock.getSecondsAtTime(s))) : (this.emit("ticks", e), this._clock.setTicksAtTime(t, e))) } getTicksAtTime(t) { return this._clock.getTicksAtTime(t) } getSecondsAtTime(t) { return this._clock.getSecondsAtTime(t) } get PPQ() { return this._clock.frequency.multiplier } set PPQ(t) { this._clock.frequency.multiplier = t } nextSubdivision(t) { if (t = this.toTicks(t), "started" !== this.state) return 0; var e = this.now(), t = t - this.getTicksAtTime(e) % t; return this._clock.nextTickTime(t, e) } syncSignal(t, e) { const s = this.now(); let i = this.bpm, n = 1 / (60 / i.getValueAtTime(s) / this.PPQ), r = []; if ("time" === t.units) { const t = 1 / 64 / n, e = new C(t), s = new Bd(-1), o = new C(t); i.chain(e, s, o), i = o, n = 1 / n, r = [e, s, o] } e = e || (0 !== t.getValueAtTime(s) ? t.getValueAtTime(s) / n : 0); const o = new C(e); return i.connect(o), o.connect(t._param), r.push(o), this._syncedSignals.push({ initial: t.value, nodes: r, signal: t }), t.value = 0, this } unsyncSignal(e) { for (let t = this._syncedSignals.length - 1; 0 <= t; t--) { const s = this._syncedSignals[t]; s.signal === e && (s.nodes.forEach(t => t.dispose()), s.signal.value = s.initial, this._syncedSignals.splice(t, 1)) } return this } dispose() { return super.dispose(), this._clock.dispose(), id(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this } } td.mixin(Qd), $p(t => { t.transport = new Qd({ context: t }) }), Kp(t => { t.transport.dispose() }); class M extends A { constructor(t) { super(t), this.input = void 0, this._state = new xd("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = x, this._syncedStop = x, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new Rd({ context: this.context, mute: t.mute, volume: t.volume }), this.volume = this._volume.volume, y(this, "volume"), this.onstop = t.onstop } static getDefaults() { return Object.assign(A.getDefaults(), { mute: !1, onstop: x, volume: 0 }) } get state() { return this._synced ? "started" === this.context.transport.state ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now()) } get mute() { return this._volume.mute } set mute(t) { this._volume.mute = t } _clampToCurrentTime(t) { return this._synced ? t : Math.max(t, this.context.currentTime) } start(t, e, s) { var i = gp(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t), i = this._clampToCurrentTime(i); if (this._synced || "started" !== this._state.getValueAtTime(i)) if (this.log("start", i), this._state.setStateAtTime("started", i), this._synced) { const t = this._state.get(i); t && (t.offset = this.toSeconds(zp(e, 0)), t.duration = s ? this.toSeconds(s) : void 0); var n = this.context.transport.schedule(t => { this._start(t, e, s) }, i); this._scheduled.push(n), "started" === this.context.transport.state && this.context.transport.getSecondsAtTime(this.immediate()) > i && this._syncedStart(this.now(), this.context.transport.seconds) } else Sp(this.context), this._start(i, e, s); else l(Up(i, this._state.get(i).time), "Start time must be strictly greater than previous start time"), this._state.cancel(i), this._state.setStateAtTime("started", i), this.log("restart", i), this.restart(i, e, s); return this } stop(t) { var e = gp(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t), e = this._clampToCurrentTime(e); if ("started" === this._state.getValueAtTime(e) || o(this._state.getNextState("started", e))) { if (this.log("stop", e), this._synced) { const t = this.context.transport.schedule(this._stop.bind(this), e); this._scheduled.push(t) } else this._stop(e); this._state.cancel(e), this._state.setStateAtTime("stopped", e) } return this } restart(t, e, s) { return t = this.toSeconds(t), "started" === this._state.getValueAtTime(t) && (this._state.cancel(t), this._restart(t, e, s)), this } sync() { return this._synced || (this._synced = !0, this._syncedStart = (e, s) => { if (Up(s, 0)) { var i = this._state.get(s); if (i && "started" === i.state && i.time !== s) { s = s - this.toSeconds(i.time); let t; i.duration && (t = this.toSeconds(i.duration) - s), this._start(e, this.toSeconds(i.offset) + s, t) } } }, this._syncedStop = t => { var e = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0)); "started" === this._state.getValueAtTime(e) && this._stop(t) }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this } unsync() { return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach(t => this.context.transport.clear(t)), this._scheduled = [], this._state.cancel(0), this._stop(0), this } dispose() { return super.dispose(), this.onstop = x, this.unsync(), this._volume.dispose(), this._state.dispose(), this } } class Zd extends Sd { constructor() { var t = g(Zd.getDefaults(), arguments, ["url", "onload"]); super(t), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1, bd(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new k({ context: this.context, param: this._source.playbackRate, units: "positive", value: t.playbackRate }), this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this._buffer = new w(t.url, t.onload, t.onerror), this._internalChannels.push(this._source) } static getDefaults() { return Object.assign(Sd.getDefaults(), { url: new w, loop: !1, loopEnd: 0, loopStart: 0, onload: x, onerror: x, playbackRate: 1 }) } get fadeIn() { return this._fadeIn } set fadeIn(t) { this._fadeIn = t } get fadeOut() { return this._fadeOut } set fadeOut(t) { this._fadeOut = t } get curve() { return this._curve } set curve(t) { this._curve = t } start(t, e, s, i = 1) { l(this.buffer.loaded, "buffer is either not set or not loaded"); t = this.toSeconds(t); this._startGain(t, i), e = this.loop ? zp(e, this.loopStart) : zp(e, 0); let n = Math.max(this.toSeconds(e), 0); if (this.loop) { const t = this.toSeconds(this.loopEnd) || this.buffer.duration, e = this.toSeconds(this.loopStart), s = t - e; Zp(n = Gp(n, t) ? (n - e) % s + e : n, this.buffer.duration) && (n = 0) } return this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, Qp(n, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(t, n)), o(s) && (i = this.toSeconds(s), i = Math.max(i, 0), this.stop(t + i)), this } _stopSource(t) { !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(t)), this._onended()) } get loopStart() { return this._source.loopStart } set loopStart(t) { this._source.loopStart = this.toSeconds(t) } get loopEnd() { return this._source.loopEnd } set loopEnd(t) { this._source.loopEnd = this.toSeconds(t) } get buffer() { return this._buffer } set buffer(t) { this._buffer.set(t) } get loop() { return this._source.loop } set loop(t) { this._source.loop = t, this._sourceStarted && this.cancelStop() } dispose() { return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this } } class Xd extends M { constructor() { var t = g(Xd.getDefaults(), arguments, ["type"]); super(t), this.name = "Noise", this._source = null, this._playbackRate = t.playbackRate, this.type = t.type, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut } static getDefaults() { return Object.assign(M.getDefaults(), { fadeIn: 0, fadeOut: 0, playbackRate: 1, type: "white" }) } get type() { return this._type } set type(t) { if (l(t in $d, "Noise: invalid type: " + t), this._type !== t && (this._type = t, "started" === this.state)) { const t = this.now(); this._stop(t), this._start(t) } } get playbackRate() { return this._playbackRate } set playbackRate(t) { this._playbackRate = t, this._source && (this._source.playbackRate.value = t) } _start(t) { var e = $d[this._type]; this._source = new Zd({ url: e, context: this.context, fadeIn: this._fadeIn, fadeOut: this._fadeOut, loop: !0, onended: () => this.onstop(this), playbackRate: this._playbackRate }).connect(this.output), this._source.start(this.toSeconds(t), Math.random() * (e.duration - .001)) } _stop(t) { this._source && (this._source.stop(this.toSeconds(t)), this._source = null) } get fadeIn() { return this._fadeIn } set fadeIn(t) { this._fadeIn = t, this._source && (this._source.fadeIn = this._fadeIn) } get fadeOut() { return this._fadeOut } set fadeOut(t) { this._fadeOut = t, this._source && (this._source.fadeOut = this._fadeOut) } _restart(t) { this._stop(t), this._start(t) } dispose() { return super.dispose(), this._source && this._source.disconnect(), this } } const Yd = 220500, Hd = { brown: null, pink: null, white: null }, $d = { get brown() { if (!Hd.brown) { const i = []; for (let t = 0; t < 2; t++) { const n = new Float32Array(Yd); i[t] = n; let e = 0; for (let t = 0; t < Yd; t++) { var s = 2 * Math.random() - 1; n[t] = (e + .02 * s) / 1.02, e = n[t], n[t] *= 3.5 } } Hd.brown = (new w).fromArray(i) } return Hd.brown }, get pink() { if (!Hd.pink) { const c = []; for (let t = 0; t < 2; t++) { const l = new Float32Array(Yd); let e, s, i, n, r, o, a; c[t] = l; for (let t = e = s = i = n = r = o = a = 0; t < Yd; t++) { var h = 2 * Math.random() - 1; e = .99886 * e + .0555179 * h, s = .99332 * s + .0750759 * h, i = .969 * i + .153852 * h, n = .8665 * n + .3104856 * h, r = .55 * r + .5329522 * h, o = -.7616 * o - .016898 * h, l[t] = e + s + i + n + r + o + a + .5362 * h, l[t] *= .11, a = .115926 * h } } Hd.pink = (new w).fromArray(c) } return Hd.pink }, get white() { if (!Hd.white) { const e = []; for (let t = 0; t < 2; t++) { const s = new Float32Array(Yd); e[t] = s; for (let t = 0; t < Yd; t++)s[t] = 2 * Math.random() - 1 } Hd.white = (new w).fromArray(e) } return Hd.white } }; class Jd extends A { constructor() { var t = g(Jd.getDefaults(), arguments, ["volume"]); super(t), this.name = "UserMedia", this._volume = this.output = new Rd({ context: this.context, volume: t.volume }), this.volume = this._volume.volume, y(this, "volume"), this.mute = t.mute } static getDefaults() { return Object.assign(A.getDefaults(), { mute: !1, volume: 0 }) } open(i) { return _(this, void 0, void 0, function* () { l(Jd.supported, "UserMedia is not supported"), "started" === this.state && this.close(); const t = yield Jd.enumerateDevices(), e = (yp(i) ? this._device = t[i] : (this._device = t.find(t => t.label === i || t.deviceId === i), !this._device && 0 < t.length && (this._device = t[0]), l(o(this._device), "No matching device " + i)), { audio: { echoCancellation: !1, sampleRate: this.context.sampleRate, noiseSuppression: !1, mozNoiseSuppression: !1 } }); this._device && (e.audio.deviceId = this._device.deviceId); var s = yield navigator.mediaDevices.getUserMedia(e); if (!this._stream) { this._stream = s; const i = this.context.createMediaStreamSource(s); bd(i, this.output), this._mediaStream = i } return this }) } close() { return this._stream && this._mediaStream && (this._stream.getAudioTracks().forEach(t => { t.stop() }), this._stream = void 0, this._mediaStream.disconnect(), this._mediaStream = void 0), this._device = void 0, this } static enumerateDevices() { return _(this, void 0, void 0, function* () { return (yield navigator.mediaDevices.enumerateDevices()).filter(t => "audioinput" === t.kind) }) } get state() { return this._stream && this._stream.active ? "started" : "stopped" } get deviceId() { return this._device ? this._device.deviceId : void 0 } get groupId() { return this._device ? this._device.groupId : void 0 } get label() { return this._device ? this._device.label : void 0 } get mute() { return this._volume.mute } set mute(t) { this._volume.mute = t } dispose() { return super.dispose(), this.close(), this._volume.dispose(), this.volume.dispose(), this } static get supported() { return o(navigator.mediaDevices) && o(navigator.mediaDevices.getUserMedia) } } function Kd(s, i) { return _(this, void 0, void 0, function* () { const t = i / s.context.sampleRate, e = new nd(1, t, s.context.sampleRate); return new s.constructor(Object.assign(s.get(), { frequency: 2 / t, detune: 0, context: e })).toDestination().start(0), (yield e.render()).getChannelData(0) }) } class tf extends Sd { constructor() { var t = g(tf.getDefaults(), arguments, ["frequency", "type"]); super(t), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator], bd(this._oscillator, this._gainNode), this.type = t.type, this.frequency = new k({ context: this.context, param: this._oscillator.frequency, units: "frequency", value: t.frequency }), this.detune = new k({ context: this.context, param: this._oscillator.detune, units: "cents", value: t.detune }), y(this, ["frequency", "detune"]) } static getDefaults() { return Object.assign(Sd.getDefaults(), { detune: 0, frequency: 440, type: "sine" }) } start(t) { t = this.toSeconds(t); return this.log("start", t), this._startGain(t), this._oscillator.start(t), this } _stopSource(t) { this._oscillator.stop(t) } setPeriodicWave(t) { return this._oscillator.setPeriodicWave(t), this } get type() { return this._oscillator.type } set type(t) { this._oscillator.type = t } dispose() { return super.dispose(), "started" === this.state && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this } } class E extends M { constructor() { const t = g(E.getDefaults(), arguments, ["frequency", "type"]); super(t), this.name = "Oscillator", this._oscillator = null, this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency }), y(this, "frequency"), this.detune = new O({ context: this.context, units: "cents", value: t.detune }), y(this, "detune"), this._partials = t.partials, this._partialCount = t.partialCount, this._type = t.type, t.partialCount && "custom" !== t.type && (this._type = this.baseType + t.partialCount.toString()), this.phase = t.phase } static getDefaults() { return Object.assign(M.getDefaults(), { detune: 0, frequency: 440, partialCount: 0, partials: [], phase: 0, type: "sine" }) } _start(t) { var t = this.toSeconds(t), e = new tf({ context: this.context, onended: () => this.onstop(this) }); this._oscillator = e, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(t) } _stop(t) { t = this.toSeconds(t); this._oscillator && this._oscillator.stop(t) } _restart(t) { t = this.toSeconds(t); return this.log("restart", t), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(t), this } syncFrequency() { return this.context.transport.syncSignal(this.frequency), this } unsyncFrequency() { return this.context.transport.unsyncSignal(this.frequency), this } _getCachedPeriodicWave() { if ("custom" === this._type) return E._periodicWaveCache.find(t => { return t.phase === this._phase && (t = t.partials, s = this._partials, t.length === s.length && t.every((t, e) => s[e] === t)); var s }); var t = E._periodicWaveCache.find(t => t.type === this._type && t.phase === this._phase); return this._partialCount = t ? t.partialCount : this._partialCount, t } get type() { return this._type } set type(t) { this._type = t; const e = -1 !== ["sine", "square", "sawtooth", "triangle"].indexOf(t); if (0 === this._phase && e) this._wave = void 0, this._partialCount = 0, null !== this._oscillator && (this._oscillator.type = t); else { const e = this._getCachedPeriodicWave(); if (o(e)) { const { partials: t, wave: s } = e; this._wave = s, this._partials = t, null !== this._oscillator && this._oscillator.setPeriodicWave(this._wave) } else { const [e, i] = this._getRealImaginary(t, this._phase), n = this.context.createPeriodicWave(e, i); this._wave = n, null !== this._oscillator && this._oscillator.setPeriodicWave(this._wave), E._periodicWaveCache.push({ imag: i, partialCount: this._partialCount, partials: this._partials, phase: this._phase, real: e, type: this._type, wave: this._wave }), 100 < E._periodicWaveCache.length && E._periodicWaveCache.shift() } } } get baseType() { return this._type.replace(this.partialCount.toString(), "") } set baseType(t) { this.partialCount && "custom" !== this._type && "custom" !== t ? this.type = t + this.partialCount : this.type = t } get partialCount() { return this._partialCount } set partialCount(t) { f(t, 0); let s = this._type; var e = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type); if (e && (s = e[1]), "custom" !== this._type) this.type = 0 === t ? s : s + t.toString(); else { const s = new Float32Array(t); this._partials.forEach((t, e) => s[e] = t), this._partials = Array.from(s), this.type = this._type } } _getRealImaginary(s, i) { let n = 2048; const r = new Float32Array(n), o = new Float32Array(n); let a = 1; if ("custom" === s) { if (a = this._partials.length + 1, this._partialCount = this._partials.length, n = a, 0 === this._partials.length) return [r, o] } else { const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(s); i ? (a = parseInt(i[2], 10) + 1, this._partialCount = parseInt(i[2], 10), s = i[1], a = Math.max(a, 2), n = a) : this._partialCount = 0, this._partials = [] } for (let e = 1; e < n; ++e) { const n = 2 / (e * Math.PI); let t; switch (s) { case "sine": t = e <= a ? 1 : 0, this._partials[e - 1] = t; break; case "square": t = 1 & e ? 2 * n : 0, this._partials[e - 1] = t; break; case "sawtooth": t = n * (1 & e ? 1 : -1), this._partials[e - 1] = t; break; case "triangle": t = 1 & e ? n * n * 2 * (e - 1 >> 1 & 1 ? -1 : 1) : 0, this._partials[e - 1] = t; break; case "custom": t = this._partials[e - 1]; break; default: throw new TypeError("Oscillator: invalid type: " + s) }0 !== t ? (r[e] = -t * Math.sin(i * e), o[e] = t * Math.cos(i * e)) : (r[e] = 0, o[e] = 0) } return [r, o] } _inverseFFT(e, s, i) { let n = 0; var r = e.length; for (let t = 0; t < r; t++)n += e[t] * Math.cos(t * i) + s[t] * Math.sin(t * i); return n } getInitialValue() { var [e, s] = this._getRealImaginary(this._type, 0); let i = 0; var n = 2 * Math.PI; for (let t = 0; t < 32; t++)i = Math.max(this._inverseFFT(e, s, t / 32 * n), i); return Xp(-this._inverseFFT(e, s, this._phase) / i, -1, 1) } get partials() { return this._partials.slice(0, this.partialCount) } set partials(t) { this._partials = t, this._partialCount = this._partials.length, t.length && (this.type = "custom") } get phase() { return this._phase * (180 / Math.PI) } set phase(t) { this._phase = t * Math.PI / 180, this.type = this._type } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), null !== this._oscillator && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this } } E._periodicWaveCache = []; class ef extends zd { constructor() { super(...arguments), this.name = "AudioToGain", this._norm = new Wd({ context: this.context, mapping: t => (t + 1) / 2 }), this.input = this._norm, this.output = this._norm } dispose() { return super.dispose(), this._norm.dispose(), this } } class q extends O { constructor() { var t = g(q.getDefaults(), arguments, ["value"]); super(t), this.name = "Multiply", this.override = !1, this._mult = this.input = this.output = new C({ context: this.context, minValue: t.minValue, maxValue: t.maxValue }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(t.value, 0) } static getDefaults() { return Object.assign(O.getDefaults(), { value: 0 }) } dispose() { return super.dispose(), this._mult.dispose(), this } } class sf extends M { constructor() { var t = g(sf.getDefaults(), arguments, ["frequency", "type", "modulationType"]); super(t), this.name = "AMOscillator", this._modulationScale = new ef({ context: this.context }), this._modulationNode = new C({ context: this.context }), this._carrier = new E({ context: this.context, detune: t.detune, frequency: t.frequency, onstop: () => this.onstop(this), phase: t.phase, type: t.type }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new E({ context: this.context, phase: t.phase, type: t.modulationType }), this.harmonicity = new q({ context: this.context, units: "positive", value: t.harmonicity }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), y(this, ["frequency", "detune", "harmonicity"]) } static getDefaults() { return Object.assign(E.getDefaults(), { harmonicity: 1, modulationType: "square" }) } _start(t) { this._modulator.start(t), this._carrier.start(t) } _stop(t) { this._modulator.stop(t), this._carrier.stop(t) } _restart(t) { this._modulator.restart(t), this._carrier.restart(t) } get type() { return this._carrier.type } set type(t) { this._carrier.type = t } get baseType() { return this._carrier.baseType } set baseType(t) { this._carrier.baseType = t } get partialCount() { return this._carrier.partialCount } set partialCount(t) { this._carrier.partialCount = t } get modulationType() { return this._modulator.type } set modulationType(t) { this._modulator.type = t } get phase() { return this._carrier.phase } set phase(t) { this._carrier.phase = t, this._modulator.phase = t } get partials() { return this._carrier.partials } set partials(t) { this._carrier.partials = t } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this } } class nf extends M { constructor() { var t = g(nf.getDefaults(), arguments, ["frequency", "type", "modulationType"]); super(t), this.name = "FMOscillator", this._modulationNode = new C({ context: this.context, gain: 0 }), this._carrier = new E({ context: this.context, detune: t.detune, frequency: 0, onstop: () => this.onstop(this), phase: t.phase, type: t.type }), this.detune = this._carrier.detune, this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency }), this._modulator = new E({ context: this.context, phase: t.phase, type: t.modulationType }), this.harmonicity = new q({ context: this.context, units: "positive", value: t.harmonicity }), this.modulationIndex = new q({ context: this.context, units: "positive", value: t.modulationIndex }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), y(this, ["modulationIndex", "frequency", "detune", "harmonicity"]) } static getDefaults() { return Object.assign(E.getDefaults(), { harmonicity: 1, modulationIndex: 2, modulationType: "square" }) } _start(t) { this._modulator.start(t), this._carrier.start(t) } _stop(t) { this._modulator.stop(t), this._carrier.stop(t) } _restart(t) { return this._modulator.restart(t), this._carrier.restart(t), this } get type() { return this._carrier.type } set type(t) { this._carrier.type = t } get baseType() { return this._carrier.baseType } set baseType(t) { this._carrier.baseType = t } get partialCount() { return this._carrier.partialCount } set partialCount(t) { this._carrier.partialCount = t } get modulationType() { return this._modulator.type } set modulationType(t) { this._modulator.type = t } get phase() { return this._carrier.phase } set phase(t) { this._carrier.phase = t, this._modulator.phase = t } get partials() { return this._carrier.partials } set partials(t) { this._carrier.partials = t } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this } } class rf extends M { constructor() { var t = g(rf.getDefaults(), arguments, ["frequency", "width"]); super(t), this.name = "PulseOscillator", this._widthGate = new C({ context: this.context, gain: 0 }), this._thresh = new Wd({ context: this.context, mapping: t => t <= 0 ? -1 : 1 }), this.width = new O({ context: this.context, units: "audioRange", value: t.width }), this._triangle = new E({ context: this.context, detune: t.detune, frequency: t.frequency, onstop: () => this.onstop(this), phase: t.phase, type: "triangle" }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), y(this, ["width", "frequency", "detune"]) } static getDefaults() { return Object.assign(M.getDefaults(), { detune: 0, frequency: 440, phase: 0, type: "pulse", width: .2 }) } _start(t) { t = this.toSeconds(t), this._triangle.start(t), this._widthGate.gain.setValueAtTime(1, t) } _stop(t) { t = this.toSeconds(t), this._triangle.stop(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(0, t) } _restart(t) { this._triangle.restart(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(1, t) } get phase() { return this._triangle.phase } set phase(t) { this._triangle.phase = t } get type() { return "pulse" } get baseType() { return "pulse" } get partials() { return [] } get partialCount() { return 0 } set carrierType(t) { this._triangle.type = t } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this } } class of extends M { constructor() { var t = g(of.getDefaults(), arguments, ["frequency", "type", "spread"]); super(t), this.name = "FatOscillator", this._oscillators = [], this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency }), this.detune = new O({ context: this.context, units: "cents", value: t.detune }), this._spread = t.spread, this._type = t.type, this._phase = t.phase, this._partials = t.partials, this._partialCount = t.partialCount, this.count = t.count, y(this, ["frequency", "detune"]) } static getDefaults() { return Object.assign(E.getDefaults(), { count: 3, spread: 20, type: "sawtooth" }) } _start(e) { e = this.toSeconds(e), this._forEach(t => t.start(e)) } _stop(e) { e = this.toSeconds(e), this._forEach(t => t.stop(e)) } _restart(e) { this._forEach(t => t.restart(e)) } _forEach(e) { for (let t = 0; t < this._oscillators.length; t++)e(this._oscillators[t], t) } get type() { return this._type } set type(e) { this._type = e, this._forEach(t => t.type = e) } get spread() { return this._spread } set spread(t) { if (this._spread = t, 1 < this._oscillators.length) { const s = -t / 2, i = t / (this._oscillators.length - 1); this._forEach((t, e) => t.detune.value = s + i * e) } } get count() { return this._oscillators.length } set count(e) { if (f(e, 1), this._oscillators.length !== e) { this._forEach(t => t.dispose()), this._oscillators = []; for (let t = 0; t < e; t++) { const s = new E({ context: this.context, volume: -6 - 1.1 * e, type: this._type, phase: this._phase + t / e * 360, partialCount: this._partialCount, onstop: 0 === t ? () => this.onstop(this) : x }); "custom" === this.type && (s.partials = this._partials), this.frequency.connect(s.frequency), this.detune.connect(s.detune), s.detune.overridden = !1, s.connect(this.output), this._oscillators[t] = s } this.spread = this._spread, "started" === this.state && this._forEach(t => t.start()) } } get phase() { return this._phase } set phase(t) { this._phase = t, this._forEach((t, e) => t.phase = this._phase + e / this.count * 360) } get baseType() { return this._oscillators[0].baseType } set baseType(e) { this._forEach(t => t.baseType = e), this._type = this._oscillators[0].type } get partials() { return this._oscillators[0].partials } set partials(e) { this._partials = e, this._partialCount = this._partials.length, e.length && (this._type = "custom", this._forEach(t => t.partials = e)) } get partialCount() { return this._oscillators[0].partialCount } set partialCount(e) { this._partialCount = e, this._forEach(t => t.partialCount = e), this._type = this._oscillators[0].type } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach(t => t.dispose()), this } } class af extends M { constructor() { var t = g(af.getDefaults(), arguments, ["frequency", "modulationFrequency"]); super(t), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new q({ context: this.context, value: 2 }), this._pulse = new rf({ context: this.context, frequency: t.modulationFrequency }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new E({ context: this.context, detune: t.detune, frequency: t.frequency, onstop: () => this.onstop(this), phase: t.phase }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), y(this, ["modulationFrequency", "frequency", "detune"]) } static getDefaults() { return Object.assign(M.getDefaults(), { detune: 0, frequency: 440, modulationFrequency: .4, phase: 0, type: "pwm" }) } _start(t) { t = this.toSeconds(t), this._modulator.start(t), this._pulse.start(t) } _stop(t) { t = this.toSeconds(t), this._modulator.stop(t), this._pulse.stop(t) } _restart(t) { this._modulator.restart(t), this._pulse.restart(t) } get type() { return "pwm" } get baseType() { return "pwm" } get partials() { return [] } get partialCount() { return 0 } get phase() { return this._modulator.phase } set phase(t) { this._modulator.phase = t } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this } } const hf = { am: sf, fat: of, fm: nf, oscillator: E, pulse: rf, pwm: af }; class cf extends M { constructor() { var t = g(cf.getDefaults(), arguments, ["frequency", "type"]); super(t), this.name = "OmniOscillator", this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency }), this.detune = new O({ context: this.context, units: "cents", value: t.detune }), y(this, ["frequency", "detune"]), this.set(t) } static getDefaults() { return Object.assign(E.getDefaults(), nf.getDefaults(), sf.getDefaults(), of.getDefaults(), rf.getDefaults(), af.getDefaults()) } _start(t) { this._oscillator.start(t) } _stop(t) { this._oscillator.stop(t) } _restart(t) { return this._oscillator.restart(t), this } get type() { let t = ""; return (t = ["am", "fm", "fat"].some(t => this._sourceType === t) ? this._sourceType : t) + this._oscillator.type } set type(t) { "fm" === t.substr(0, 2) ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : "am" === t.substr(0, 2) ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : "fat" === t.substr(0, 3) ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(3)) : "pwm" === t ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : "pulse" === t ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = t) } get partials() { return this._oscillator.partials } set partials(t) { this._getOscType(this._oscillator, "pulse") || this._getOscType(this._oscillator, "pwm") || (this._oscillator.partials = t) } get partialCount() { return this._oscillator.partialCount } set partialCount(t) { this._getOscType(this._oscillator, "pulse") || this._getOscType(this._oscillator, "pwm") || (this._oscillator.partialCount = t) } set(t) { return Reflect.has(t, "type") && t.type && (this.type = t.type), super.set(t), this } _createNewOscillator(t) { if (t !== this._sourceType) { this._sourceType = t; const e = hf[t], s = this.now(); if (this._oscillator) { const t = this._oscillator; t.stop(s), this.context.setTimeout(() => t.dispose(), this.blockTime) } this._oscillator = new e({ context: this.context }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), "started" === this.state && this._oscillator.start(s) } } get phase() { return this._oscillator.phase } set phase(t) { this._oscillator.phase = t } get sourceType() { return this._sourceType } set sourceType(t) { let e = "sine"; "pwm" !== this._oscillator.type && "pulse" !== this._oscillator.type && (e = this._oscillator.type), "fm" === t ? this.type = "fm" + e : "am" === t ? this.type = "am" + e : "fat" === t ? this.type = "fat" + e : "oscillator" === t ? this.type = e : "pulse" === t ? this.type = "pulse" : "pwm" === t && (this.type = "pwm") } _getOscType(t, e) { return t instanceof hf[e] } get baseType() { return this._oscillator.baseType } set baseType(t) { this._getOscType(this._oscillator, "pulse") || this._getOscType(this._oscillator, "pwm") || "pulse" === t || "pwm" === t || (this._oscillator.baseType = t) } get width() { return this._getOscType(this._oscillator, "pulse") ? this._oscillator.width : void 0 } get count() { return this._getOscType(this._oscillator, "fat") ? this._oscillator.count : void 0 } set count(t) { this._getOscType(this._oscillator, "fat") && yp(t) && (this._oscillator.count = t) } get spread() { return this._getOscType(this._oscillator, "fat") ? this._oscillator.spread : void 0 } set spread(t) { this._getOscType(this._oscillator, "fat") && yp(t) && (this._oscillator.spread = t) } get modulationType() { return this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am") ? this._oscillator.modulationType : void 0 } set modulationType(t) { (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && bp(t) && (this._oscillator.modulationType = t) } get modulationIndex() { return this._getOscType(this._oscillator, "fm") ? this._oscillator.modulationIndex : void 0 } get harmonicity() { return this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am") ? this._oscillator.harmonicity : void 0 } get modulationFrequency() { return this._getOscType(this._oscillator, "pwm") ? this._oscillator.modulationFrequency : void 0 } asArray() { return _(this, arguments, void 0, function* (t = 1024) { return Kd(this, t) }) } dispose() { return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this } } class lf extends O { constructor() { super(g(lf.getDefaults(), arguments, ["value"])), this.override = !1, this.name = "Add", this._sum = new C({ context: this.context }), this.input = this._sum, this.output = this._sum, this.addend = this._param, wd(this._constantSource, this._sum) } static getDefaults() { return Object.assign(O.getDefaults(), { value: 0 }) } dispose() { return super.dispose(), this._sum.dispose(), this } } class uf extends zd { constructor() { var t = g(uf.getDefaults(), arguments, ["min", "max"]); super(t), this.name = "Scale", this._mult = this.input = new q({ context: this.context, value: t.max - t.min }), this._add = this.output = new lf({ context: this.context, value: t.min }), this._min = t.min, this._max = t.max, this.input.connect(this.output) } static getDefaults() { return Object.assign(zd.getDefaults(), { max: 1, min: 0 }) } get min() { return this._min } set min(t) { this._min = t, this._setRange() } get max() { return this._max } set max(t) { this._max = t, this._setRange() } _setRange() { this._add.value = this._min, this._mult.value = this._max - this._min } dispose() { return super.dispose(), this._add.dispose(), this._mult.dispose(), this } } class pf extends zd { constructor() { super(g(pf.getDefaults(), arguments)), this.name = "Zero", this._gain = new C({ context: this.context }), this.output = this._gain, this.input = void 0, bd(this.context.getConstant(0), this._gain) } dispose() { return super.dispose(), Td(this.context.getConstant(0), this._gain), this } } class df extends A { constructor() { var t = g(df.getDefaults(), arguments, ["frequency", "min", "max"]); super(t), this.name = "LFO", this._stoppedValue = 0, this._units = "number", this.convert = !0, this._fromType = k.prototype._fromType, this._toType = k.prototype._toType, this._is = k.prototype._is, this._clampValue = k.prototype._clampValue, this._oscillator = new E(t), this.frequency = this._oscillator.frequency, this._amplitudeGain = new C({ context: this.context, gain: t.amplitude, units: "normalRange" }), this.amplitude = this._amplitudeGain.gain, this._stoppedSignal = new O({ context: this.context, units: "audioRange", value: 0 }), this._zeros = new pf({ context: this.context }), this._a2g = new ef({ context: this.context }), this._scaler = this.output = new uf({ context: this.context, max: t.max, min: t.min }), this.units = t.units, this.min = t.min, this.max = t.max, this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler), this._zeros.connect(this._a2g), this._stoppedSignal.connect(this._a2g), y(this, ["amplitude", "frequency"]), this.phase = t.phase } static getDefaults() { return Object.assign(E.getDefaults(), { amplitude: 1, frequency: "4n", max: 1, min: 0, type: "sine", units: "number" }) } start(t) { return t = this.toSeconds(t), this._stoppedSignal.setValueAtTime(0, t), this._oscillator.start(t), this } stop(t) { return t = this.toSeconds(t), this._stoppedSignal.setValueAtTime(this._stoppedValue, t), this._oscillator.stop(t), this } sync() { return this._oscillator.sync(), this._oscillator.syncFrequency(), this } unsync() { return this._oscillator.unsync(), this._oscillator.unsyncFrequency(), this } _setStoppedValue() { this._stoppedValue = this._oscillator.getInitialValue(), this._stoppedSignal.value = this._stoppedValue } get min() { return this._toType(this._scaler.min) } set min(t) { t = this._fromType(t), this._scaler.min = t } get max() { return this._toType(this._scaler.max) } set max(t) { t = this._fromType(t), this._scaler.max = t } get type() { return this._oscillator.type } set type(t) { this._oscillator.type = t, this._setStoppedValue() } get partials() { return this._oscillator.partials } set partials(t) { this._oscillator.partials = t, this._setStoppedValue() } get phase() { return this._oscillator.phase } set phase(t) { this._oscillator.phase = t, this._setStoppedValue() } get units() { return this._units } set units(t) { var e = this.min, s = this.max; this._units = t, this.min = e, this.max = s } get state() { return this._oscillator.state } connect(t, e, s) { return (t instanceof k || t instanceof O) && (this.convert = t.convert, this.units = t.units), Ad(this, t, e, s), this } dispose() { return super.dispose(), this._oscillator.dispose(), this._stoppedSignal.dispose(), this._zeros.dispose(), this._scaler.dispose(), this._a2g.dispose(), this._amplitudeGain.dispose(), this.amplitude.dispose(), this } } function ff(s, i = 1 / 0) { const n = new WeakMap; return function (t, e) { Reflect.defineProperty(t, e, { configurable: !0, enumerable: !0, get: function () { return n.get(this) }, set: function (t) { f(t, s, i), n.set(this, t) } }) } } function _f(s, i = 1 / 0) { const n = new WeakMap; return function (t, e) { Reflect.defineProperty(t, e, { configurable: !0, enumerable: !0, get: function () { return n.get(this) }, set: function (t) { f(this.toSeconds(t), s, i), n.set(this, t) } }) } } class mf extends M { constructor() { var t = g(mf.getDefaults(), arguments, ["url", "onload"]); super(t), this.name = "Player", this._activeSources = new Set, this._buffer = new w({ onload: this._onload.bind(this, t.onload), onerror: t.onerror, reverse: t.reverse, url: t.url }), this.autostart = t.autostart, this._loop = t.loop, this._loopStart = t.loopStart, this._loopEnd = t.loopEnd, this._playbackRate = t.playbackRate, this.fadeIn = t.fadeIn, this.fadeOut = t.fadeOut } static getDefaults() { return Object.assign(M.getDefaults(), { autostart: !1, fadeIn: 0, fadeOut: 0, loop: !1, loopEnd: 0, loopStart: 0, onload: x, onerror: x, playbackRate: 1, reverse: !1 }) } load(t) { return _(this, void 0, void 0, function* () { return yield this._buffer.load(t), this._onload(), this }) } _onload(t = x) { t(), this.autostart && this.start() } _onSourceEnd(t) { this.onstop(this), this._activeSources.delete(t), 0 !== this._activeSources.size || this._synced || "started" !== this._state.getValueAtTime(this.now()) || (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now())) } start(t, e, s) { return super.start(t, e, s), this } _start(t, e, s) { e = this._loop ? zp(e, this._loopStart) : zp(e, 0); var e = this.toSeconds(e), i = s, s = (s = zp(s, Math.max(this._buffer.duration - e, 0)), this.toSeconds(s)); s /= this._playbackRate, t = this.toSeconds(t); const n = new Zd({ url: this._buffer, context: this.context, fadeIn: this.fadeIn, fadeOut: this.fadeOut, loop: this._loop, loopEnd: this._loopEnd, loopStart: this._loopStart, onended: this._onSourceEnd.bind(this), playbackRate: this._playbackRate }).connect(this.output); this._loop || this._synced || (this._state.cancel(t + s), this._state.setStateAtTime("stopped", t + s, { implicitEnd: !0 })), this._activeSources.add(n), this._loop && gp(i) ? n.start(t, e) : n.start(t, e, s - this.toSeconds(this.fadeOut)) } _stop(t) { const e = this.toSeconds(t); this._activeSources.forEach(t => t.stop(e)) } restart(t, e, s) { return super.restart(t, e, s), this } _restart(t, e, s) { var i; null != (i = [...this._activeSources].pop()) && i.stop(t), this._start(t, e, s) } seek(t, e) { var s = this.toSeconds(e); if ("started" === this._state.getValueAtTime(s)) { const e = this.toSeconds(t); this._stop(s), this._start(s, e) } return this } setLoopPoints(t, e) { return this.loopStart = t, this.loopEnd = e, this } get loopStart() { return this._loopStart } set loopStart(e) { this._loopStart = e, this.buffer.loaded && f(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(t => { t.loopStart = e }) } get loopEnd() { return this._loopEnd } set loopEnd(e) { this._loopEnd = e, this.buffer.loaded && f(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(t => { t.loopEnd = e }) } get buffer() { return this._buffer } set buffer(t) { this._buffer.set(t) } get loop() { return this._loop } set loop(e) { if (this._loop !== e && (this._loop = e, this._activeSources.forEach(t => { t.loop = e }), e)) { const e = this._state.getNextState("stopped", this.now()); e && this._state.cancel(e.time) } } get playbackRate() { return this._playbackRate } set playbackRate(e) { this._playbackRate = e; const s = this.now(), t = this._state.getNextState("stopped", s); t && t.implicitEnd && (this._state.cancel(t.time), this._activeSources.forEach(t => t.cancelStop())), this._activeSources.forEach(t => { t.playbackRate.setValueAtTime(e, s) }) } get reverse() { return this._buffer.reverse } set reverse(t) { this._buffer.reverse = t } get loaded() { return this._buffer.loaded } dispose() { return super.dispose(), this._activeSources.forEach(t => t.dispose()), this._activeSources.clear(), this._buffer.dispose(), this } } Ip([_f(0)], mf.prototype, "fadeIn", void 0), Ip([_f(0)], mf.prototype, "fadeOut", void 0); class gf extends A { constructor() { var t = g(gf.getDefaults(), arguments, ["urls", "onload"], "urls"); super(t), this.name = "Players", this.input = void 0, this._players = new Map, this._volume = this.output = new Rd({ context: this.context, volume: t.volume }), this.volume = this._volume.volume, y(this, "volume"), this._buffers = new Fd({ urls: t.urls, onload: t.onload, baseUrl: t.baseUrl, onerror: t.onerror }), this.mute = t.mute, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut } static getDefaults() { return Object.assign(M.getDefaults(), { baseUrl: "", fadeIn: 0, fadeOut: 0, mute: !1, onload: x, onerror: x, urls: {}, volume: 0 }) } get mute() { return this._volume.mute } set mute(t) { this._volume.mute = t } get fadeIn() { return this._fadeIn } set fadeIn(e) { this._fadeIn = e, this._players.forEach(t => { t.fadeIn = e }) } get fadeOut() { return this._fadeOut } set fadeOut(e) { this._fadeOut = e, this._players.forEach(t => { t.fadeOut = e }) } get state() { return Array.from(this._players).some(([, t]) => "started" === t.state) ? "started" : "stopped" } has(t) { return this._buffers.has(t) } player(t) { var e; return l(this.has(t), `No Player with the name ${t} exists on this object`), this._players.has(t) || (e = new mf({ context: this.context, fadeIn: this._fadeIn, fadeOut: this._fadeOut, url: this._buffers.get(t) }).connect(this.output), this._players.set(t, e)), this._players.get(t) } get loaded() { return this._buffers.loaded } add(t, e, s) { return l(!this._buffers.has(t), "A buffer with that name already exists on this object"), this._buffers.add(t, e, s), this } stopAll(e) { return this._players.forEach(t => t.stop(e)), this } dispose() { return super.dispose(), this._volume.dispose(), this.volume.dispose(), this._players.forEach(t => t.dispose()), this._buffers.dispose(), this } } class vf extends M { constructor() { var t = g(vf.getDefaults(), arguments, ["url", "onload"]); super(t), this.name = "GrainPlayer", this._loopStart = 0, this._loopEnd = 0, this._activeSources = [], this.buffer = new w({ onload: t.onload, onerror: t.onerror, reverse: t.reverse, url: t.url }), this._clock = new Md({ context: this.context, callback: this._tick.bind(this), frequency: 1 / t.grainSize }), this._playbackRate = t.playbackRate, this._grainSize = t.grainSize, this._overlap = t.overlap, this.detune = t.detune, this.overlap = t.overlap, this.loop = t.loop, this.playbackRate = t.playbackRate, this.grainSize = t.grainSize, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this.reverse = t.reverse, this._clock.on("stop", this._onstop.bind(this)) } static getDefaults() { return Object.assign(M.getDefaults(), { onload: x, onerror: x, overlap: .1, grainSize: .2, playbackRate: 1, detune: 0, loop: !1, loopStart: 0, loopEnd: 0, reverse: !1 }) } _start(t, e, s) { e = zp(e, 0), e = this.toSeconds(e), t = this.toSeconds(t); var i = 1 / this._clock.frequency.getValueAtTime(t); this._clock.start(t, e / i), s && this.stop(t + this.toSeconds(s)) } restart(t, e, s) { return super.restart(t, e, s), this } _restart(t, e, s) { this._stop(t), this._start(t, e, s) } _stop(t) { this._clock.stop(t) } _onstop(e) { this._activeSources.forEach(t => { t.fadeOut = 0, t.stop(e) }), this.onstop(this) } _tick(t) { var e = this._clock.getTicksAtTime(t), s = e * this._grainSize; if (this.log("offset", s), !this.loop && s > this.buffer.duration) this.stop(t); else { const i = s < this._overlap ? 0 : this._overlap, n = new Zd({ context: this.context, url: this.buffer, fadeIn: i, fadeOut: this._overlap, loop: this.loop, loopStart: this._loopStart, loopEnd: this._loopEnd, playbackRate: ld(this.detune / 100) }).connect(this.output); n.start(t, this._grainSize * e), n.stop(t + this._grainSize / this.playbackRate), this._activeSources.push(n), n.onended = () => { var t = this._activeSources.indexOf(n); -1 !== t && this._activeSources.splice(t, 1) } } } get playbackRate() { return this._playbackRate } set playbackRate(t) { f(t, .001), this._playbackRate = t, this.grainSize = this._grainSize } get loopStart() { return this._loopStart } set loopStart(t) { this.buffer.loaded && f(this.toSeconds(t), 0, this.buffer.duration), this._loopStart = this.toSeconds(t) } get loopEnd() { return this._loopEnd } set loopEnd(t) { this.buffer.loaded && f(this.toSeconds(t), 0, this.buffer.duration), this._loopEnd = this.toSeconds(t) } get reverse() { return this.buffer.reverse } set reverse(t) { this.buffer.reverse = t } get grainSize() { return this._grainSize } set grainSize(t) { this._grainSize = this.toSeconds(t), this._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now()) } get overlap() { return this._overlap } set overlap(t) { t = this.toSeconds(t); f(t, 0), this._overlap = t } get loaded() { return this.buffer.loaded } dispose() { return super.dispose(), this.buffer.dispose(), this._clock.dispose(), this._activeSources.forEach(t => t.dispose()), this } } class yf extends zd { constructor() { super(...arguments), this.name = "Abs", this._abs = new Wd({ context: this.context, mapping: t => Math.abs(t) < .001 ? 0 : Math.abs(t) }), this.input = this._abs, this.output = this._abs } dispose() { return super.dispose(), this._abs.dispose(), this } } class xf extends zd { constructor() { super(...arguments), this.name = "GainToAudio", this._norm = new Wd({ context: this.context, mapping: t => 2 * Math.abs(t) - 1 }), this.input = this._norm, this.output = this._norm } dispose() { return super.dispose(), this._norm.dispose(), this } } class wf extends zd { constructor() { super(...arguments), this.name = "Negate", this._multiply = new q({ context: this.context, value: -1 }), this.input = this._multiply, this.output = this._multiply } dispose() { return super.dispose(), this._multiply.dispose(), this } } class bf extends O { constructor() { super(g(bf.getDefaults(), arguments, ["value"])), this.override = !1, this.name = "Subtract", this._sum = new C({ context: this.context }), this.input = this._sum, this.output = this._sum, this._neg = new wf({ context: this.context }), this.subtrahend = this._param, wd(this._constantSource, this._neg, this._sum) } static getDefaults() { return Object.assign(O.getDefaults(), { value: 0 }) } dispose() { return super.dispose(), this._neg.dispose(), this._sum.dispose(), this } } class Tf extends zd { constructor() { super(g(Tf.getDefaults(), arguments)), this.name = "GreaterThanZero", this._thresh = this.output = new Wd({ context: this.context, length: 127, mapping: t => t <= 0 ? 0 : 1 }), this._scale = this.input = new q({ context: this.context, value: 1e4 }), this._scale.connect(this._thresh) } dispose() { return super.dispose(), this._scale.dispose(), this._thresh.dispose(), this } } class Sf extends O { constructor() { var t = g(Sf.getDefaults(), arguments, ["value"]); super(t), this.name = "GreaterThan", this.override = !1, this._subtract = this.input = new bf({ context: this.context, value: t.value }), this._gtz = this.output = new Tf({ context: this.context }), this.comparator = this._param = this._subtract.subtrahend, y(this, "comparator"), this._subtract.connect(this._gtz) } static getDefaults() { return Object.assign(O.getDefaults(), { value: 0 }) } dispose() { return super.dispose(), this._gtz.dispose(), this._subtract.dispose(), this.comparator.dispose(), this } } class kf extends uf { constructor() { var t = g(kf.getDefaults(), arguments, ["min", "max", "exponent"]); super(t), this.name = "ScaleExp", this.input = this._exp = new Bd({ context: this.context, value: t.exponent }), this._exp.connect(this._mult) } static getDefaults() { return Object.assign(uf.getDefaults(), { exponent: 1 }) } get exponent() { return this._exp.value } set exponent(t) { this._exp.value = t } dispose() { return super.dispose(), this._exp.dispose(), this } } class Af extends O { constructor() { var t = g(O.getDefaults(), arguments, ["value", "units"]); super(t), this.name = "SyncedSignal", this.override = !1, this._lastVal = t.value, this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), "1i"), this._syncedCallback = this._anchorValue.bind(this), this.context.transport.on("start", this._syncedCallback), this.context.transport.on("pause", this._syncedCallback), this.context.transport.on("stop", this._syncedCallback), this._constantSource.disconnect(), this._constantSource.stop(0), this._constantSource = this.output = new kd({ context: this.context, offset: t.value, units: t.units }).start(0), this.setValueAtTime(t.value, 0) } _onTick(t) { var e = super.getValueAtTime(this.context.transport.seconds); this._lastVal !== e && (this._lastVal = e, this._constantSource.offset.setValueAtTime(e, t)) } _anchorValue(t) { var e = super.getValueAtTime(this.context.transport.seconds); this._lastVal = e, this._constantSource.offset.cancelAndHoldAtTime(t), this._constantSource.offset.setValueAtTime(e, t) } getValueAtTime(t) { t = new T(this.context, t).toSeconds(); return super.getValueAtTime(t) } setValueAtTime(t, e) { e = new T(this.context, e).toSeconds(); return super.setValueAtTime(t, e), this } linearRampToValueAtTime(t, e) { e = new T(this.context, e).toSeconds(); return super.linearRampToValueAtTime(t, e), this } exponentialRampToValueAtTime(t, e) { e = new T(this.context, e).toSeconds(); return super.exponentialRampToValueAtTime(t, e), this } setTargetAtTime(t, e, s) { e = new T(this.context, e).toSeconds(); return super.setTargetAtTime(t, e, s), this } cancelScheduledValues(t) { t = new T(this.context, t).toSeconds(); return super.cancelScheduledValues(t), this } setValueCurveAtTime(t, e, s, i) { e = new T(this.context, e).toSeconds(); return s = this.toSeconds(s), super.setValueCurveAtTime(t, e, s, i), this } cancelAndHoldAtTime(t) { t = new T(this.context, t).toSeconds(); return super.cancelAndHoldAtTime(t), this } setRampPoint(t) { t = new T(this.context, t).toSeconds(); return super.setRampPoint(t), this } exponentialRampTo(t, e, s) { s = new T(this.context, s).toSeconds(); return super.exponentialRampTo(t, e, s), this } linearRampTo(t, e, s) { s = new T(this.context, s).toSeconds(); return super.linearRampTo(t, e, s), this } targetRampTo(t, e, s) { s = new T(this.context, s).toSeconds(); return super.targetRampTo(t, e, s), this } dispose() { return super.dispose(), this.context.transport.clear(this._synced), this.context.transport.off("start", this._syncedCallback), this.context.transport.off("pause", this._syncedCallback), this.context.transport.off("stop", this._syncedCallback), this._constantSource.dispose(), this } } class Cf extends A { constructor() { var t = g(Cf.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]); super(t), this.name = "Envelope", this._sig = new O({ context: this.context, value: 0 }), this.output = this._sig, this.input = void 0, this.attack = t.attack, this.decay = t.decay, this.sustain = t.sustain, this.release = t.release, this.attackCurve = t.attackCurve, this.releaseCurve = t.releaseCurve, this.decayCurve = t.decayCurve } static getDefaults() { return Object.assign(A.getDefaults(), { attack: .01, attackCurve: "linear", decay: .1, decayCurve: "exponential", release: 1, releaseCurve: "exponential", sustain: .5 }) } get value() { return this.getValueAtTime(this.now()) } _getCurve(e, s) { if (bp(e)) return e; { let t; for (t in Of) if (Of[t][s] === e) return t; return e } } _setCurve(t, e, s) { if (bp(s) && Reflect.has(Of, s)) { var i = Of[s]; xp(i) ? "_decayCurve" !== t && (this[t] = i[e]) : this[t] = i } else { if (!d(s) || "_decayCurve" === t) throw new Error("Envelope: invalid curve: " + s); this[t] = s } } get attackCurve() { return this._getCurve(this._attackCurve, "In") } set attackCurve(t) { this._setCurve("_attackCurve", "In", t) } get releaseCurve() { return this._getCurve(this._releaseCurve, "Out") } set releaseCurve(t) { this._setCurve("_releaseCurve", "Out", t) } get decayCurve() { return this._getCurve(this._decayCurve, "Out") } set decayCurve(t) { this._setCurve("_decayCurve", "Out", t) } triggerAttack(t, s = 1) { this.log("triggerAttack", t, s), t = this.toSeconds(t); let i = this.toSeconds(this.attack); const e = this.toSeconds(this.decay), n = this.getValueAtTime(t); if ((i = 0 < n ? (1 - n) / (1 / i) : i) < this.sampleTime) this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(s, t); else if ("linear" === this._attackCurve) this._sig.linearRampTo(s, i, t); else if ("exponential" === this._attackCurve) this._sig.targetRampTo(s, i, t); else { this._sig.cancelAndHoldAtTime(t); let e = this._attackCurve; for (let t = 1; t < e.length; t++)if (e[t - 1] <= n && n <= e[t]) { (e = this._attackCurve.slice(t))[0] = n; break } this._sig.setValueCurveAtTime(e, t, i, s) } if (e && this.sustain < 1) { const n = s * this.sustain, r = t + i; this.log("decay", r), "linear" === this._decayCurve ? this._sig.linearRampToValueAtTime(n, e + r) : this._sig.exponentialApproachValueAtTime(n, r, e) } return this } triggerRelease(t) { this.log("triggerRelease", t), t = this.toSeconds(t); var e, s = this.getValueAtTime(t); return 0 < s && ((e = this.toSeconds(this.release)) < this.sampleTime ? this._sig.setValueAtTime(0, t) : "linear" === this._releaseCurve ? this._sig.linearRampTo(0, e, t) : "exponential" === this._releaseCurve ? this._sig.targetRampTo(0, e, t) : (l(d(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(t), this._sig.setValueCurveAtTime(this._releaseCurve, t, e, s))), this } getValueAtTime(t) { return this._sig.getValueAtTime(t) } triggerAttackRelease(t, e, s = 1) { return e = this.toSeconds(e), this.triggerAttack(e, s), this.triggerRelease(e + this.toSeconds(t)), this } cancel(t) { return this._sig.cancelScheduledValues(this.toSeconds(t)), this } connect(t, e = 0, s = 0) { return Ad(this, t, e, s), this } asArray() { return _(this, arguments, void 0, function* (t = 1024) { const e = t / this.context.sampleRate, s = new nd(1, e, this.context.sampleRate), i = this.toSeconds(this.attack) + this.toSeconds(this.decay), n = i + this.toSeconds(this.release), r = .1 * n, o = n + r, a = new this.constructor(Object.assign(this.get(), { attack: e * this.toSeconds(this.attack) / o, decay: e * this.toSeconds(this.decay) / o, release: e * this.toSeconds(this.release) / o, context: s })); return a._sig.toDestination(), a.triggerAttackRelease(e * (i + r) / o, 0), (yield s.render()).getChannelData(0) }) } dispose() { return super.dispose(), this._sig.dispose(), this } } Ip([_f(0)], Cf.prototype, "attack", void 0), Ip([_f(0)], Cf.prototype, "decay", void 0), Ip([ff(0, 1)], Cf.prototype, "sustain", void 0), Ip([_f(0)], Cf.prototype, "release", void 0); const Of = (() => { const t = 128; let e, s; const i = []; for (e = 0; e < t; e++)i[e] = Math.sin(e / 127 * (Math.PI / 2)); const n = []; for (e = 0; e < 127; e++) { s = e / 127; const t = Math.sin(s * (2 * Math.PI) * 6.4 - Math.PI / 2) + 1; n[e] = t / 10 + .83 * s } n[127] = 1; const r = []; for (e = 0; e < t; e++)r[e] = Math.ceil(e / 127 * 5) / 5; const o = []; for (e = 0; e < t; e++)s = e / 127, o[e] = .5 * (1 - Math.cos(Math.PI * s)); const a = []; for (e = 0; e < t; e++) { s = e / 127; const t = 4 * Math.pow(s, 3) + .2, i = Math.cos(t * Math.PI * 2 * s); a[e] = Math.abs(i * (1 - s)) } function h(e) { const s = new Array(e.length); for (let t = 0; t < e.length; t++)s[t] = 1 - e[t]; return s } return { bounce: { In: h(a), Out: a }, cosine: { In: i, Out: i.slice(0).reverse() }, exponential: "exponential", linear: "linear", ripple: { In: n, Out: h(n) }, sine: { In: o, Out: h(o) }, step: { In: r, Out: h(r) } } })(); class Df extends A { constructor() { var t = g(Df.getDefaults(), arguments); super(t), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease, this._syncedRelease = t => this._original_triggerRelease(t), this._volume = this.output = new Rd({ context: this.context, volume: t.volume }), this.volume = this._volume.volume, y(this, "volume") } static getDefaults() { return Object.assign(A.getDefaults(), { volume: 0 }) } sync() { return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this } _syncState() { let t = !1; return this._synced || (this._synced = !0, t = !0), t } _syncMethod(t, s) { const i = this["_original_" + t] = this[t]; this[t] = (...e) => { var t = e[s], t = this.context.transport.schedule(t => { e[s] = t, i.apply(this, e) }, t); this._scheduledEvents.push(t) } } unsync() { return this._scheduledEvents.forEach(t => this.context.transport.clear(t)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease, this.context.transport.off("stop", this._syncedRelease), this.context.transport.off("pause", this._syncedRelease), this.context.transport.off("loopEnd", this._syncedRelease)), this } triggerAttackRelease(t, e, s, i) { s = this.toSeconds(s), e = this.toSeconds(e); return this.triggerAttack(t, s, i), this.triggerRelease(s + e), this } dispose() { return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this } } class Mf extends Df { constructor() { var t = g(Mf.getDefaults(), arguments); super(t), this.portamento = t.portamento, this.onsilence = t.onsilence } static getDefaults() { return Object.assign(Df.getDefaults(), { detune: 0, onsilence: x, portamento: 0 }) } triggerAttack(t, e, s = 1) { this.log("triggerAttack", t, e, s); e = this.toSeconds(e); return this._triggerEnvelopeAttack(e, s), this.setNote(t, e), this } triggerRelease(t) { this.log("triggerRelease", t); t = this.toSeconds(t); return this._triggerEnvelopeRelease(t), this } setNote(t, e) { var e = this.toSeconds(e), s = t instanceof gd ? t.toFrequency() : t; if (0 < this.portamento && .05 < this.getLevelAtTime(e)) { const t = this.toSeconds(this.portamento); this.frequency.exponentialRampTo(s, t, e) } else this.frequency.setValueAtTime(s, e); return this } } Ip([_f(0)], Mf.prototype, "portamento", void 0); class Ef extends Cf { constructor() { super(g(Ef.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new C({ context: this.context, gain: 0 }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode } dispose() { return super.dispose(), this._gainNode.dispose(), this } } class Rf extends Mf { constructor() { var t = g(Rf.getDefaults(), arguments); super(t), this.name = "Synth", this.oscillator = new cf(Object.assign({ context: this.context, detune: t.detune, onstop: () => this.onsilence(this) }, t.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new Ef(Object.assign({ context: this.context }, t.envelope)), this.oscillator.chain(this.envelope, this.output), y(this, ["oscillator", "frequency", "detune", "envelope"]) } static getDefaults() { return Object.assign(Mf.getDefaults(), { envelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { attack: .005, decay: .1, release: 1, sustain: .3 }), oscillator: Object.assign(v(cf.getDefaults(), [...Object.keys(M.getDefaults()), "frequency", "detune"]), { type: "triangle" }) }) } _triggerEnvelopeAttack(t, e) { if (this.envelope.triggerAttack(t, e), this.oscillator.start(t), 0 === this.envelope.sustain) { const e = this.toSeconds(this.envelope.attack), s = this.toSeconds(this.envelope.decay); this.oscillator.stop(t + e + s) } } _triggerEnvelopeRelease(t) { this.envelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release)) } getLevelAtTime(t) { return t = this.toSeconds(t), this.envelope.getValueAtTime(t) } dispose() { return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this } } class qf extends Mf { constructor() { var t = g(qf.getDefaults(), arguments); super(t), this.name = "ModulationSynth", this._carrier = new Rf({ context: this.context, oscillator: t.oscillator, envelope: t.envelope, onsilence: () => this.onsilence(this), volume: -10 }), this._modulator = new Rf({ context: this.context, oscillator: t.modulation, envelope: t.modulationEnvelope, volume: -10 }), this.oscillator = this._carrier.oscillator, this.envelope = this._carrier.envelope, this.modulation = this._modulator.oscillator, this.modulationEnvelope = this._modulator.envelope, this.frequency = new O({ context: this.context, units: "frequency" }), this.detune = new O({ context: this.context, value: t.detune, units: "cents" }), this.harmonicity = new q({ context: this.context, value: t.harmonicity, minValue: 0 }), this._modulationNode = new C({ context: this.context, gain: 0 }), y(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"]) } static getDefaults() { return Object.assign(Mf.getDefaults(), { harmonicity: 3, oscillator: Object.assign(v(cf.getDefaults(), [...Object.keys(M.getDefaults()), "frequency", "detune"]), { type: "sine" }), envelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { attack: .01, decay: .01, sustain: 1, release: .5 }), modulation: Object.assign(v(cf.getDefaults(), [...Object.keys(M.getDefaults()), "frequency", "detune"]), { type: "square" }), modulationEnvelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { attack: .5, decay: 0, sustain: 1, release: .5 }) }) } _triggerEnvelopeAttack(t, e) { this._carrier._triggerEnvelopeAttack(t, e), this._modulator._triggerEnvelopeAttack(t, e) } _triggerEnvelopeRelease(t) { return this._carrier._triggerEnvelopeRelease(t), this._modulator._triggerEnvelopeRelease(t), this } getLevelAtTime(t) { return t = this.toSeconds(t), this.envelope.getValueAtTime(t) } dispose() { return super.dispose(), this._carrier.dispose(), this._modulator.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._modulationNode.dispose(), this } } class If extends qf { constructor() { super(g(If.getDefaults(), arguments)), this.name = "AMSynth", this._modulationScale = new ef({ context: this.context }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output) } dispose() { return super.dispose(), this._modulationScale.dispose(), this } } class Ff extends A { constructor() { var t = g(Ff.getDefaults(), arguments, ["frequency", "type"]); super(t), this.name = "BiquadFilter", this._filter = this.context.createBiquadFilter(), this.input = this.output = this._filter, this.Q = new k({ context: this.context, units: "number", value: t.Q, param: this._filter.Q }), this.frequency = new k({ context: this.context, units: "frequency", value: t.frequency, param: this._filter.frequency }), this.detune = new k({ context: this.context, units: "cents", value: t.detune, param: this._filter.detune }), this.gain = new k({ context: this.context, units: "decibels", convert: !1, value: t.gain, param: this._filter.gain }), this.type = t.type } static getDefaults() { return Object.assign(A.getDefaults(), { Q: 1, type: "lowpass", frequency: 350, detune: 0, gain: 0 }) } get type() { return this._filter.type } set type(t) { l(-1 !== ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(t), "Invalid filter type: " + t), this._filter.type = t } getFrequencyResponse(e = 128) { const s = new Float32Array(e); for (let t = 0; t < e; t++) { const i = 19980 * Math.pow(t / e, 2) + 20; s[t] = i } const t = new Float32Array(e), i = new Float32Array(e), n = this.context.createBiquadFilter(); return n.type = this.type, n.Q.value = this.Q.value, n.frequency.value = this.frequency.value, n.gain.value = this.gain.value, n.getFrequencyResponse(s, t, i), t } dispose() { return super.dispose(), this._filter.disconnect(), this.Q.dispose(), this.frequency.dispose(), this.gain.dispose(), this.detune.dispose(), this } } class Vf extends A { constructor() { var t = g(Vf.getDefaults(), arguments, ["frequency", "type", "rolloff"]); super(t), this.name = "Filter", this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this._filters = [], this._filters = [], this.Q = new O({ context: this.context, units: "positive", value: t.Q }), this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency }), this.detune = new O({ context: this.context, units: "cents", value: t.detune }), this.gain = new O({ context: this.context, units: "decibels", convert: !1, value: t.gain }), this._type = t.type, this.rolloff = t.rolloff, y(this, ["detune", "frequency", "gain", "Q"]) } static getDefaults() { return Object.assign(A.getDefaults(), { Q: 1, detune: 0, frequency: 350, gain: 0, rolloff: -12, type: "lowpass" }) } get type() { return this._type } set type(e) { l(-1 !== ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e), "Invalid filter type: " + e), this._type = e, this._filters.forEach(t => t.type = e) } get rolloff() { return this._rolloff } set rolloff(t) { const e = yp(t) ? t : parseInt(t, 10), s = [-12, -24, -48, -96]; var i = s.indexOf(e); l(-1 !== i, "rolloff can only be " + s.join(", ")), i += 1, this._rolloff = e, this.input.disconnect(), this._filters.forEach(t => t.disconnect()), this._filters = new Array(i); for (let t = 0; t < i; t++) { const e = new Ff({ context: this.context }); e.type = this._type, this.frequency.connect(e.frequency), this.detune.connect(e.detune), this.Q.connect(e.Q), this.gain.connect(e.gain), this._filters[t] = e } this._internalChannels = this._filters, wd(this.input, ...this._internalChannels, this.output) } getFrequencyResponse(t = 128) { const e = new Ff({ frequency: this.frequency.value, gain: this.gain.value, Q: this.Q.value, type: this._type, detune: this.detune.value }), s = new Float32Array(t).map(() => 1); return this._filters.forEach(() => { e.getFrequencyResponse(t).forEach((t, e) => s[e] *= t) }), e.dispose(), s } dispose() { return super.dispose(), this._filters.forEach(t => { t.dispose() }), id(this, ["detune", "frequency", "gain", "Q"]), this.frequency.dispose(), this.Q.dispose(), this.detune.dispose(), this.gain.dispose(), this } } class Nf extends Cf { constructor() { var t = g(Nf.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]); super(t), this.name = "FrequencyEnvelope", this._octaves = t.octaves, this._baseFrequency = this.toFrequency(t.baseFrequency), this._exponent = this.input = new Bd({ context: this.context, value: t.exponent }), this._scale = this.output = new uf({ context: this.context, min: this._baseFrequency, max: this._baseFrequency * Math.pow(2, this._octaves) }), this._sig.chain(this._exponent, this._scale) } static getDefaults() { return Object.assign(Cf.getDefaults(), { baseFrequency: 200, exponent: 1, octaves: 4 }) } get baseFrequency() { return this._baseFrequency } set baseFrequency(t) { t = this.toFrequency(t); f(t, 0), this._baseFrequency = t, this._scale.min = this._baseFrequency, this.octaves = this._octaves } get octaves() { return this._octaves } set octaves(t) { this._octaves = t, this._scale.max = this._baseFrequency * Math.pow(2, t) } get exponent() { return this._exponent.value } set exponent(t) { this._exponent.value = t } dispose() { return super.dispose(), this._exponent.dispose(), this._scale.dispose(), this } } class Pf extends Mf { constructor() { var t = g(Pf.getDefaults(), arguments); super(t), this.name = "MonoSynth", this.oscillator = new cf(Object.assign(t.oscillator, { context: this.context, detune: t.detune, onstop: () => this.onsilence(this) })), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.filter = new Vf(Object.assign(t.filter, { context: this.context })), this.filterEnvelope = new Nf(Object.assign(t.filterEnvelope, { context: this.context })), this.envelope = new Ef(Object.assign(t.envelope, { context: this.context })), this.oscillator.chain(this.filter, this.envelope, this.output), this.filterEnvelope.connect(this.filter.frequency), y(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"]) } static getDefaults() { return Object.assign(Mf.getDefaults(), { envelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { attack: .005, decay: .1, release: 1, sustain: .9 }), filter: Object.assign(v(Vf.getDefaults(), Object.keys(A.getDefaults())), { Q: 1, rolloff: -12, type: "lowpass" }), filterEnvelope: Object.assign(v(Nf.getDefaults(), Object.keys(A.getDefaults())), { attack: .6, baseFrequency: 200, decay: .2, exponent: 2, octaves: 3, release: 2, sustain: .5 }), oscillator: Object.assign(v(cf.getDefaults(), Object.keys(M.getDefaults())), { type: "sawtooth" }) }) } _triggerEnvelopeAttack(t, e = 1) { if (this.envelope.triggerAttack(t, e), this.filterEnvelope.triggerAttack(t), this.oscillator.start(t), 0 === this.envelope.sustain) { const e = this.toSeconds(this.envelope.attack), s = this.toSeconds(this.envelope.decay); this.oscillator.stop(t + e + s) } } _triggerEnvelopeRelease(t) { this.envelope.triggerRelease(t), this.filterEnvelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release)) } getLevelAtTime(t) { return t = this.toSeconds(t), this.envelope.getValueAtTime(t) } dispose() { return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this.filterEnvelope.dispose(), this.filter.dispose(), this } } class jf extends Mf { constructor() { var t = g(jf.getDefaults(), arguments); super(t), this.name = "DuoSynth", this.voice0 = new Pf(Object.assign(t.voice0, { context: this.context, onsilence: () => this.onsilence(this) })), this.voice1 = new Pf(Object.assign(t.voice1, { context: this.context })), this.harmonicity = new q({ context: this.context, units: "positive", value: t.harmonicity }), this._vibrato = new df({ frequency: t.vibratoRate, context: this.context, min: -50, max: 50 }), this._vibrato.start(), this.vibratoRate = this._vibrato.frequency, this._vibratoGain = new C({ context: this.context, units: "normalRange", gain: t.vibratoAmount }), this.vibratoAmount = this._vibratoGain.gain, this.frequency = new O({ context: this.context, units: "frequency", value: 440 }), this.detune = new O({ context: this.context, units: "cents", value: t.detune }), this.frequency.connect(this.voice0.frequency), this.frequency.chain(this.harmonicity, this.voice1.frequency), this._vibrato.connect(this._vibratoGain), this._vibratoGain.fan(this.voice0.detune, this.voice1.detune), this.detune.fan(this.voice0.detune, this.voice1.detune), this.voice0.connect(this.output), this.voice1.connect(this.output), y(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"]) } getLevelAtTime(t) { return t = this.toSeconds(t), this.voice0.envelope.getValueAtTime(t) + this.voice1.envelope.getValueAtTime(t) } static getDefaults() { return Lp(Mf.getDefaults(), { vibratoAmount: .5, vibratoRate: 5, harmonicity: 1.5, voice0: Lp(v(Pf.getDefaults(), Object.keys(Mf.getDefaults())), { filterEnvelope: { attack: .01, decay: 0, sustain: 1, release: .5 }, envelope: { attack: .01, decay: 0, sustain: 1, release: .5 } }), voice1: Lp(v(Pf.getDefaults(), Object.keys(Mf.getDefaults())), { filterEnvelope: { attack: .01, decay: 0, sustain: 1, release: .5 }, envelope: { attack: .01, decay: 0, sustain: 1, release: .5 } }) }) } _triggerEnvelopeAttack(t, e) { this.voice0._triggerEnvelopeAttack(t, e), this.voice1._triggerEnvelopeAttack(t, e) } _triggerEnvelopeRelease(t) { return this.voice0._triggerEnvelopeRelease(t), this.voice1._triggerEnvelopeRelease(t), this } dispose() { return super.dispose(), this.voice0.dispose(), this.voice1.dispose(), this.frequency.dispose(), this.detune.dispose(), this._vibrato.dispose(), this.vibratoRate.dispose(), this._vibratoGain.dispose(), this.harmonicity.dispose(), this } } class Lf extends qf { constructor() { var t = g(Lf.getDefaults(), arguments); super(t), this.name = "FMSynth", this.modulationIndex = new q({ context: this.context, value: t.modulationIndex }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output) } static getDefaults() { return Object.assign(qf.getDefaults(), { modulationIndex: 10 }) } dispose() { return super.dispose(), this.modulationIndex.dispose(), this } } const zf = [1, 1.483, 1.932, 2.546, 2.63, 3.897]; class Wf extends Mf { constructor() { var e = g(Wf.getDefaults(), arguments); super(e), this.name = "MetalSynth", this._oscillators = [], this._freqMultipliers = [], this.detune = new O({ context: this.context, units: "cents", value: e.detune }), this.frequency = new O({ context: this.context, units: "frequency" }), this._amplitude = new C({ context: this.context, gain: 0 }).connect(this.output), this._highpass = new Vf({ Q: 0, context: this.context, type: "highpass" }).connect(this._amplitude); for (let t = 0; t < zf.length; t++) { const i = new nf({ context: this.context, harmonicity: e.harmonicity, modulationIndex: e.modulationIndex, modulationType: "square", onstop: 0 === t ? () => this.onsilence(this) : x, type: "square" }); i.connect(this._highpass), this._oscillators[t] = i; var s = new q({ context: this.context, value: zf[t] }); this._freqMultipliers[t] = s, this.frequency.chain(s, i.frequency), this.detune.connect(i.detune) } this._filterFreqScaler = new uf({ context: this.context, max: 7e3, min: this.toFrequency(e.resonance) }), this.envelope = new Cf({ attack: e.envelope.attack, attackCurve: "linear", context: this.context, decay: e.envelope.decay, release: e.envelope.release, sustain: 0 }), this.envelope.chain(this._filterFreqScaler, this._highpass.frequency), this.envelope.connect(this._amplitude.gain), this._octaves = e.octaves, this.octaves = e.octaves } static getDefaults() { return Lp(Mf.getDefaults(), { envelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { attack: .001, decay: 1.4, release: .2 }), harmonicity: 5.1, modulationIndex: 32, octaves: 1.5, resonance: 4e3 }) } _triggerEnvelopeAttack(e, t = 1) { return this.envelope.triggerAttack(e, t), this._oscillators.forEach(t => t.start(e)), 0 === this.envelope.sustain && this._oscillators.forEach(t => { t.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay)) }), this } _triggerEnvelopeRelease(e) { return this.envelope.triggerRelease(e), this._oscillators.forEach(t => t.stop(e + this.toSeconds(this.envelope.release))), this } getLevelAtTime(t) { return t = this.toSeconds(t), this.envelope.getValueAtTime(t) } get modulationIndex() { return this._oscillators[0].modulationIndex.value } set modulationIndex(e) { this._oscillators.forEach(t => t.modulationIndex.value = e) } get harmonicity() { return this._oscillators[0].harmonicity.value } set harmonicity(e) { this._oscillators.forEach(t => t.harmonicity.value = e) } get resonance() { return this._filterFreqScaler.min } set resonance(t) { this._filterFreqScaler.min = this.toFrequency(t), this.octaves = this._octaves } get octaves() { return this._octaves } set octaves(t) { this._octaves = t, this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, t) } dispose() { return super.dispose(), this._oscillators.forEach(t => t.dispose()), this._freqMultipliers.forEach(t => t.dispose()), this.frequency.dispose(), this.detune.dispose(), this._filterFreqScaler.dispose(), this._amplitude.dispose(), this.envelope.dispose(), this._highpass.dispose(), this } } class Bf extends Rf { constructor() { var t = g(Bf.getDefaults(), arguments); super(t), this.name = "MembraneSynth", this.portamento = 0, this.pitchDecay = t.pitchDecay, this.octaves = t.octaves, y(this, ["oscillator", "envelope"]) } static getDefaults() { return Lp(Mf.getDefaults(), Rf.getDefaults(), { envelope: { attack: .001, attackCurve: "exponential", decay: .4, release: 1.4, sustain: .01 }, octaves: 10, oscillator: { type: "sine" }, pitchDecay: .05 }) } setNote(t, e) { var e = this.toSeconds(e), t = this.toFrequency(t instanceof gd ? t.toFrequency() : t), s = t * this.octaves; return this.oscillator.frequency.setValueAtTime(s, e), this.oscillator.frequency.exponentialRampToValueAtTime(t, e + this.toSeconds(this.pitchDecay)), this } dispose() { return super.dispose(), this } } Ip([ff(0)], Bf.prototype, "octaves", void 0), Ip([_f(0)], Bf.prototype, "pitchDecay", void 0); class Uf extends Df { constructor() { var t = g(Uf.getDefaults(), arguments); super(t), this.name = "NoiseSynth", this.noise = new Xd(Object.assign({ context: this.context }, t.noise)), this.envelope = new Ef(Object.assign({ context: this.context }, t.envelope)), this.noise.chain(this.envelope, this.output) } static getDefaults() { return Object.assign(Df.getDefaults(), { envelope: Object.assign(v(Cf.getDefaults(), Object.keys(A.getDefaults())), { decay: .1, sustain: 0 }), noise: Object.assign(v(Xd.getDefaults(), Object.keys(M.getDefaults())), { type: "white" }) }) } triggerAttack(t, e = 1) { return t = this.toSeconds(t), this.envelope.triggerAttack(t, e), this.noise.start(t), 0 === this.envelope.sustain && this.noise.stop(t + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay)), this } triggerRelease(t) { return t = this.toSeconds(t), this.envelope.triggerRelease(t), this.noise.stop(t + this.toSeconds(this.envelope.release)), this } sync() { return this._syncState() && (this._syncMethod("triggerAttack", 0), this._syncMethod("triggerRelease", 0)), this } triggerAttackRelease(t, e, s = 1) { return e = this.toSeconds(e), t = this.toSeconds(t), this.triggerAttack(e, s), this.triggerRelease(e + t), this } dispose() { return super.dispose(), this.noise.dispose(), this.envelope.dispose(), this } } const Gf = new Set; function Qf(t) { Gf.add(t) } function Zf(t, e) { t = `registerProcessor("${t}", ${e})`; Gf.add(t) } class Xf extends A { constructor(t) { super(t), this.name = "ToneAudioWorklet", this.workletOptions = {}, this.onprocessorerror = x; const e = URL.createObjectURL(new Blob([Array.from(Gf).join("\n")], { type: "text/javascript" })), s = this._audioWorkletName(); this._dummyGain = this.context.createGain(), this._dummyParam = this._dummyGain.gain, this.context.addAudioWorkletModule(e).then(() => { this.disposed || (this._worklet = this.context.createAudioWorkletNode(s, this.workletOptions), this._worklet.onprocessorerror = this.onprocessorerror.bind(this), this.onReady(this._worklet)) }) } dispose() { return super.dispose(), this._dummyGain.disconnect(), this._worklet && (this._worklet.port.postMessage("dispose"), this._worklet.disconnect()), this } } Qf('\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it\'s disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === "dispose") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n'), Qf("\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n"), Qf("\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n"); const Yf = "feedback-comb-filter"; Zf(Yf, '\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: "delayTime",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}, {\n\t\t\t\tname: "feedback",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n'); class Hf extends Xf { constructor() { var t = g(Hf.getDefaults(), arguments, ["delayTime", "resonance"]); super(t), this.name = "FeedbackCombFilter", this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this.delayTime = new k({ context: this.context, value: t.delayTime, units: "time", minValue: 0, maxValue: 1, param: this._dummyParam, swappable: !0 }), this.resonance = new k({ context: this.context, value: t.resonance, units: "normalRange", param: this._dummyParam, swappable: !0 }), y(this, ["resonance", "delayTime"]) } _audioWorkletName() { return Yf } static getDefaults() { return Object.assign(A.getDefaults(), { delayTime: .1, resonance: .5 }) } onReady(t) { wd(this.input, t, this.output); var e = t.parameters.get("delayTime"), e = (this.delayTime.setParam(e), t.parameters.get("feedback")); this.resonance.setParam(e) } dispose() { return super.dispose(), this.input.dispose(), this.output.dispose(), this.delayTime.dispose(), this.resonance.dispose(), this } } class $f extends A { constructor() { var t = g($f.getDefaults(), arguments, ["frequency", "type"]); super(t), this.name = "OnePoleFilter", this._frequency = t.frequency, this._type = t.type, this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this._createFilter() } static getDefaults() { return Object.assign(A.getDefaults(), { frequency: 880, type: "lowpass" }) } _createFilter() { const t = this._filter, e = this.toFrequency(this._frequency), s = 1 / (2 * Math.PI * e); if ("lowpass" === this._type) { const t = 1 / (s * this.context.sampleRate), e = t - 1; this._filter = this.context.createIIRFilter([t, 0], [1, e]) } else { const t = 1 / (s * this.context.sampleRate) - 1; this._filter = this.context.createIIRFilter([1, -1], [1, t]) } this.input.chain(this._filter, this.output), t && this.context.setTimeout(() => { this.disposed || (this.input.disconnect(t), t.disconnect()) }, this.blockTime) } get frequency() { return this._frequency } set frequency(t) { this._frequency = t, this._createFilter() } get type() { return this._type } set type(t) { this._type = t, this._createFilter() } getFrequencyResponse(e = 128) { const s = new Float32Array(e); for (let t = 0; t < e; t++) { const i = 19980 * Math.pow(t / e, 2) + 20; s[t] = i } const t = new Float32Array(e), i = new Float32Array(e); return this._filter.getFrequencyResponse(s, t, i), t } dispose() { return super.dispose(), this.input.dispose(), this.output.dispose(), this._filter.disconnect(), this } } class Jf extends A { constructor() { var t = g(Jf.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]); super(t), this.name = "LowpassCombFilter", this._combFilter = this.output = new Hf({ context: this.context, delayTime: t.delayTime, resonance: t.resonance }), this.delayTime = this._combFilter.delayTime, this.resonance = this._combFilter.resonance, this._lowpass = this.input = new $f({ context: this.context, frequency: t.dampening, type: "lowpass" }), this._lowpass.connect(this._combFilter) } static getDefaults() { return Object.assign(A.getDefaults(), { dampening: 3e3, delayTime: .1, resonance: .5 }) } get dampening() { return this._lowpass.frequency } set dampening(t) { this._lowpass.frequency = t } dispose() { return super.dispose(), this._combFilter.dispose(), this._lowpass.dispose(), this } } class Kf extends Df { constructor() { var t = g(Kf.getDefaults(), arguments); super(t), this.name = "PluckSynth", this._noise = new Xd({ context: this.context, type: "pink" }), this.attackNoise = t.attackNoise, this._lfcf = new Jf({ context: this.context, dampening: t.dampening, resonance: t.resonance }), this.resonance = t.resonance, this.release = t.release, this._noise.connect(this._lfcf), this._lfcf.connect(this.output) } static getDefaults() { return Lp(Df.getDefaults(), { attackNoise: 1, dampening: 4e3, resonance: .7, release: 1 }) } get dampening() { return this._lfcf.dampening } set dampening(t) { this._lfcf.dampening = t } triggerAttack(t, e) { t = this.toFrequency(t), e = this.toSeconds(e), t = 1 / t; return this._lfcf.delayTime.setValueAtTime(t, e), this._noise.start(e), this._noise.stop(e + t * this.attackNoise), this._lfcf.resonance.cancelScheduledValues(e), this._lfcf.resonance.setValueAtTime(this.resonance, e), this } triggerRelease(t) { return this._lfcf.resonance.linearRampTo(0, this.release, t), this } dispose() { return super.dispose(), this._noise.dispose(), this._lfcf.dispose(), this } } class t_ extends Df { constructor() { const t = g(t_.getDefaults(), arguments, ["voice", "options"]); super(t), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0, this._syncedRelease = t => this.releaseAll(t), l(!yp(t.voice), "DEPRECATED: The polyphony count is no longer the first argument."); var e = t.voice.getDefaults(), e = (this.options = Object.assign(e, t.options), this.voice = t.voice, this.maxPolyphony = t.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice(), this._voices.indexOf(this._dummyVoice)); this._voices.splice(e, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1) } static getDefaults() { return Object.assign(Df.getDefaults(), { maxPolyphony: 32, options: {}, voice: Rf }) } get activeVoices() { return this._activeVoices.length } _makeVoiceAvailable(e) { this._availableVoices.push(e); var t = this._activeVoices.findIndex(t => t.voice === e); this._activeVoices.splice(t, 1) } _getNextAvailableVoice() { if (this._availableVoices.length) return this._availableVoices.shift(); if (this._voices.length < this.maxPolyphony) { const t = new this.voice(Object.assign(this.options, { context: this.context, onsilence: this._makeVoiceAvailable.bind(this) })); return l(t instanceof Mf, "Voice must extend Monophonic class"), t.connect(this.output), this._voices.push(t), t } Ep("Max polyphony exceeded. Note dropped.") } _collectGarbage() { if (this._averageActiveVoices = Math.max(.95 * this._averageActiveVoices, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) { const t = this._availableVoices.shift(), e = this._voices.indexOf(t); this._voices.splice(e, 1), this.context.isOffline || t.dispose() } } _triggerAttack(t, i, n) { t.forEach(t => { const e = new Vd(this.context, t).toMidi(), s = this._getNextAvailableVoice(); s && (s.triggerAttack(t, i, n), this._activeVoices.push({ midi: e, voice: s, released: !1 }), this.log("triggerAttack", t, i)) }) } _triggerRelease(t, i) { t.forEach(t => { const s = new Vd(this.context, t).toMidi(), e = this._activeVoices.find(({ midi: t, released: e }) => t === s && !e); e && (e.voice.triggerRelease(i), e.released = !0, this.log("triggerRelease", t, i)) }) } _scheduleEvent(t, e, s, i) { l(!this.disposed, "Synth was already disposed"), s <= this.now() ? "attack" === t ? this._triggerAttack(e, s, i) : this._triggerRelease(e, s) : this.context.setTimeout(() => { this.disposed || this._scheduleEvent(t, e, s, i) }, s - this.now()) } triggerAttack(t, e, s) { Array.isArray(t) || (t = [t]); e = this.toSeconds(e); return this._scheduleEvent("attack", t, e, s), this } triggerRelease(t, e) { Array.isArray(t) || (t = [t]); e = this.toSeconds(e); return this._scheduleEvent("release", t, e), this } triggerAttackRelease(e, s, t, i) { var n = this.toSeconds(t); if (this.triggerAttack(e, n, i), d(s)) { l(d(e), "If the duration is an array, the notes must also be an array"); for (let t = 0; t < e.length; t++) { const i = s[Math.min(t, s.length - 1)], r = this.toSeconds(i); l(0 < r, "The duration must be greater than 0"), this.triggerRelease(e[t], n + r) } } else { const t = this.toSeconds(s); l(0 < t, "The duration must be greater than 0"), this.triggerRelease(e, n + t) } return this } sync() { return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this } set(t) { const e = v(t, ["onsilence", "context"]); return this.options = Lp(this.options, e), this._voices.forEach(t => t.set(e)), this._dummyVoice.set(e), this } get() { return this._dummyVoice.get() } releaseAll(t) { const e = this.toSeconds(t); return this._activeVoices.forEach(({ voice: t }) => { t.triggerRelease(e) }), this } dispose() { return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach(t => t.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this } } class e_ extends Df { constructor() { const s = g(e_.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"), i = (super(s), this.name = "Sampler", this._activeSources = new Map, {}); Object.keys(s.urls).forEach(t => { const e = parseInt(t, 10); if (l(Tp(t) || yp(e) && isFinite(e), "url key is neither a note or midi pitch: " + t), Tp(t)) { const e = new gd(this.context, t).toMidi(); i[e] = s.urls[t] } else yp(e) && isFinite(e) && (i[e] = s.urls[e]) }), this._buffers = new Fd({ urls: i, onload: s.onload, baseUrl: s.baseUrl, onerror: s.onerror }), this.attack = s.attack, this.release = s.release, this.curve = s.curve, this._buffers.loaded && Promise.resolve().then(s.onload) } static getDefaults() { return Object.assign(Df.getDefaults(), { attack: 0, baseUrl: "", curve: "exponential", onload: x, onerror: x, release: .1, urls: {} }) } _findClosest(t) { let e = 0; for (; e < 96;) { if (this._buffers.has(t + e)) return -e; if (this._buffers.has(t - e)) return e; e++ } throw new Error("No available buffers for note: " + t) } triggerAttack(t, c, l = 1) { return this.log("triggerAttack", t, c, l), (t = Array.isArray(t) ? t : [t]).forEach(t => { const e = dd(new gd(this.context, t).toFrequency()), s = Math.round(e), i = e - s, n = this._findClosest(s), r = s - n, o = this._buffers.get(r), a = ld(n + i), h = new Zd({ url: o, context: this.context, curve: this.curve, fadeIn: this.attack, fadeOut: this.release, playbackRate: a }).connect(this.output); h.start(c, 0, o.duration / a, l), d(this._activeSources.get(s)) || this._activeSources.set(s, []), this._activeSources.get(s).push(h), h.onended = () => { if (this._activeSources && this._activeSources.has(s)) { const t = this._activeSources.get(s), e = t.indexOf(h); -1 !== e && t.splice(e, 1) } } }), this } triggerRelease(t, s) { return this.log("triggerRelease", t, s), (t = Array.isArray(t) ? t : [t]).forEach(t => { var e = new gd(this.context, t).toMidi(); if (this._activeSources.has(e) && this._activeSources.get(e).length) { const t = this._activeSources.get(e); s = this.toSeconds(s), t.forEach(t => { t.stop(s) }), this._activeSources.set(e, []) } }), this } releaseAll(t) { const e = this.toSeconds(t); return this._activeSources.forEach(t => { for (; t.length;)t.shift().stop(e) }), this } sync() { return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this } triggerAttackRelease(t, s, e, i = 1) { const n = this.toSeconds(e); return this.triggerAttack(t, n, i), d(s) ? (l(d(t), "notes must be an array when duration is array"), t.forEach((t, e) => { e = s[Math.min(e, s.length - 1)]; this.triggerRelease(t, n + this.toSeconds(e)) })) : this.triggerRelease(t, n + this.toSeconds(s)), this } add(t, e, s) { var i; return l(Tp(t) || isFinite(t), "note must be a pitch or midi: " + t), Tp(t) ? (i = new gd(this.context, t).toMidi(), this._buffers.add(i, e, s)) : this._buffers.add(t, e, s), this } get loaded() { return this._buffers.loaded } dispose() { return super.dispose(), this._buffers.dispose(), this._activeSources.forEach(t => { t.forEach(t => t.dispose()) }), this._activeSources.clear(), this } } Ip([_f(0)], e_.prototype, "attack", void 0), Ip([_f(0)], e_.prototype, "release", void 0); class s_ extends S { constructor() { var t = g(s_.getDefaults(), arguments, ["callback", "value"]); super(t), this.name = "ToneEvent", this._state = new xd("stopped"), this._startOffset = 0, this._loop = t.loop, this.callback = t.callback, this.value = t.value, this._loopStart = this.toTicks(t.loopStart), this._loopEnd = this.toTicks(t.loopEnd), this._playbackRate = t.playbackRate, this._probability = t.probability, this._humanize = t.humanize, this.mute = t.mute, this._playbackRate = t.playbackRate, this._state.increasing = !0, this._rescheduleEvents() } static getDefaults() { return Object.assign(S.getDefaults(), { callback: x, humanize: !1, loop: !1, loopEnd: "1m", loopStart: 0, mute: !1, playbackRate: 1, probability: 1, value: null }) } _rescheduleEvents(t = -1) { this._state.forEachFrom(t, t => { let e; var s, i; "started" === t.state && (-1 !== t.id && this.context.transport.clear(t.id), s = t.time + Math.round(this.startOffset / this._playbackRate), !0 === this._loop || yp(this._loop) && 1 < this._loop ? (e = 1 / 0, yp(this._loop) && (e = this._loop * this._getLoopDuration()), i = this._state.getAfter(s), (e = null !== i ? Math.min(e, i.time - s) : e) !== 1 / 0 && (e = new D(this.context, e)), i = new D(this.context, this._getLoopDuration()), t.id = this.context.transport.scheduleRepeat(this._tick.bind(this), i, new D(this.context, s), e)) : t.id = this.context.transport.schedule(this._tick.bind(this), new D(this.context, s))) }) } get state() { return this._state.getValueAtTime(this.context.transport.ticks) } get startOffset() { return this._startOffset } set startOffset(t) { this._startOffset = t } get probability() { return this._probability } set probability(t) { this._probability = t } get humanize() { return this._humanize } set humanize(t) { this._humanize = t } start(t) { t = this.toTicks(t); return "stopped" === this._state.getValueAtTime(t) && (this._state.add({ id: -1, state: "started", time: t }), this._rescheduleEvents(t)), this } stop(e) { this.cancel(e); var s = this.toTicks(e); if ("started" === this._state.getValueAtTime(s)) { this._state.setStateAtTime("stopped", s, { id: -1 }); const e = this._state.getBefore(s); let t = s; null !== e && (t = e.time), this._rescheduleEvents(t) } return this } cancel(t) { t = zp(t, -1 / 0); t = this.toTicks(t); return this._state.forEachFrom(t, t => { this.context.transport.clear(t.id) }), this._state.cancel(t), this } _tick(e) { var t = this.context.transport.getTicksAtTime(e); if (!(this.mute || "started" !== this._state.getValueAtTime(t) || this.probability < 1 && Math.random() > this.probability)) { if (this.humanize) { let t = .02; wp(this.humanize) || (t = this.toSeconds(this.humanize)), e += (2 * Math.random() - 1) * t } this.callback(e, this.value) } } _getLoopDuration() { return (this._loopEnd - this._loopStart) / this._playbackRate } get loop() { return this._loop } set loop(t) { this._loop = t, this._rescheduleEvents() } get playbackRate() { return this._playbackRate } set playbackRate(t) { this._playbackRate = t, this._rescheduleEvents() } get loopEnd() { return new D(this.context, this._loopEnd).toSeconds() } set loopEnd(t) { this._loopEnd = this.toTicks(t), this._loop && this._rescheduleEvents() } get loopStart() { return new D(this.context, this._loopStart).toSeconds() } set loopStart(t) { this._loopStart = this.toTicks(t), this._loop && this._rescheduleEvents() } get progress() { var t, e, s; return this._loop ? (t = this.context.transport.ticks, null !== (e = this._state.get(t)) && "started" === e.state ? (s = this._getLoopDuration(), (t - e.time) % s / s) : 0) : 0 } dispose() { return super.dispose(), this.cancel(), this._state.dispose(), this } } class i_ extends S { constructor() { var t = g(i_.getDefaults(), arguments, ["callback", "interval"]); super(t), this.name = "Loop", this._event = new s_({ context: this.context, callback: this._tick.bind(this), loop: !0, loopEnd: t.interval, playbackRate: t.playbackRate, probability: t.probability, humanize: t.humanize }), this.callback = t.callback, this.iterations = t.iterations } static getDefaults() { return Object.assign(S.getDefaults(), { interval: "4n", callback: x, playbackRate: 1, iterations: 1 / 0, probability: 1, mute: !1, humanize: !1 }) } start(t) { return this._event.start(t), this } stop(t) { return this._event.stop(t), this } cancel(t) { return this._event.cancel(t), this } _tick(t) { this.callback(t) } get state() { return this._event.state } get progress() { return this._event.progress } get interval() { return this._event.loopEnd } set interval(t) { this._event.loopEnd = t } get playbackRate() { return this._event.playbackRate } set playbackRate(t) { this._event.playbackRate = t } get humanize() { return this._event.humanize } set humanize(t) { this._event.humanize = t } get probability() { return this._event.probability } set probability(t) { this._event.probability = t } get mute() { return this._event.mute } set mute(t) { this._event.mute = t } get iterations() { return !0 === this._event.loop ? 1 / 0 : this._event.loop } set iterations(t) { this._event.loop = t === 1 / 0 || t } dispose() { return super.dispose(), this._event.dispose(), this } } class n_ extends s_ { constructor() { const t = g(n_.getDefaults(), arguments, ["callback", "events"]); super(t), this.name = "Part", this._state = new xd("stopped"), this._events = new Set, this._state.increasing = !0, t.events.forEach(t => { d(t) ? this.add(t[0], t[1]) : this.add(t) }) } static getDefaults() { return Object.assign(s_.getDefaults(), { events: [] }) } start(e, t) { const s = this.toTicks(e); if ("started" !== this._state.getValueAtTime(s)) { t = zp(t, this._loop ? this._loopStart : 0), t = this._loop ? zp(t, this._loopStart) : zp(t, 0); const e = this.toTicks(t); this._state.add({ id: -1, offset: e, state: "started", time: s }), this._forEach(t => { this._startNote(t, s, e) }) } return this } _startNote(t, e, s) { e -= s, this._loop ? t.startOffset >= this._loopStart && t.startOffset < this._loopEnd ? (t.startOffset < s && (e += this._getLoopDuration()), t.start(new D(this.context, e))) : t.startOffset < this._loopStart && t.startOffset >= s && (t.loop = !1, t.start(new D(this.context, e))) : t.startOffset >= s && t.start(new D(this.context, e)) } get startOffset() { return this._startOffset } set startOffset(t) { this._startOffset = t, this._forEach(t => { t.startOffset += this._startOffset }) } stop(e) { var t = this.toTicks(e); return this._state.cancel(t), this._state.setStateAtTime("stopped", t), this._forEach(t => { t.stop(e) }), this } at(t, e) { const s = new T(this.context, t).toTicks(), i = new D(this.context, 1).toSeconds(), n = this._events.values(); let r = n.next(); for (; !r.done;) { const t = r.value; if (Math.abs(s - t.startOffset) < i) return o(e) && (t.value = e), t; r = n.next() } return o(e) ? (this.add(t, e), this.at(t)) : null } add(t, e) { t instanceof Object && Reflect.has(t, "time") && (t = (e = t).time); t = this.toTicks(t); let s; return e instanceof s_ ? (s = e).callback = this._tick.bind(this) : s = new s_({ callback: this._tick.bind(this), context: this.context, value: e }), s.startOffset = t, s.set({ humanize: this.humanize, loop: this.loop, loopEnd: this.loopEnd, loopStart: this.loopStart, playbackRate: this.playbackRate, probability: this.probability }), this._events.add(s), this._restartEvent(s), this } _restartEvent(e) { this._state.forEach(t => { "started" === t.state ? this._startNote(e, t.time, t.offset) : e.stop(new D(this.context, t.time)) }) } remove(e, s) { return xp(e) && e.hasOwnProperty("time") && (e = (s = e).time), e = this.toTicks(e), this._events.forEach(t => { t.startOffset === e && (gp(s) || o(s) && t.value === s) && (this._events.delete(t), t.dispose()) }), this } clear() { return this._forEach(t => t.dispose()), this._events.clear(), this } cancel(e) { return this._forEach(t => t.cancel(e)), this._state.cancel(this.toTicks(e)), this } _forEach(e) { return this._events && this._events.forEach(t => { t instanceof n_ ? t._forEach(e) : e(t) }), this } _setAll(e, s) { this._forEach(t => { t[e] = s }) } _tick(t, e) { this.mute || this.callback(t, e) } _testLoopBoundries(t) { this._loop && (t.startOffset < this._loopStart || t.startOffset >= this._loopEnd) ? t.cancel(0) : "stopped" === t.state && this._restartEvent(t) } get probability() { return this._probability } set probability(t) { this._probability = t, this._setAll("probability", t) } get humanize() { return this._humanize } set humanize(t) { this._humanize = t, this._setAll("humanize", t) } get loop() { return this._loop } set loop(e) { this._loop = e, this._forEach(t => { t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.loop = e, this._testLoopBoundries(t) }) } get loopEnd() { return new D(this.context, this._loopEnd).toSeconds() } set loopEnd(e) { this._loopEnd = this.toTicks(e), this._loop && this._forEach(t => { t.loopEnd = e, this._testLoopBoundries(t) }) } get loopStart() { return new D(this.context, this._loopStart).toSeconds() } set loopStart(t) { this._loopStart = this.toTicks(t), this._loop && this._forEach(t => { t.loopStart = this.loopStart, this._testLoopBoundries(t) }) } get playbackRate() { return this._playbackRate } set playbackRate(t) { this._playbackRate = t, this._setAll("playbackRate", t) } get length() { return this._events.size } dispose() { return super.dispose(), this.clear(), this } } function* r_(t) { let e = 0; for (; e < t;)yield e = Xp(e, 0, t - 1), e++ } function* o_(t) { let e = t - 1; for (; 0 <= e;)yield e = Xp(e, 0, t - 1), e-- } function* a_(t, e) { for (; ;)yield* e(t) } function* h_(t, e) { let s = e ? 0 : t - 1; for (; ;)yield s = Xp(s, 0, t - 1), e ? ++s >= t - 1 && (e = !1) : --s <= 0 && (e = !0) } function* c_(t) { let e = 0, s = 0; for (; e < t;)yield e = Xp(e, 0, t - 1), s++, e += s % 2 ? 2 : -1 } function* l_(t) { let e = t - 1, s = 0; for (; 0 <= e;)yield e = Xp(e, 0, t - 1), s++, e += s % 2 ? -2 : 1 } function* u_(e) { const s = []; for (let t = 0; t < e; t++)s.push(t); for (; 0 < s.length;)yield Xp(s.splice(Math.floor(s.length * Math.random()), 1)[0], 0, e - 1) } function* p_(e, t = "up") { switch (l(1 <= e, "The number of values must be at least one"), t) { case "up": yield* a_(e, r_); case "down": yield* a_(e, o_); case "upDown": yield* h_(e, !0); case "downUp": yield* h_(e, !1); case "alternateUp": yield* a_(e, c_); case "alternateDown": yield* a_(e, l_); case "random": for (var s = e; ;)yield Math.floor(Math.random() * s); case "randomOnce": yield* a_(e, u_); case "randomWalk": { var i = e; let t = Math.floor(Math.random() * i); for (; ;)0 !== t && (t === i - 1 || Math.random() < .5) ? t-- : t++, yield t } } } class d_ extends i_ { constructor() { var t = g(d_.getDefaults(), arguments, ["callback", "values", "pattern"]); super(t), this.name = "Pattern", this.callback = t.callback, this._values = t.values, this._pattern = p_(t.values.length, t.pattern), this._type = t.pattern } static getDefaults() { return Object.assign(i_.getDefaults(), { pattern: "up", values: [], callback: x }) } _tick(t) { var e = this._pattern.next(); this._index = e.value, this._value = this._values[e.value], this.callback(t, this._value) } get values() { return this._values } set values(t) { this._values = t, this.pattern = this._type } get value() { return this._value } get index() { return this._index } get pattern() { return this._type } set pattern(t) { this._type = t, this._pattern = p_(this._values.length, this._type) } } class f_ extends s_ { constructor() { var t = g(f_.getDefaults(), arguments, ["callback", "events", "subdivision"]); super(t), this.name = "Sequence", this._part = new n_({ callback: this._seqCallback.bind(this), context: this.context }), this._events = [], this._eventsArray = [], this._subdivision = this.toTicks(t.subdivision), this.events = t.events, this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this.playbackRate = t.playbackRate, this.probability = t.probability, this.humanize = t.humanize, this.mute = t.mute, this.playbackRate = t.playbackRate } static getDefaults() { return Object.assign(v(s_.getDefaults(), ["value"]), { events: [], loop: !0, loopEnd: 0, loopStart: 0, subdivision: "8n" }) } _seqCallback(t, e) { null === e || this.mute || this.callback(t, e) } get events() { return this._events } set events(t) { this.clear(), this._eventsArray = t, this._events = this._createSequence(this._eventsArray), this._eventsUpdated() } start(t, e) { return this._part.start(t, e && this._indexTime(e)), this } stop(t) { return this._part.stop(t), this } get subdivision() { return new D(this.context, this._subdivision).toSeconds() } _createSequence(t) { return new Proxy(t, { get: (t, e) => t[e], set: (t, e, s) => (bp(e) && isFinite(parseInt(e, 10)) && d(s) ? t[e] = this._createSequence(s) : t[e] = s, this._eventsUpdated(), !0) }) } _eventsUpdated() { this._part.clear(), this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset), this.loopEnd = this.loopEnd } _rescheduleSequence(t, s, i) { t.forEach((t, e) => { e = e * s + i; if (d(t)) this._rescheduleSequence(t, s / t.length, e); else { const s = new D(this.context, e, "i").toSeconds(); this._part.add(s, t) } }) } _indexTime(t) { return new D(this.context, t * this._subdivision + this.startOffset).toSeconds() } clear() { return this._part.clear(), this } dispose() { return super.dispose(), this._part.dispose(), this } get loop() { return this._part.loop } set loop(t) { this._part.loop = t } get loopStart() { return this._loopStart } set loopStart(t) { this._loopStart = t, this._part.loopStart = this._indexTime(t) } get loopEnd() { return this._loopEnd } set loopEnd(t) { this._loopEnd = t, this._part.loopEnd = 0 === t ? this._indexTime(this._eventsArray.length) : this._indexTime(t) } get startOffset() { return this._part.startOffset } set startOffset(t) { this._part.startOffset = t } get playbackRate() { return this._part.playbackRate } set playbackRate(t) { this._part.playbackRate = t } get probability() { return this._part.probability } set probability(t) { this._part.probability = t } get progress() { return this._part.progress } get humanize() { return this._part.humanize } set humanize(t) { this._part.humanize = t } get length() { return this._part.length } } class __ extends A { constructor() { var t = g(__.getDefaults(), arguments, ["fade"]); super(t), this.name = "CrossFade", this._panner = this.context.createStereoPanner(), this._split = this.context.createChannelSplitter(2), this._g2a = new xf({ context: this.context }), this.a = new C({ context: this.context, gain: 0 }), this.b = new C({ context: this.context, gain: 0 }), this.output = new C({ context: this.context }), this._internalChannels = [this.a, this.b], this.fade = new O({ context: this.context, units: "normalRange", value: t.fade }), y(this, "fade"), this.context.getConstant(1).connect(this._panner), this._panner.connect(this._split), this._panner.channelCount = 1, this._panner.channelCountMode = "explicit", bd(this._split, this.a.gain, 0), bd(this._split, this.b.gain, 1), this.fade.chain(this._g2a, this._panner.pan), this.a.connect(this.output), this.b.connect(this.output) } static getDefaults() { return Object.assign(A.getDefaults(), { fade: .5 }) } dispose() { return super.dispose(), this.a.dispose(), this.b.dispose(), this.output.dispose(), this.fade.dispose(), this._g2a.dispose(), this._panner.disconnect(), this._split.disconnect(), this } } class I extends A { constructor(t) { super(t), this.name = "Effect", this._dryWet = new __({ context: this.context }), this.wet = this._dryWet.fade, this.effectSend = new C({ context: this.context }), this.effectReturn = new C({ context: this.context }), this.input = new C({ context: this.context }), this.output = this._dryWet, this.input.fan(this._dryWet.a, this.effectSend), this.effectReturn.connect(this._dryWet.b), this.wet.setValueAtTime(t.wet, 0), this._internalChannels = [this.effectReturn, this.effectSend], y(this, "wet") } static getDefaults() { return Object.assign(A.getDefaults(), { wet: 1 }) } connectEffect(t) { return this._internalChannels.push(t), this.effectSend.chain(t, this.effectReturn), this } dispose() { return super.dispose(), this._dryWet.dispose(), this.effectSend.dispose(), this.effectReturn.dispose(), this.wet.dispose(), this } } class m_ extends I { constructor(t) { super(t), this.name = "LFOEffect", this._lfo = new df({ context: this.context, frequency: t.frequency, amplitude: t.depth }), this.depth = this._lfo.amplitude, this.frequency = this._lfo.frequency, this.type = t.type, y(this, ["frequency", "depth"]) } static getDefaults() { return Object.assign(I.getDefaults(), { frequency: 1, type: "sine", depth: 1 }) } start(t) { return this._lfo.start(t), this } stop(t) { return this._lfo.stop(t), this } sync() { return this._lfo.sync(), this } unsync() { return this._lfo.unsync(), this } get type() { return this._lfo.type } set type(t) { this._lfo.type = t } dispose() { return super.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this } } class g_ extends m_ { constructor() { var t = g(g_.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]); super(t), this.name = "AutoFilter", this.filter = new Vf(Object.assign(t.filter, { context: this.context })), this.connectEffect(this.filter), this._lfo.connect(this.filter.frequency), this.octaves = t.octaves, this.baseFrequency = t.baseFrequency } static getDefaults() { return Object.assign(m_.getDefaults(), { baseFrequency: 200, octaves: 2.6, filter: { type: "lowpass", rolloff: -12, Q: 1 } }) } get baseFrequency() { return this._lfo.min } set baseFrequency(t) { this._lfo.min = this.toFrequency(t), this.octaves = this._octaves } get octaves() { return this._octaves } set octaves(t) { this._octaves = t, this._lfo.max = this._lfo.min * Math.pow(2, t) } dispose() { return super.dispose(), this.filter.dispose(), this } } class v_ extends A { constructor() { var t = g(v_.getDefaults(), arguments, ["pan"]); super(t), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner, this.pan = new k({ context: this.context, param: this._panner.pan, value: t.pan, minValue: -1, maxValue: 1 }), this._panner.channelCount = t.channelCount, this._panner.channelCountMode = "explicit", y(this, "pan") } static getDefaults() { return Object.assign(A.getDefaults(), { pan: 0, channelCount: 1 }) } dispose() { return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this } } class y_ extends m_ { constructor() { var t = g(y_.getDefaults(), arguments, ["frequency"]); super(t), this.name = "AutoPanner", this._panner = new v_({ context: this.context, channelCount: t.channelCount }), this.connectEffect(this._panner), this._lfo.connect(this._panner.pan), this._lfo.min = -1, this._lfo.max = 1 } static getDefaults() { return Object.assign(m_.getDefaults(), { channelCount: 1 }) } dispose() { return super.dispose(), this._panner.dispose(), this } } class x_ extends A { constructor() { var t = g(x_.getDefaults(), arguments, ["smoothing"]); super(t), this.name = "Follower", this._abs = this.input = new yf({ context: this.context }), this._lowpass = this.output = new $f({ context: this.context, frequency: 1 / this.toSeconds(t.smoothing), type: "lowpass" }), this._abs.connect(this._lowpass), this._smoothing = t.smoothing } static getDefaults() { return Object.assign(A.getDefaults(), { smoothing: .05 }) } get smoothing() { return this._smoothing } set smoothing(t) { this._smoothing = t, this._lowpass.frequency = 1 / this.toSeconds(this.smoothing) } dispose() { return super.dispose(), this._abs.dispose(), this._lowpass.dispose(), this } } class w_ extends I { constructor() { var t = g(w_.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]); super(t), this.name = "AutoWah", this._follower = new x_({ context: this.context, smoothing: t.follower }), this._sweepRange = new kf({ context: this.context, min: 0, max: 1, exponent: .5 }), this._baseFrequency = this.toFrequency(t.baseFrequency), this._octaves = t.octaves, this._inputBoost = new C({ context: this.context }), this._bandpass = new Vf({ context: this.context, rolloff: -48, frequency: 0, Q: t.Q }), this._peaking = new Vf({ context: this.context, type: "peaking" }), this._peaking.gain.value = t.gain, this.gain = this._peaking.gain, this.Q = this._bandpass.Q, this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange), this._sweepRange.connect(this._bandpass.frequency), this._sweepRange.connect(this._peaking.frequency), this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn), this._setSweepRange(), this.sensitivity = t.sensitivity, y(this, ["gain", "Q"]) } static getDefaults() { return Object.assign(I.getDefaults(), { baseFrequency: 100, octaves: 6, sensitivity: 0, Q: 2, gain: 2, follower: .2 }) } get octaves() { return this._octaves } set octaves(t) { this._octaves = t, this._setSweepRange() } get follower() { return this._follower.smoothing } set follower(t) { this._follower.smoothing = t } get baseFrequency() { return this._baseFrequency } set baseFrequency(t) { this._baseFrequency = this.toFrequency(t), this._setSweepRange() } get sensitivity() { return cd(1 / this._inputBoost.gain.value) } set sensitivity(t) { this._inputBoost.gain.value = 1 / hd(t) } _setSweepRange() { this._sweepRange.min = this._baseFrequency, this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2) } dispose() { return super.dispose(), this._follower.dispose(), this._sweepRange.dispose(), this._bandpass.dispose(), this._peaking.dispose(), this._inputBoost.dispose(), this } } const b_ = "bit-crusher"; Zf(b_, "\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n"); class T_ extends I { constructor() { var t = g(T_.getDefaults(), arguments, ["bits"]); super(t), this.name = "BitCrusher", this._bitCrusherWorklet = new S_({ context: this.context, bits: t.bits }), this.connectEffect(this._bitCrusherWorklet), this.bits = this._bitCrusherWorklet.bits } static getDefaults() { return Object.assign(I.getDefaults(), { bits: 4 }) } dispose() { return super.dispose(), this._bitCrusherWorklet.dispose(), this } } class S_ extends Xf { constructor() { var t = g(S_.getDefaults(), arguments); super(t), this.name = "BitCrusherWorklet", this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this.bits = new k({ context: this.context, value: t.bits, units: "positive", minValue: 1, maxValue: 16, param: this._dummyParam, swappable: !0 }) } static getDefaults() { return Object.assign(Xf.getDefaults(), { bits: 12 }) } _audioWorkletName() { return b_ } onReady(t) { wd(this.input, t, this.output); t = t.parameters.get("bits"); this.bits.setParam(t) } dispose() { return super.dispose(), this.input.dispose(), this.output.dispose(), this.bits.dispose(), this } } class k_ extends I { constructor() { var t = g(k_.getDefaults(), arguments, ["order"]); super(t), this.name = "Chebyshev", this._shaper = new Wd({ context: this.context, length: 4096 }), this._order = t.order, this.connectEffect(this._shaper), this.order = t.order, this.oversample = t.oversample } static getDefaults() { return Object.assign(I.getDefaults(), { order: 1, oversample: "none" }) } _getCoefficient(t, e, s) { return s.has(e) || (0 === e ? s.set(e, 0) : 1 === e ? s.set(e, t) : s.set(e, 2 * t * this._getCoefficient(t, e - 1, s) - this._getCoefficient(t, e - 2, s))), s.get(e) } get order() { return this._order } set order(e) { l(Number.isInteger(e), "'order' must be an integer"), this._order = e, this._shaper.setMap(t => this._getCoefficient(t, e, new Map)) } get oversample() { return this._shaper.oversample } set oversample(t) { this._shaper.oversample = t } dispose() { return super.dispose(), this._shaper.dispose(), this } } class A_ extends A { constructor() { var t = g(A_.getDefaults(), arguments, ["channels"]); super(t), this.name = "Split", this._splitter = this.input = this.output = this.context.createChannelSplitter(t.channels), this._internalChannels = [this._splitter] } static getDefaults() { return Object.assign(A.getDefaults(), { channels: 2 }) } dispose() { return super.dispose(), this._splitter.disconnect(), this } } class C_ extends A { constructor() { var t = g(C_.getDefaults(), arguments, ["channels"]); super(t), this.name = "Merge", this._merger = this.output = this.input = this.context.createChannelMerger(t.channels) } static getDefaults() { return Object.assign(A.getDefaults(), { channels: 2 }) } dispose() { return super.dispose(), this._merger.disconnect(), this } } class O_ extends A { constructor(t) { super(t), this.name = "StereoEffect", this.input = new C({ context: this.context }), this.input.channelCount = 2, this.input.channelCountMode = "explicit", this._dryWet = this.output = new __({ context: this.context, fade: t.wet }), this.wet = this._dryWet.fade, this._split = new A_({ context: this.context, channels: 2 }), this._merge = new C_({ context: this.context, channels: 2 }), this.input.connect(this._split), this.input.connect(this._dryWet.a), this._merge.connect(this._dryWet.b), y(this, ["wet"]) } connectEffectLeft(...t) { this._split.connect(t[0], 0, 0), wd(...t), bd(t[t.length - 1], this._merge, 0, 0) } connectEffectRight(...t) { this._split.connect(t[0], 1, 0), wd(...t), bd(t[t.length - 1], this._merge, 0, 1) } static getDefaults() { return Object.assign(A.getDefaults(), { wet: 1 }) } dispose() { return super.dispose(), this._dryWet.dispose(), this._split.dispose(), this._merge.dispose(), this } } class D_ extends O_ { constructor(t) { super(t), this.feedback = new O({ context: this.context, value: t.feedback, units: "normalRange" }), this._feedbackL = new C({ context: this.context }), this._feedbackR = new C({ context: this.context }), this._feedbackSplit = new A_({ context: this.context, channels: 2 }), this._feedbackMerge = new C_({ context: this.context, channels: 2 }), this._merge.connect(this._feedbackSplit), this._feedbackMerge.connect(this._split), this._feedbackSplit.connect(this._feedbackL, 0, 0), this._feedbackL.connect(this._feedbackMerge, 0, 0), this._feedbackSplit.connect(this._feedbackR, 1, 0), this._feedbackR.connect(this._feedbackMerge, 0, 1), this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain), y(this, ["feedback"]) } static getDefaults() { return Object.assign(O_.getDefaults(), { feedback: .5 }) } dispose() { return super.dispose(), this.feedback.dispose(), this._feedbackL.dispose(), this._feedbackR.dispose(), this._feedbackSplit.dispose(), this._feedbackMerge.dispose(), this } } class M_ extends D_ { constructor() { var t = g(M_.getDefaults(), arguments, ["frequency", "delayTime", "depth"]); super(t), this.name = "Chorus", this._depth = t.depth, this._delayTime = t.delayTime / 1e3, this._lfoL = new df({ context: this.context, frequency: t.frequency, min: 0, max: 1 }), this._lfoR = new df({ context: this.context, frequency: t.frequency, min: 0, max: 1, phase: 180 }), this._delayNodeL = new Ed({ context: this.context }), this._delayNodeR = new Ed({ context: this.context }), this.frequency = this._lfoL.frequency, y(this, ["frequency"]), this._lfoL.frequency.connect(this._lfoR.frequency), this.connectEffectLeft(this._delayNodeL), this.connectEffectRight(this._delayNodeR), this._lfoL.connect(this._delayNodeL.delayTime), this._lfoR.connect(this._delayNodeR.delayTime), this.depth = this._depth, this.type = t.type, this.spread = t.spread } static getDefaults() { return Object.assign(D_.getDefaults(), { frequency: 1.5, delayTime: 3.5, depth: .7, type: "sine", spread: 180, feedback: 0, wet: .5 }) } get depth() { return this._depth } set depth(t) { this._depth = t; t = this._delayTime * t; this._lfoL.min = Math.max(this._delayTime - t, 0), this._lfoL.max = this._delayTime + t, this._lfoR.min = Math.max(this._delayTime - t, 0), this._lfoR.max = this._delayTime + t } get delayTime() { return 1e3 * this._delayTime } set delayTime(t) { this._delayTime = t / 1e3, this.depth = this._depth } get type() { return this._lfoL.type } set type(t) { this._lfoL.type = t, this._lfoR.type = t } get spread() { return this._lfoR.phase - this._lfoL.phase } set spread(t) { this._lfoL.phase = 90 - t / 2, this._lfoR.phase = t / 2 + 90 } start(t) { return this._lfoL.start(t), this._lfoR.start(t), this } stop(t) { return this._lfoL.stop(t), this._lfoR.stop(t), this } sync() { return this._lfoL.sync(), this._lfoR.sync(), this } unsync() { return this._lfoL.unsync(), this._lfoR.unsync(), this } dispose() { return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._delayNodeL.dispose(), this._delayNodeR.dispose(), this.frequency.dispose(), this } } class E_ extends I { constructor() { var t = g(E_.getDefaults(), arguments, ["distortion"]); super(t), this.name = "Distortion", this._shaper = new Wd({ context: this.context, length: 4096 }), this._distortion = t.distortion, this.connectEffect(this._shaper), this.distortion = t.distortion, this.oversample = t.oversample } static getDefaults() { return Object.assign(I.getDefaults(), { distortion: .4, oversample: "none" }) } get distortion() { return this._distortion } set distortion(t) { const e = 100 * (this._distortion = t), s = Math.PI / 180; this._shaper.setMap(t => Math.abs(t) < .001 ? 0 : (3 + e) * t * 20 * s / (Math.PI + e * Math.abs(t))) } get oversample() { return this._shaper.oversample } set oversample(t) { this._shaper.oversample = t } dispose() { return super.dispose(), this._shaper.dispose(), this } } class R_ extends I { constructor(t) { super(t), this.name = "FeedbackEffect", this._feedbackGain = new C({ context: this.context, gain: t.feedback, units: "normalRange" }), this.feedback = this._feedbackGain.gain, y(this, "feedback"), this.effectReturn.chain(this._feedbackGain, this.effectSend) } static getDefaults() { return Object.assign(I.getDefaults(), { feedback: .125 }) } dispose() { return super.dispose(), this._feedbackGain.dispose(), this.feedback.dispose(), this } } class q_ extends R_ { constructor() { var t = g(q_.getDefaults(), arguments, ["delayTime", "feedback"]); super(t), this.name = "FeedbackDelay", this._delayNode = new Ed({ context: this.context, delayTime: t.delayTime, maxDelay: t.maxDelay }), this.delayTime = this._delayNode.delayTime, this.connectEffect(this._delayNode), y(this, "delayTime") } static getDefaults() { return Object.assign(R_.getDefaults(), { delayTime: .25, maxDelay: 1 }) } dispose() { return super.dispose(), this._delayNode.dispose(), this.delayTime.dispose(), this } } class I_ extends A { constructor(t) { super(t), this.name = "PhaseShiftAllpass", this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this.offset90 = new C({ context: this.context }), this._bank0 = this._createAllPassFilterBank([.6923878, .9360654322959, .988229522686, .9987488452737]), this._bank1 = this._createAllPassFilterBank([.4021921162426, .856171088242, .9722909545651, .9952884791278]), this._oneSampleDelay = this.context.createIIRFilter([0, 1], [1, 0]), wd(this.input, ...this._bank0, this._oneSampleDelay, this.output), wd(this.input, ...this._bank1, this.offset90) } _createAllPassFilterBank(t) { return t.map(t => { t = [[t * t, 0, -1], [1, 0, -t * t]]; return this.context.createIIRFilter(t[0], t[1]) }) } dispose() { return super.dispose(), this.input.dispose(), this.output.dispose(), this.offset90.dispose(), this._bank0.forEach(t => t.disconnect()), this._bank1.forEach(t => t.disconnect()), this._oneSampleDelay.disconnect(), this } } class F_ extends I { constructor() { var t = g(F_.getDefaults(), arguments, ["frequency"]), t = (super(t), this.name = "FrequencyShifter", this.frequency = new O({ context: this.context, units: "frequency", value: t.frequency, minValue: -this.context.sampleRate / 2, maxValue: this.context.sampleRate / 2 }), this._sine = new tf({ context: this.context, type: "sine" }), this._cosine = new E({ context: this.context, phase: -90, type: "sine" }), this._sineMultiply = new q({ context: this.context }), this._cosineMultiply = new q({ context: this.context }), this._negate = new wf({ context: this.context }), this._add = new lf({ context: this.context }), this._phaseShifter = new I_({ context: this.context }), this.effectSend.connect(this._phaseShifter), this.frequency.fan(this._sine.frequency, this._cosine.frequency), this._phaseShifter.offset90.connect(this._cosineMultiply), this._cosine.connect(this._cosineMultiply.factor), this._phaseShifter.connect(this._sineMultiply), this._sine.connect(this._sineMultiply.factor), this._sineMultiply.connect(this._negate), this._cosineMultiply.connect(this._add), this._negate.connect(this._add.addend), this._add.connect(this.effectReturn), this.immediate()); this._sine.start(t), this._cosine.start(t) } static getDefaults() { return Object.assign(I.getDefaults(), { frequency: 0 }) } dispose() { return super.dispose(), this.frequency.dispose(), this._add.dispose(), this._cosine.dispose(), this._cosineMultiply.dispose(), this._negate.dispose(), this._phaseShifter.dispose(), this._sine.dispose(), this._sineMultiply.dispose(), this } } const V_ = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100], N_ = [225, 556, 441, 341]; class P_ extends O_ { constructor() { const s = g(P_.getDefaults(), arguments, ["roomSize", "dampening"]); super(s), this.name = "Freeverb", this._combFilters = [], this._allpassFiltersL = [], this._allpassFiltersR = [], this.roomSize = new O({ context: this.context, value: s.roomSize, units: "normalRange" }), this._allpassFiltersL = N_.map(t => { const e = this.context.createBiquadFilter(); return e.type = "allpass", e.frequency.value = t, e }), this._allpassFiltersR = N_.map(t => { const e = this.context.createBiquadFilter(); return e.type = "allpass", e.frequency.value = t, e }), this._combFilters = V_.map((t, e) => { t = new Jf({ context: this.context, dampening: s.dampening, delayTime: t }); return e < V_.length / 2 ? this.connectEffectLeft(t, ...this._allpassFiltersL) : this.connectEffectRight(t, ...this._allpassFiltersR), this.roomSize.connect(t.resonance), t }), y(this, ["roomSize"]) } static getDefaults() { return Object.assign(O_.getDefaults(), { roomSize: .7, dampening: 3e3 }) } get dampening() { return this._combFilters[0].dampening } set dampening(e) { this._combFilters.forEach(t => t.dampening = e) } dispose() { return super.dispose(), this._allpassFiltersL.forEach(t => t.disconnect()), this._allpassFiltersR.forEach(t => t.disconnect()), this._combFilters.forEach(t => t.dispose()), this.roomSize.dispose(), this } } const j_ = [.06748, .06404, .08212, .09004], L_ = [.773, .802, .753, .733], z_ = [347, 113, 37]; class W_ extends O_ { constructor() { var t = g(W_.getDefaults(), arguments, ["roomSize"]); super(t), this.name = "JCReverb", this._allpassFilters = [], this._feedbackCombFilters = [], this.roomSize = new O({ context: this.context, value: t.roomSize, units: "normalRange" }), this._scaleRoomSize = new uf({ context: this.context, min: -.733, max: .197 }), this._allpassFilters = z_.map(t => { const e = this.context.createBiquadFilter(); return e.type = "allpass", e.frequency.value = t, e }), this._feedbackCombFilters = j_.map((t, e) => { const s = new Hf({ context: this.context, delayTime: t }); return this._scaleRoomSize.connect(s.resonance), s.resonance.value = L_[e], e < j_.length / 2 ? this.connectEffectLeft(...this._allpassFilters, s) : this.connectEffectRight(...this._allpassFilters, s), s }), this.roomSize.connect(this._scaleRoomSize), y(this, ["roomSize"]) } static getDefaults() { return Object.assign(O_.getDefaults(), { roomSize: .5 }) } dispose() { return super.dispose(), this._allpassFilters.forEach(t => t.disconnect()), this._feedbackCombFilters.forEach(t => t.dispose()), this.roomSize.dispose(), this._scaleRoomSize.dispose(), this } } class B_ extends D_ { constructor(t) { super(t), this._feedbackL.disconnect(), this._feedbackL.connect(this._feedbackMerge, 0, 1), this._feedbackR.disconnect(), this._feedbackR.connect(this._feedbackMerge, 0, 0), y(this, ["feedback"]) } } class U_ extends B_ { constructor() { var t = g(U_.getDefaults(), arguments, ["delayTime", "feedback"]); super(t), this.name = "PingPongDelay", this._leftDelay = new Ed({ context: this.context, maxDelay: t.maxDelay }), this._rightDelay = new Ed({ context: this.context, maxDelay: t.maxDelay }), this._rightPreDelay = new Ed({ context: this.context, maxDelay: t.maxDelay }), this.delayTime = new O({ context: this.context, units: "time", value: t.delayTime }), this.connectEffectLeft(this._leftDelay), this.connectEffectRight(this._rightPreDelay, this._rightDelay), this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime), this._feedbackL.disconnect(), this._feedbackL.connect(this._rightDelay), y(this, ["delayTime"]) } static getDefaults() { return Object.assign(B_.getDefaults(), { delayTime: .25, maxDelay: 1 }) } dispose() { return super.dispose(), this._leftDelay.dispose(), this._rightDelay.dispose(), this._rightPreDelay.dispose(), this.delayTime.dispose(), this } } class G_ extends R_ { constructor() { var t = g(G_.getDefaults(), arguments, ["pitch"]), t = (super(t), this.name = "PitchShift", this._frequency = new O({ context: this.context }), this._delayA = new Ed({ maxDelay: 1, context: this.context }), this._lfoA = new df({ context: this.context, min: 0, max: .1, type: "sawtooth" }).connect(this._delayA.delayTime), this._delayB = new Ed({ maxDelay: 1, context: this.context }), this._lfoB = new df({ context: this.context, min: 0, max: .1, type: "sawtooth", phase: 180 }).connect(this._delayB.delayTime), this._crossFade = new __({ context: this.context }), this._crossFadeLFO = new df({ context: this.context, min: 0, max: 1, type: "triangle", phase: 90 }).connect(this._crossFade.fade), this._feedbackDelay = new Ed({ delayTime: t.delayTime, context: this.context }), this.delayTime = this._feedbackDelay.delayTime, y(this, "delayTime"), this._pitch = t.pitch, this._windowSize = t.windowSize, this._delayA.connect(this._crossFade.a), this._delayB.connect(this._crossFade.b), this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency), this.effectSend.fan(this._delayA, this._delayB), this._crossFade.chain(this._feedbackDelay, this.effectReturn), this.now()); this._lfoA.start(t), this._lfoB.start(t), this._crossFadeLFO.start(t), this.windowSize = this._windowSize } static getDefaults() { return Object.assign(R_.getDefaults(), { pitch: 0, windowSize: .1, delayTime: 0, feedback: 0 }) } get pitch() { return this._pitch } set pitch(t) { this._pitch = t; let e = 0; e = t < 0 ? (this._lfoA.min = 0, this._lfoA.max = this._windowSize, this._lfoB.min = 0, this._lfoB.max = this._windowSize, ld(t - 1) + 1) : (this._lfoA.min = this._windowSize, this._lfoA.max = 0, this._lfoB.min = this._windowSize, this._lfoB.max = 0, ld(t) - 1), this._frequency.value = e * (1.2 / this._windowSize) } get windowSize() { return this._windowSize } set windowSize(t) { this._windowSize = this.toSeconds(t), this.pitch = this._pitch } dispose() { return super.dispose(), this._frequency.dispose(), this._delayA.dispose(), this._delayB.dispose(), this._lfoA.dispose(), this._lfoB.dispose(), this._crossFade.dispose(), this._crossFadeLFO.dispose(), this._feedbackDelay.dispose(), this } } class Q_ extends O_ { constructor() { var t = g(Q_.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]); super(t), this.name = "Phaser", this._lfoL = new df({ context: this.context, frequency: t.frequency, min: 0, max: 1 }), this._lfoR = new df({ context: this.context, frequency: t.frequency, min: 0, max: 1, phase: 180 }), this._baseFrequency = this.toFrequency(t.baseFrequency), this._octaves = t.octaves, this.Q = new O({ context: this.context, value: t.Q, units: "positive" }), this._filtersL = this._makeFilters(t.stages, this._lfoL), this._filtersR = this._makeFilters(t.stages, this._lfoR), this.frequency = this._lfoL.frequency, this.frequency.value = t.frequency, this.connectEffectLeft(...this._filtersL), this.connectEffectRight(...this._filtersR), this._lfoL.frequency.connect(this._lfoR.frequency), this.baseFrequency = t.baseFrequency, this.octaves = t.octaves, this._lfoL.start(), this._lfoR.start(), y(this, ["frequency", "Q"]) } static getDefaults() { return Object.assign(O_.getDefaults(), { frequency: .5, octaves: 3, stages: 10, Q: 10, baseFrequency: 350 }) } _makeFilters(e, s) { const i = []; for (let t = 0; t < e; t++) { const e = this.context.createBiquadFilter(); e.type = "allpass", this.Q.connect(e.Q), s.connect(e.frequency), i.push(e) } return i } get octaves() { return this._octaves } set octaves(t) { this._octaves = t; t = this._baseFrequency * Math.pow(2, t); this._lfoL.max = t, this._lfoR.max = t } get baseFrequency() { return this._baseFrequency } set baseFrequency(t) { this._baseFrequency = this.toFrequency(t), this._lfoL.min = this._baseFrequency, this._lfoR.min = this._baseFrequency, this.octaves = this._octaves } dispose() { return super.dispose(), this.Q.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._filtersL.forEach(t => t.disconnect()), this._filtersR.forEach(t => t.disconnect()), this.frequency.dispose(), this } } class Z_ extends I { constructor() { var t = g(Z_.getDefaults(), arguments, ["decay"]), e = (super(t), this.name = "Reverb", this._convolver = this.context.createConvolver(), this.ready = Promise.resolve(), this.toSeconds(t.decay)), e = (f(e, .001), this._decay = e, this.toSeconds(t.preDelay)); f(e, 0), this._preDelay = e, this.generate(), this.connectEffect(this._convolver) } static getDefaults() { return Object.assign(I.getDefaults(), { decay: 1.5, preDelay: .01 }) } get decay() { return this._decay } set decay(t) { f(t = this.toSeconds(t), .001), this._decay = t, this.generate() } get preDelay() { return this._preDelay } set preDelay(t) { f(t = this.toSeconds(t), 0), this._preDelay = t, this.generate() } generate() { return _(this, void 0, void 0, function* () { const t = this.ready, e = new nd(2, this._decay + this._preDelay, this.context.sampleRate), s = new Xd({ context: e }), i = new Xd({ context: e }), n = new C_({ context: e }), r = (s.connect(n, 0, 0), i.connect(n, 0, 1), new C({ context: e }).toDestination()), o = (n.connect(r), s.start(0), i.start(0), r.gain.setValueAtTime(0, 0), r.gain.setValueAtTime(1, this._preDelay), r.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay), e.render()); return this.ready = o.then(x), yield t, this._convolver.buffer = (yield o).get(), this }) } dispose() { return super.dispose(), this._convolver.disconnect(), this } } class X_ extends A { constructor() { super(g(X_.getDefaults(), arguments)), this.name = "MidSideSplit", this._split = this.input = new A_({ channels: 2, context: this.context }), this._midAdd = new lf({ context: this.context }), this.mid = new q({ context: this.context, value: Math.SQRT1_2 }), this._sideSubtract = new bf({ context: this.context }), this.side = new q({ context: this.context, value: Math.SQRT1_2 }), this._split.connect(this._midAdd, 0), this._split.connect(this._midAdd.addend, 1), this._split.connect(this._sideSubtract, 0), this._split.connect(this._sideSubtract.subtrahend, 1), this._midAdd.connect(this.mid), this._sideSubtract.connect(this.side) } dispose() { return super.dispose(), this.mid.dispose(), this.side.dispose(), this._midAdd.dispose(), this._sideSubtract.dispose(), this._split.dispose(), this } } class Y_ extends A { constructor() { super(g(Y_.getDefaults(), arguments)), this.name = "MidSideMerge", this.mid = new C({ context: this.context }), this.side = new C({ context: this.context }), this._left = new lf({ context: this.context }), this._leftMult = new q({ context: this.context, value: Math.SQRT1_2 }), this._right = new bf({ context: this.context }), this._rightMult = new q({ context: this.context, value: Math.SQRT1_2 }), this._merge = this.output = new C_({ context: this.context }), this.mid.fan(this._left), this.side.connect(this._left.addend), this.mid.connect(this._right), this.side.connect(this._right.subtrahend), this._left.connect(this._leftMult), this._right.connect(this._rightMult), this._leftMult.connect(this._merge, 0, 0), this._rightMult.connect(this._merge, 0, 1) } dispose() { return super.dispose(), this.mid.dispose(), this.side.dispose(), this._leftMult.dispose(), this._rightMult.dispose(), this._left.dispose(), this._right.dispose(), this } } class H_ extends I { constructor(t) { super(t), this.name = "MidSideEffect", this._midSideMerge = new Y_({ context: this.context }), this._midSideSplit = new X_({ context: this.context }), this._midSend = this._midSideSplit.mid, this._sideSend = this._midSideSplit.side, this._midReturn = this._midSideMerge.mid, this._sideReturn = this._midSideMerge.side, this.effectSend.connect(this._midSideSplit), this._midSideMerge.connect(this.effectReturn) } connectEffectMid(...t) { this._midSend.chain(...t, this._midReturn) } connectEffectSide(...t) { this._sideSend.chain(...t, this._sideReturn) } dispose() { return super.dispose(), this._midSideSplit.dispose(), this._midSideMerge.dispose(), this._midSend.dispose(), this._sideSend.dispose(), this._midReturn.dispose(), this._sideReturn.dispose(), this } } class $_ extends H_ { constructor() { var t = g($_.getDefaults(), arguments, ["width"]); super(t), this.name = "StereoWidener", this.width = new O({ context: this.context, value: t.width, units: "normalRange" }), y(this, ["width"]), this._twoTimesWidthMid = new q({ context: this.context, value: 2 }), this._twoTimesWidthSide = new q({ context: this.context, value: 2 }), this._midMult = new q({ context: this.context }), this._twoTimesWidthMid.connect(this._midMult.factor), this.connectEffectMid(this._midMult), this._oneMinusWidth = new bf({ context: this.context }), this._oneMinusWidth.connect(this._twoTimesWidthMid), bd(this.context.getConstant(1), this._oneMinusWidth), this.width.connect(this._oneMinusWidth.subtrahend), this._sideMult = new q({ context: this.context }), this.width.connect(this._twoTimesWidthSide), this._twoTimesWidthSide.connect(this._sideMult.factor), this.connectEffectSide(this._sideMult) } static getDefaults() { return Object.assign(H_.getDefaults(), { width: .5 }) } dispose() { return super.dispose(), this.width.dispose(), this._midMult.dispose(), this._sideMult.dispose(), this._twoTimesWidthMid.dispose(), this._twoTimesWidthSide.dispose(), this._oneMinusWidth.dispose(), this } } class J_ extends O_ { constructor() { var t = g(J_.getDefaults(), arguments, ["frequency", "depth"]); super(t), this.name = "Tremolo", this._lfoL = new df({ context: this.context, type: t.type, min: 1, max: 0 }), this._lfoR = new df({ context: this.context, type: t.type, min: 1, max: 0 }), this._amplitudeL = new C({ context: this.context }), this._amplitudeR = new C({ context: this.context }), this.frequency = new O({ context: this.context, value: t.frequency, units: "frequency" }), this.depth = new O({ context: this.context, value: t.depth, units: "normalRange" }), y(this, ["frequency", "depth"]), this.connectEffectLeft(this._amplitudeL), this.connectEffectRight(this._amplitudeR), this._lfoL.connect(this._amplitudeL.gain), this._lfoR.connect(this._amplitudeR.gain), this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency), this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude), this.spread = t.spread } static getDefaults() { return Object.assign(O_.getDefaults(), { frequency: 10, type: "sine", depth: .5, spread: 180 }) } start(t) { return this._lfoL.start(t), this._lfoR.start(t), this } stop(t) { return this._lfoL.stop(t), this._lfoR.stop(t), this } sync() { return this._lfoL.sync(), this._lfoR.sync(), this.context.transport.syncSignal(this.frequency), this } unsync() { return this._lfoL.unsync(), this._lfoR.unsync(), this.context.transport.unsyncSignal(this.frequency), this } get type() { return this._lfoL.type } set type(t) { this._lfoL.type = t, this._lfoR.type = t } get spread() { return this._lfoR.phase - this._lfoL.phase } set spread(t) { this._lfoL.phase = 90 - t / 2, this._lfoR.phase = t / 2 + 90 } dispose() { return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._amplitudeL.dispose(), this._amplitudeR.dispose(), this.frequency.dispose(), this.depth.dispose(), this } } class K_ extends I { constructor() { var t = g(K_.getDefaults(), arguments, ["frequency", "depth"]); super(t), this.name = "Vibrato", this._delayNode = new Ed({ context: this.context, delayTime: 0, maxDelay: t.maxDelay }), this._lfo = new df({ context: this.context, type: t.type, min: 0, max: t.maxDelay, frequency: t.frequency, phase: -90 }).start().connect(this._delayNode.delayTime), this.frequency = this._lfo.frequency, this.depth = this._lfo.amplitude, this.depth.value = t.depth, y(this, ["frequency", "depth"]), this.effectSend.chain(this._delayNode, this.effectReturn) } static getDefaults() { return Object.assign(I.getDefaults(), { maxDelay: .005, frequency: 5, depth: .1, type: "sine" }) } get type() { return this._lfo.type } set type(t) { this._lfo.type = t } dispose() { return super.dispose(), this._delayNode.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this } } class tm extends A { constructor() { var e = g(tm.getDefaults(), arguments, ["type", "size"]); super(e), this.name = "Analyser", this._analysers = [], this._buffers = [], this.input = this.output = this._gain = new C({ context: this.context }), this._split = new A_({ context: this.context, channels: e.channels }), this.input.connect(this._split), f(e.channels, 1); for (let t = 0; t < e.channels; t++)this._analysers[t] = this.context.createAnalyser(), this._split.connect(this._analysers[t], t, 0); this.size = e.size, this.type = e.type, this.smoothing = e.smoothing } static getDefaults() { return Object.assign(A.getDefaults(), { size: 1024, smoothing: .8, type: "fft", channels: 1 }) } getValue() { return this._analysers.forEach((t, e) => { e = this._buffers[e]; "fft" === this._type ? t.getFloatFrequencyData(e) : "waveform" === this._type && t.getFloatTimeDomainData(e) }), 1 === this.channels ? this._buffers[0] : this._buffers } get size() { return this._analysers[0].frequencyBinCount } set size(s) { this._analysers.forEach((t, e) => { t.fftSize = 2 * s, this._buffers[e] = new Float32Array(s) }) } get channels() { return this._analysers.length } get type() { return this._type } set type(t) { l("waveform" === t || "fft" === t, "Analyser: invalid type: " + t), this._type = t } get smoothing() { return this._analysers[0].smoothingTimeConstant } set smoothing(e) { this._analysers.forEach(t => t.smoothingTimeConstant = e) } dispose() { return super.dispose(), this._analysers.forEach(t => t.disconnect()), this._split.dispose(), this._gain.dispose(), this } } class em extends A { constructor() { super(g(em.getDefaults(), arguments)), this.name = "MeterBase", this.input = this.output = this._analyser = new tm({ context: this.context, size: 256, type: "waveform" }) } dispose() { return super.dispose(), this._analyser.dispose(), this } } class sm extends em { constructor() { var t = g(sm.getDefaults(), arguments, ["smoothing"]); super(t), this.name = "Meter", this.input = this.output = this._analyser = new tm({ context: this.context, size: 256, type: "waveform", channels: t.channelCount }), this.smoothing = t.smoothing, this.normalRange = t.normalRange, this._rms = new Array(t.channelCount), this._rms.fill(0) } static getDefaults() { return Object.assign(em.getDefaults(), { smoothing: .8, normalRange: !1, channelCount: 1 }) } getLevel() { return Ep("'getLevel' has been changed to 'getValue'"), this.getValue() } getValue() { const t = this._analyser.getValue(), e = (1 === this.channels ? [t] : t).map((t, e) => { var s = t.reduce((t, e) => t + e * e, 0), s = Math.sqrt(s / t.length); return this._rms[e] = Math.max(s, this._rms[e] * this.smoothing), this.normalRange ? this._rms[e] : cd(this._rms[e]) }); return 1 === this.channels ? e[0] : e } get channels() { return this._analyser.channels } dispose() { return super.dispose(), this._analyser.dispose(), this } } class im extends em { constructor() { var t = g(im.getDefaults(), arguments, ["size"]); super(t), this.name = "FFT", this.normalRange = t.normalRange, this._analyser.type = "fft", this.size = t.size } static getDefaults() { return Object.assign(A.getDefaults(), { normalRange: !1, size: 1024, smoothing: .8 }) } getValue() { return this._analyser.getValue().map(t => this.normalRange ? hd(t) : t) } get size() { return this._analyser.size } set size(t) { this._analyser.size = t } get smoothing() { return this._analyser.smoothing } set smoothing(t) { this._analyser.smoothing = t } getFrequencyOfIndex(t) { return l(0 <= t && t < this.size, "index must be greater than or equal to 0 and less than " + this.size), t * this.context.sampleRate / (2 * this.size) } } class nm extends em { constructor() { super(g(nm.getDefaults(), arguments)), this.name = "DCMeter", this._analyser.type = "waveform", this._analyser.size = 256 } getValue() { return this._analyser.getValue()[0] } } class rm extends em { constructor() { var t = g(rm.getDefaults(), arguments, ["size"]); super(t), this.name = "Waveform", this._analyser.type = "waveform", this.size = t.size } static getDefaults() { return Object.assign(em.getDefaults(), { size: 1024 }) } getValue() { return this._analyser.getValue() } get size() { return this._analyser.size } set size(t) { this._analyser.size = t } } class F extends A { constructor() { var t = g(F.getDefaults(), arguments, ["solo"]); super(t), this.name = "Solo", this.input = this.output = new C({ context: this.context }), F._allSolos.has(this.context) || F._allSolos.set(this.context, new Set), F._allSolos.get(this.context).add(this), this.solo = t.solo } static getDefaults() { return Object.assign(A.getDefaults(), { solo: !1 }) } get solo() { return this._isSoloed() } set solo(t) { t ? this._addSolo() : this._removeSolo(), F._allSolos.get(this.context).forEach(t => t._updateSolo()) } get muted() { return 0 === this.input.gain.value } _addSolo() { F._soloed.has(this.context) || F._soloed.set(this.context, new Set), F._soloed.get(this.context).add(this) } _removeSolo() { F._soloed.has(this.context) && F._soloed.get(this.context).delete(this) } _isSoloed() { return F._soloed.has(this.context) && F._soloed.get(this.context).has(this) } _noSolos() { return !F._soloed.has(this.context) || F._soloed.has(this.context) && 0 === F._soloed.get(this.context).size } _updateSolo() { this._isSoloed() || this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0 } dispose() { return super.dispose(), F._allSolos.get(this.context).delete(this), this._removeSolo(), this } } F._allSolos = new Map, F._soloed = new Map; class om extends A { constructor() { var t = g(om.getDefaults(), arguments, ["pan", "volume"]); super(t), this.name = "PanVol", this._panner = this.input = new v_({ context: this.context, pan: t.pan, channelCount: t.channelCount }), this.pan = this._panner.pan, this._volume = this.output = new Rd({ context: this.context, volume: t.volume }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = t.mute, y(this, ["pan", "volume"]) } static getDefaults() { return Object.assign(A.getDefaults(), { mute: !1, pan: 0, volume: 0, channelCount: 1 }) } get mute() { return this._volume.mute } set mute(t) { this._volume.mute = t } dispose() { return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this } } class am extends A { constructor() { var t = g(am.getDefaults(), arguments, ["volume", "pan"]); super(t), this.name = "Channel", this._solo = this.input = new F({ solo: t.solo, context: this.context }), this._panVol = this.output = new om({ context: this.context, pan: t.pan, volume: t.volume, mute: t.mute, channelCount: t.channelCount }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), y(this, ["pan", "volume"]) } static getDefaults() { return Object.assign(A.getDefaults(), { pan: 0, volume: 0, mute: !1, solo: !1, channelCount: 1 }) } get solo() { return this._solo.solo } set solo(t) { this._solo.solo = t } get muted() { return this._solo.muted || this.mute } get mute() { return this._panVol.mute } set mute(t) { this._panVol.mute = t } _getBus(t) { return am.buses.has(t) || am.buses.set(t, new C({ context: this.context })), am.buses.get(t) } send(t, e = 0) { const s = this._getBus(t), i = new C({ context: this.context, units: "decibels", gain: e }); return this.connect(i), i.connect(s), i } receive(t) { return this._getBus(t).connect(this), this } dispose() { return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this } } am.buses = new Map; class hm extends A { constructor() { super(g(hm.getDefaults(), arguments)), this.name = "Mono", this.input = new C({ context: this.context }), this._merge = this.output = new C_({ channels: 2, context: this.context }), this.input.connect(this._merge, 0, 0), this.input.connect(this._merge, 0, 1) } dispose() { return super.dispose(), this._merge.dispose(), this.input.dispose(), this } } class cm extends A { constructor() { var t = g(cm.getDefaults(), arguments, ["lowFrequency", "highFrequency"]); super(t), this.name = "MultibandSplit", this.input = new C({ context: this.context }), this.output = void 0, this.low = new Vf({ context: this.context, frequency: 0, type: "lowpass" }), this._lowMidFilter = new Vf({ context: this.context, frequency: 0, type: "highpass" }), this.mid = new Vf({ context: this.context, frequency: 0, type: "lowpass" }), this.high = new Vf({ context: this.context, frequency: 0, type: "highpass" }), this._internalChannels = [this.low, this.mid, this.high], this.lowFrequency = new O({ context: this.context, units: "frequency", value: t.lowFrequency }), this.highFrequency = new O({ context: this.context, units: "frequency", value: t.highFrequency }), this.Q = new O({ context: this.context, units: "positive", value: t.Q }), this.input.fan(this.low, this.high), this.input.chain(this._lowMidFilter, this.mid), this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency), this.highFrequency.fan(this.mid.frequency, this.high.frequency), this.Q.connect(this.low.Q), this.Q.connect(this._lowMidFilter.Q), this.Q.connect(this.mid.Q), this.Q.connect(this.high.Q), y(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]) } static getDefaults() { return Object.assign(A.getDefaults(), { Q: 1, highFrequency: 2500, lowFrequency: 400 }) } dispose() { return super.dispose(), id(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]), this.low.dispose(), this._lowMidFilter.dispose(), this.mid.dispose(), this.high.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this.Q.dispose(), this } } class lm extends A { constructor() { var t = g(lm.getDefaults(), arguments, ["positionX", "positionY", "positionZ"]); super(t), this.name = "Panner3D", this._panner = this.input = this.output = this.context.createPanner(), this.panningModel = t.panningModel, this.maxDistance = t.maxDistance, this.distanceModel = t.distanceModel, this.coneOuterGain = t.coneOuterGain, this.coneOuterAngle = t.coneOuterAngle, this.coneInnerAngle = t.coneInnerAngle, this.refDistance = t.refDistance, this.rolloffFactor = t.rolloffFactor, this.positionX = new k({ context: this.context, param: this._panner.positionX, value: t.positionX }), this.positionY = new k({ context: this.context, param: this._panner.positionY, value: t.positionY }), this.positionZ = new k({ context: this.context, param: this._panner.positionZ, value: t.positionZ }), this.orientationX = new k({ context: this.context, param: this._panner.orientationX, value: t.orientationX }), this.orientationY = new k({ context: this.context, param: this._panner.orientationY, value: t.orientationY }), this.orientationZ = new k({ context: this.context, param: this._panner.orientationZ, value: t.orientationZ }) } static getDefaults() { return Object.assign(A.getDefaults(), { coneInnerAngle: 360, coneOuterAngle: 360, coneOuterGain: 0, distanceModel: "inverse", maxDistance: 1e4, orientationX: 0, orientationY: 0, orientationZ: 0, panningModel: "equalpower", positionX: 0, positionY: 0, positionZ: 0, refDistance: 1, rolloffFactor: 1 }) } setPosition(t, e, s) { return this.positionX.value = t, this.positionY.value = e, this.positionZ.value = s, this } setOrientation(t, e, s) { return this.orientationX.value = t, this.orientationY.value = e, this.orientationZ.value = s, this } get panningModel() { return this._panner.panningModel } set panningModel(t) { this._panner.panningModel = t } get refDistance() { return this._panner.refDistance } set refDistance(t) { this._panner.refDistance = t } get rolloffFactor() { return this._panner.rolloffFactor } set rolloffFactor(t) { this._panner.rolloffFactor = t } get distanceModel() { return this._panner.distanceModel } set distanceModel(t) { this._panner.distanceModel = t } get coneInnerAngle() { return this._panner.coneInnerAngle } set coneInnerAngle(t) { this._panner.coneInnerAngle = t } get coneOuterAngle() { return this._panner.coneOuterAngle } set coneOuterAngle(t) { this._panner.coneOuterAngle = t } get coneOuterGain() { return this._panner.coneOuterGain } set coneOuterGain(t) { this._panner.coneOuterGain = t } get maxDistance() { return this._panner.maxDistance } set maxDistance(t) { this._panner.maxDistance = t } dispose() { return super.dispose(), this._panner.disconnect(), this.orientationX.dispose(), this.orientationY.dispose(), this.orientationZ.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this } } class um extends A { constructor() { var t = g(um.getDefaults(), arguments); super(t), this.name = "Recorder", this.input = new C({ context: this.context }), l(um.supported, "Media Recorder API is not available"), this._stream = this.context.createMediaStreamDestination(), this.input.connect(this._stream), this._recorder = new MediaRecorder(this._stream.stream, { mimeType: t.mimeType }) } static getDefaults() { return A.getDefaults() } get mimeType() { return this._recorder.mimeType } static get supported() { return null !== Rp && Reflect.has(Rp, "MediaRecorder") } get state() { return "inactive" === this._recorder.state ? "stopped" : "paused" === this._recorder.state ? "paused" : "started" } start() { return _(this, void 0, void 0, function* () { l("started" !== this.state, "Recorder is already started"); var t = new Promise(t => { const e = () => { this._recorder.removeEventListener("start", e, !1), t() }; this._recorder.addEventListener("start", e, !1) }); return this._recorder.start(), yield t }) } stop() { return _(this, void 0, void 0, function* () { l("stopped" !== this.state, "Recorder is not started"); var t = new Promise(e => { const s = t => { this._recorder.removeEventListener("dataavailable", s, !1), e(t.data) }; this._recorder.addEventListener("dataavailable", s, !1) }); return this._recorder.stop(), yield t }) } pause() { return l("started" === this.state, "Recorder must be started"), this._recorder.pause(), this } dispose() { return super.dispose(), this.input.dispose(), this._stream.disconnect(), this } } class pm extends A { constructor() { var t = g(pm.getDefaults(), arguments, ["threshold", "ratio"]); super(t), this.name = "Compressor", this._compressor = this.context.createDynamicsCompressor(), this.input = this._compressor, this.output = this._compressor, this.threshold = new k({ minValue: this._compressor.threshold.minValue, maxValue: this._compressor.threshold.maxValue, context: this.context, convert: !1, param: this._compressor.threshold, units: "decibels", value: t.threshold }), this.attack = new k({ minValue: this._compressor.attack.minValue, maxValue: this._compressor.attack.maxValue, context: this.context, param: this._compressor.attack, units: "time", value: t.attack }), this.release = new k({ minValue: this._compressor.release.minValue, maxValue: this._compressor.release.maxValue, context: this.context, param: this._compressor.release, units: "time", value: t.release }), this.knee = new k({ minValue: this._compressor.knee.minValue, maxValue: this._compressor.knee.maxValue, context: this.context, convert: !1, param: this._compressor.knee, units: "decibels", value: t.knee }), this.ratio = new k({ minValue: this._compressor.ratio.minValue, maxValue: this._compressor.ratio.maxValue, context: this.context, convert: !1, param: this._compressor.ratio, units: "positive", value: t.ratio }), y(this, ["knee", "release", "attack", "ratio", "threshold"]) } static getDefaults() { return Object.assign(A.getDefaults(), { attack: .003, knee: 30, ratio: 12, release: .25, threshold: -24 }) } get reduction() { return this._compressor.reduction } dispose() { return super.dispose(), this._compressor.disconnect(), this.attack.dispose(), this.release.dispose(), this.threshold.dispose(), this.ratio.dispose(), this.knee.dispose(), this } } class dm extends A { constructor() { var t = g(dm.getDefaults(), arguments, ["threshold", "smoothing"]); super(t), this.name = "Gate", this._follower = new x_({ context: this.context, smoothing: t.smoothing }), this._gt = new Sf({ context: this.context, value: hd(t.threshold) }), this.input = new C({ context: this.context }), this._gate = this.output = new C({ context: this.context }), this.input.connect(this._gate), this.input.chain(this._follower, this._gt, this._gate.gain) } static getDefaults() { return Object.assign(A.getDefaults(), { smoothing: .1, threshold: -40 }) } get threshold() { return cd(this._gt.value) } set threshold(t) { this._gt.value = hd(t) } get smoothing() { return this._follower.smoothing } set smoothing(t) { this._follower.smoothing = t } dispose() { return super.dispose(), this.input.dispose(), this._follower.dispose(), this._gt.dispose(), this._gate.dispose(), this } } class fm extends A { constructor() { var t = g(fm.getDefaults(), arguments, ["threshold"]); super(t), this.name = "Limiter", this._compressor = this.input = this.output = new pm({ context: this.context, ratio: 20, attack: .003, release: .01, threshold: t.threshold }), this.threshold = this._compressor.threshold, y(this, "threshold") } static getDefaults() { return Object.assign(A.getDefaults(), { threshold: -12 }) } get reduction() { return this._compressor.reduction } dispose() { return super.dispose(), this._compressor.dispose(), this.threshold.dispose(), this } } class _m extends A { constructor() { var t = g(_m.getDefaults(), arguments); super(t), this.name = "MidSideCompressor", this._midSideSplit = this.input = new X_({ context: this.context }), this._midSideMerge = this.output = new Y_({ context: this.context }), this.mid = new pm(Object.assign(t.mid, { context: this.context })), this.side = new pm(Object.assign(t.side, { context: this.context })), this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid), this._midSideSplit.side.chain(this.side, this._midSideMerge.side), y(this, ["mid", "side"]) } static getDefaults() { return Object.assign(A.getDefaults(), { mid: { ratio: 3, threshold: -24, release: .03, attack: .02, knee: 16 }, side: { ratio: 6, threshold: -30, release: .25, attack: .03, knee: 10 } }) } dispose() { return super.dispose(), this.mid.dispose(), this.side.dispose(), this._midSideSplit.dispose(), this._midSideMerge.dispose(), this } } class mm extends A { constructor() { var t = g(mm.getDefaults(), arguments); super(t), this.name = "MultibandCompressor", this._splitter = this.input = new cm({ context: this.context, lowFrequency: t.lowFrequency, highFrequency: t.highFrequency }), this.lowFrequency = this._splitter.lowFrequency, this.highFrequency = this._splitter.highFrequency, this.output = new C({ context: this.context }), this.low = new pm(Object.assign(t.low, { context: this.context })), this.mid = new pm(Object.assign(t.mid, { context: this.context })), this.high = new pm(Object.assign(t.high, { context: this.context })), this._splitter.low.chain(this.low, this.output), this._splitter.mid.chain(this.mid, this.output), this._splitter.high.chain(this.high, this.output), y(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]) } static getDefaults() { return Object.assign(A.getDefaults(), { lowFrequency: 250, highFrequency: 2e3, low: { ratio: 6, threshold: -30, release: .25, attack: .03, knee: 10 }, mid: { ratio: 3, threshold: -24, release: .03, attack: .02, knee: 16 }, high: { ratio: 3, threshold: -24, release: .03, attack: .02, knee: 16 } }) } dispose() { return super.dispose(), this._splitter.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.output.dispose(), this } } class gm extends A { constructor() { var t = g(gm.getDefaults(), arguments, ["low", "mid", "high"]); super(t), this.name = "EQ3", this.output = new C({ context: this.context }), this._internalChannels = [], this.input = this._multibandSplit = new cm({ context: this.context, highFrequency: t.highFrequency, lowFrequency: t.lowFrequency }), this._lowGain = new C({ context: this.context, gain: t.low, units: "decibels" }), this._midGain = new C({ context: this.context, gain: t.mid, units: "decibels" }), this._highGain = new C({ context: this.context, gain: t.high, units: "decibels" }), this.low = this._lowGain.gain, this.mid = this._midGain.gain, this.high = this._highGain.gain, this.Q = this._multibandSplit.Q, this.lowFrequency = this._multibandSplit.lowFrequency, this.highFrequency = this._multibandSplit.highFrequency, this._multibandSplit.low.chain(this._lowGain, this.output), this._multibandSplit.mid.chain(this._midGain, this.output), this._multibandSplit.high.chain(this._highGain, this.output), y(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._internalChannels = [this._multibandSplit] } static getDefaults() { return Object.assign(A.getDefaults(), { high: 0, highFrequency: 2500, low: 0, lowFrequency: 400, mid: 0 }) } dispose() { return super.dispose(), id(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._multibandSplit.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this._lowGain.dispose(), this._midGain.dispose(), this._highGain.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.Q.dispose(), this } } class vm extends A { constructor() { const e = g(vm.getDefaults(), arguments, ["url", "onload"]); super(e), this.name = "Convolver", this._convolver = this.context.createConvolver(), this._buffer = new w(e.url, t => { this.buffer = t, e.onload() }), this.input = new C({ context: this.context }), this.output = new C({ context: this.context }), this._buffer.loaded && (this.buffer = this._buffer), this.normalize = e.normalize, this.input.chain(this._convolver, this.output) } static getDefaults() { return Object.assign(A.getDefaults(), { normalize: !0, onload: x }) } load(t) { return _(this, void 0, void 0, function* () { this.buffer = yield this._buffer.load(t) }) } get buffer() { return this._buffer.length ? this._buffer : null } set buffer(t) { t && this._buffer.set(t), this._convolver.buffer && (this.input.disconnect(), this._convolver.disconnect(), this._convolver = this.context.createConvolver(), this.input.chain(this._convolver, this.output)); t = this._buffer.get(); this._convolver.buffer = t || null } get normalize() { return this._convolver.normalize } set normalize(t) { this._convolver.normalize = t } dispose() { return super.dispose(), this._buffer.dispose(), this._convolver.disconnect(), this } } const ym = b().transport; const xm = b().destination, wm = b().destination; const bm = b().listener; const Tm = b().draw; const Sm = b(); const km = w, Am = Fd, Cm = Zd
  })(), Mm
});